<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读《JavaScript高级程序设计》（5）]]></title>
    <url>%2Fnote%2F2018%2Fundefined04%2F68e9d4f.html</url>
    <content type="text"><![CDATA[[美] Nicholas C.Zakes 著 李松峰 曹力 译 （第三版） 第二十章 Json 第二十一章 Ajax 与Comet 第二十章 Json曾经有一段时间，XML是互联网上传输结构化数据的事实标准。Web服务的第一次浪潮很大程度上都是建立在XML之上的，突出的特点是服务器与服务器间通信。然而，业界一直不乏质疑XML的声音。不少人认为XML过于烦琐、冗长。 JSON(JavaScript Object Notation ，JS对象表示方法) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。虽然 具有相同的语法形式，但JSON并不从属于JavaScript，而且，并不是只有JavaScript才能使用JSON，毕竟JSON只是一种数据格式。很多编程语言都有针对JSON的解析器和序列化器。 JSON采用完全独立于语言的文本格式。 20.1 语法JSON的语法可以表示以下三种类型的值。 简单值 使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和null。但JSON不支持JavaScript中的特殊值undefined。 对象 对象作为一种复杂数据类型，表示的是一组无序的键值对（key-value）。而每个键值对中的值可以是简单值，也可以是复杂类型的值。 数组 数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象和数组。 JSON不支持变量、函数或者对象实例，它就是一种表示结构化数据的格式，虽然与JavaScript中表示数据的某些语法相同，但它并不局限于JavaScript范畴。 对象JSON中的对象与JavaScript字面量稍微有些不同，下面是一个JavaScript中的对象字面量： 1234var person = &#123; name:"Nicholas", age:29&#125; 这是JavaScript创建对象字面量的标准方式，但JSON中的对象要求给属性加引号。JSON表示上述对象方式如下： 1234&#123; "name":"Nicholas", "age":29&#125; 与JavaScript的对象字面量相比，JSON对象有两个地方不同： 没有声明变量（JSON中没有变量的概念）。 没有末尾分号（因为不是JavaScript语句，所以没有分号） 把数组和对象结合起来，可以构成更复杂的数据集合： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[ &#123; "title":"Professional JavaScript", "authors":[ "Nicholas C. zakas" ], "editons":3, "year":2011 &#125;, &#123; "title":"Professional JavaScript", "authors":[ "Nicholas C. zakas" ], "editons":2, "year":2009 &#125;, &#123; "title":"Professional Ajax", "authors":[ "Nicholas C. zakas", "JereMy Mcpeak", "Joe Fawcett" ], "editons":2, "year":2008 &#125;, &#123; "title":"Professional Ajax", "authors":[ "Nicholas C. zakas", "JereMy Mcpeak", "Joe Fawcett" ], "editons":1, "year":2007 &#125;, &#123; "title":"Professional Javascript", "authors":[ "Nicholas C. zakas" ], "editons":1, "year":2006 &#125;] 这个数组中包含一些图书的对象。每个对象都有几个属性，其中一个属性是”authors”，这个属性的值又是一个数组。对象和数组通常是JSON数据结构的最外层形式(当然这不是强制规定的)，利用它们可以创造出各种各样的数据结构。 对比内容 JSON JS对象 键名 必须是加双引号 可允许不加、加单引号、加双引号 属性值 只能是数值（10进制）、字符串（双引号，单引号会导致错误）、布尔值和null， 也可以是数组或者符合JSON要求的对象， 不能是函数、NaN, Infinity, -Infinity和undefined。不支持变量。 爱啥啥 逗号问题 最后一个属性后面不能有逗号 可以 数值 前导0不能用，小数点后必须有数字 没限制 20.2解析与序列化JSON之所以流行，拥有与JavaScript类似的语法并不是全部原因。更重要的一个原因是，可以把JSON数据结构解析为有用的JavaScript对象。与XML数据结构要解析成DOM文档而且从中提取数据极为麻烦相比，JSON可以解析为JavaScript对象的优势极其明显。就以上一节中包含一组图书的JSON数据结构为例，在解析为JavaScript对象后，只需要下面一行简单的代码就可以取得第三本书的书名： 1book[2].title 当然，这是是假设解析JSON数据结构后得到的对象保存到了变量books中。再看看下面在DOM结构中查找数据的代码： 1doc.getElementsByTagName("book")[2].getAttribute("title") 看看这些多余的方法调用，就不难理解为什么JSON能得到JavaScript开发人员的欢迎了。从此以后，JSON就成为WEB服务开发中交换数据的事实标准。 20.2.1JSON对象早期的JSON解析器基本上就是使用JavaScript的eval()函数。由于JSON是JavaScript语法的子集，因此eval()可以解析、解释并返回JavaScript对象和数组。ES5对解析JSON的行为进行规范，定义了全局对象JSON。 JSON对象有两个方法：stringify()和parse()。在最简单的情况下，这两个方法分别用于把JavaScript对象序列化为JSON字符串和把JSON字符串解析为原生JavaScript值。例如： 1234567891011var book = &#123; title: "Professional Javascript", authors: [ "Nicholas C. Zakas" ], eidtion: 3, year: 2011&#125;;var jsonText = JSON.stringify(book);console.log(jsonText); 这个例子使用JSON.stringify()把一个JavaScript对象序列化为一个JSON字符串，然后将它保存在jsonText中。默认情况下，JSON.stringify()输出的JSON字符串不包含任何任何空格字符或缩进，因此保存在jsonText中的字符串如下： 1&#123;"title":"Professional Javascript","authors":["Nicholas C. Zakas"],"eidtion":3,"year":2011&#125; 在序列化JavaScript对象时，所有函数及原型成员都会有意被忽略，不体现在结果中。此外，值为undefined的任何属性也都会跳过。结果中最终都是值为有效JSON数据类型的实例属性。将JSON字符串直接传递给JSON.parse()就可以得到相应的JavaScript值。使用下列代码就可以创建与类似book类似的对象： 12345var bookCopy = JSON.parse(jsonText);console.log(bookCopy["edition"]); // 3 //有点问题：当把 JSON.parse(jsonText)的值直接赋值给bookCopy时，抛出错误。。//坑，待填 注意，虽然book与bookCopy具有相同的属性，但它们是两个独立的、没有任何关系的对象。如果传给JSON.parse()的字符串不是有效的JSON，该方法会抛出错误。 20.2.2序列化选项实际上，JSON.stringify()除了要序列化JavaScript对象外，还可以接收另外两个参数，这两个参数用于指定以不同的方式序列化JavaScript对象。第一个参数是个过滤器，可以是一个数组，也可以是一个函数；第二个参数是一个选项，表示是否在JSON字符串中保留缩进。单独或组合使用这两个参数，可以更全面深入地控制JSON的序列化。 第二个参数可以是函数，也可以是一个数组 如果第二个参数是一个函数，那么序列化过程中的每个属性都会被这个函数转化和处理 如果第二个参数是一个数组，那么只有包含在这个数组中的属性才会被序列化到最终的JSON字符串中 如果第二个参数是null，那作用上和空着没啥区别，但是不想设置第二个参数，只是想设置第三个参数的时候，就可以设置第二个参数为null 1. 过滤结果如果过滤器参数是数组，那么JSON.stringify()的结果中将只包含数组中列出的属性。来看下面的例子。 1234567891011var book = &#123; "title":"Professional Javascript", "authors":[ "Nicholas C. Zakas" ], edition:3, year:2011&#125;;var jsonText = JSON.stringify(book,["title","edition"]);console.log(jsonText); // &#123;"title":"Professional Javascript","edition":3&#125; JSON.stringify()的第二个参数是一个数组，其中包含两个字符串：&quot;title&quot;和&quot;edition&quot;。这两个属性与将要序列化的对象中的属性是对应的，因此在返回的结果字符串中，就只会包含这两个属性： 1&#123;&quot;title&quot;:&quot;Professional Javascript&quot;,&quot;edition&quot;:3&#125; 如果第二个参数是函数，行为会稍有不同。传入的函数接收两个参数，属性名和属性值。根据属性名可以知道应该如何处理要序列化的对象中的属性。属性名只能是字符串，而在值不是键值对结构的情况下，键名可以是空字符串。 为了改变序列化对象的结果，函数返回的值就是相应键的值。不过要注意，如果函数返回了undefined，那么相应的属性会被忽略。还是看一个例子吧。 123456789101112131415161718192021222324var book = &#123; "title":"Professional Javascript", "authors":[ "Nicholas C. Zakas" ], edition:3, year:2011&#125;;var jsonText = JSON.stringify(book,function(key,value) &#123; switch (key) &#123; case "authors": return value.join(",") case "year": return 5000; case "edition": return undefined; default: return value; &#125;&#125;); 这里，函数过滤器根据传入的键来决定结果。如果键为”authors”，就将数组连接为一个字符串；如果键为”year”，则将其值设置为5000；如果键为”edition”，通过返回undefined删除该属性。最后，一定要提供default项，此时返回传入的值，以便其他值都能正常出现在结果中。实际上，第一次调用函数过滤器，传入的键是一个空字符串，而值就是book对象。序列化后的JSON字符串付下所示： 1&#123;&quot;title&quot;:&quot;Professional Javascript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas&quot;,&quot;year&quot;:5000&#125; 要序列化的对象中的每一个对象都要经过过滤器，因此数组中的每个带有这些属性的对象经过过滤器之后，每个对象都只包含”title”、”authors”和”year”属性。 2. 字符串缩进JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的是每个级别缩进的空格数。例如：要在每个级别缩进4个空格，可以这样： 123456789101112131415161718192021222324var book = &#123; "title": "Professional Javascript", "authors": [ "Nicholas C. Zakas" ], edition: 3, year: 2011&#125;var jsonText = JSON.stringify(book, null, 4);/*jsonText&#123; "title": "Professional Javascript", "authors": [ "Nicholas C. Zakas" ], "edition": 3, "year": 2011&#125;*/ 不知道读者注意到没有，JSON.stringify()也在结果字符串中插入了换行符以提高可读性。只要传入有效的控制缩进的参数值，结果字符串就会包含换行符。（只缩进而不换行意义不大）最大缩进空格数为10，所有大于10的值都会自动转换为10。如果缩进参数是一个字符串而非数值，则这个字符串将在JSON字符串中被用作缩进字符（不在使用空格）。在使用字符串的情况下，可以将缩进字符设置为制表符，或者两个短划线之类的任意字符。var jsonText = JSON.stringify(book,null,&quot; - -&quot;)； 这样，jsonText中的字符串将变成如下所示： 123456789101112131415161718192021222324var book = &#123; "title": "Professional Javascript", "authors": [ "Nicholas C. Zakas" ], edition: 3, year: 2011&#125;var jsonText = JSON.stringify(book,null," - -");console.log(jsonText);/*&#123; - -"title": "Professional Javascript", - -"authors": [ - - - -"Nicholas C. Zakas" - -], - -"edition": 3, - -"year": 2011&#125;*/ 缩进字符串最长不能超过10个字符长。如果字符串长度超过了10个，结果中将只出现前10个字符。 3. toJSON()方法有时候，JSON.stringify()还是不能满足对某些对象进行自定义序列化的需求。在这些情况下，可以给对象定义toJSON()方法，返回其自身的JSON数据格式。原生Date对象有一个toJSON()方法，能够将JavaScript的Date对象自动转换成ISO 8601日期字符串(与在Date对象上调用toISOString()的结果一样)。可以为任何对象添加toJSON()方法，如： 123456789101112131415var book = &#123; "title": "Professional Javascript", "authors": [ "Nicholas C. Zakas" ], edition: 3, year: 2011, toJSON:function() &#123; return this.title; &#125;&#125;;var jsonText = JSON.stringify(book);console.log(jsonText);// "Professional Javascript" 以上代码在book对象上定义了一个toJSON()对象，该方法放回图书的书名。与Date对象类似，这个对象也将被序列化为一个简单的字符串而非对象。可以让toJSON()方法返回任何值，它都能正常工作。比如，可以让这个方法返回undefined，此时如果包含它的对象嵌入在另一个对象中，会导致它的值变成null，而如果它是顶级对象，结果就是undefined。 toJSON()可以作为函数过滤器的补充，因此理解序列化的内部顺序十分重要。假设把一个对象传入JSON.stringify()，序列化该对象的顺序如下： 如果存在toJSON()方法而且能通过它取得有效的值，则调用该方法。否则返回对象本身。 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第一步返回的值。 对第二步返回的值进行相应的序列化。 如果提供了第三个参数，执行相应的格式化。 无论是考虑定义toJSON()的方法，还是考虑使用函数过滤器，亦或需要同时使用两者，理解这个顺序都是至关重要的。 20.2.3解析选项JSON.parse()方法也可以接收另一个参数，该参数是一个函数，将在每个键值对上调用。为了区别JSON.stringify()接收的替换（过滤）函数（replacer），这个函数被称为还原函数(reviver)，但实际上这两个函数的签名是相同的——它们都接收两个参数，一个键和一个值，而且都需要返回一个值。 如果还原函数返回undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。在将日期字符串转换为Date对象时，经常要用到还原函数。例如： 123456789101112131415161718192021var book = &#123; "title": "Professional Javascript", "authors": [ "Nicholas C. Zakas" ], edition: 3, year: 2011, releaseDate: new Date(2011, 11, 1)&#125;;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText, function (key, value) &#123; if (key === "releaseDate") &#123; return new Date(value); &#125; else &#123; return value; &#125;&#125;)console.log(bookCopy.releaseDate.getFullYear()); 以上代码先是为book对象新增了一个releaseDate属性，该属性保存着一个Date对象。这个对象经过序列化之后变成有效的JSON字符串，然后经过解析又在bookCopy中还原为一个Date对象。还原函数在遇到releaseDate键时，会基于相应的值创建一个新的Date对象。结果就是bookCopy.releaseDate属性中会保存一个Date对象 。正因为如此，才能基于这个对象调用getFullYear()方法。 参考链接: 深入理解 JSON 第二十一章 Ajax与Comet 本章参考： w3cAJAX 教程 阮一峰ajax 简书《JS高程》—— ajax AJAX简介AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 Ajax的核心是XMLHttpRequest对象，简称（XHR），这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现。 XHR为向服务器发送请求和解析服务器响应提供了流畅的接口。能够以异步的方式从服务器取得更多信息。可以使用XHR对象取得新数据，然后通过DOM将新数据插入到页面中，虽然名字中包含XML的成分，但Ajax通信与数据格式无关；这种技术就是无须刷新页面即可从服务器取得数据，但不一定是XML数据。 具体来说，AJAX 包括以下几个步骤。 创建 XMLHttpRequest 实例 发出 HTTP 请求 接收服务器传回的数据 更新网页数据 概括起来，就是一句话，AJAX 通过原生的XMLHttpRequest对象发出 HTTP 请求，得到服务器返回的数据后，再进行处理。现在，服务器返回的都是 JSON 格式的数据，XML 格式已经过时了，但是 AJAX 这个名字已经成了一个通用名词，字面含义已经消失了。XMLHttpRequest对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。 比如 当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 21.1 XMLHttpRequest对象（XHR）所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。 创建 XMLHttpRequest 对象的语法： 1variable=new XMLHttpRequest(); 老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象： 1variable=new ActiveXObject("Microsoft.XMLHTTP"); 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ： 123456789var xmlhttp;if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; 21.1.1 XHR的用法open() 和 send() 方法向服务器发送请求 如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法： open() 方法还能再接收两个参数：要随请求一起发送的用户名和密码。带有这两个参数的请求可以通过 SSL 发送给服务器上的页面，如下面的例子所示。 1xhr.open("get", "example.php", true, "username", "password"); // 不要这样做！！ 即便可以考虑这种安全机制，但还是尽量不要这样做。把用户名和密码保存在 JavaScript 代码中本身就是极为不安全的。任何人，只要他会使用 JavaScript 调试器，就可以通过查看相应的变量发现纯文本形式的用户名和密码。 只能向同一个域中使用相同端口和协议的URL发送请求。如果URL与启动请求的页面有任何差别，都会引发安全错误。 12xmlhttp.open("GET","test1.txt",true);xmlhttp.send(); 方法 描述 open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POST,url：文件在服务器上的位置async：true（异步）或 false（同步） send(string) 将请求发送到服务器。string：仅用于 POST 请求 我们不推荐使用 async=false，但是对于一些小型的请求，也是可以的。 请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。 注释：当您使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可： 123xmlhttp.open("GET","test1.txt",false);xmlhttp.send();document.getElementById("myDiv").innerHTML=xmlhttp.responseText; 亲自试一试 xhr.open(&#39;GET&#39;, &quot;example.php&quot;, true);这行代码会启动一个针对example.php的get请求。说明两点： URL相对于执行代码的当前页面（当然也可以使用绝对路径） 调用open()并不会真正发送请求。而只是启动一个请求已备发送。 要发送特定的请求，必须向下面这样调用send()方法。 12xhr.open("get","example.txt",false);xhr.send(null); send()接受一个参数：要作为请求主体发送的数据。如果不需要通过请求主体发送数据，则必须传入null，因为这个参数对有些浏览器是必需的。调用send()之后，请求正式被分派到服务器。 GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 下面的表格比较了两种 HTTP 方法：GET 和 POST。 GET POST 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。 其他 HTTP 请求方法 下面的表格列出了其他一些 HTTP 请求方法： 方法 描述 HEAD 与 GET 相同，但只返回 HTTP 报头，不返回文档主体。 PUT 上传指定的 URI 表示。 DELETE 删除指定资源。 OPTIONS 返回服务器支持的 HTTP 方法。 CONNECT 把请求连接转换到透明的 TCP/IP 通道。 POST 是否比 GET 安全 是的， POST要比GET安全一点点，注意，是一点点。。。 说这两者都是明文传送当然是没有错的了，但是这里有一个细节，就是GET的URL会被放在浏览器历史和WEB 服务器日志里面。 POST 发完基本就木有了。。 所以如果你把关键数据放在GET里面，被人偷窥了浏览器，或者WEB服务器被入侵日志被人倒去了，基本泄露可能性100%。而POST来说，日志没有记录，只要数据库服务器不被入侵，基本还是安全的。 GET 相对 POST 的优势是什么 最大的优势是， GET 的URL可以人肉手输啊。。。你在地址栏打个POST给我看看。本质上面， GET 的所有信息都在URL， 所以很方便的记录下来重复使用。 所以如果你希望 请求中的URL可以被手动输入 请求中的URL可以被存在书签里，或者历史里，或者快速拨号里面，或者分享给别人。 请求中的URL是可以被搜索引擎收录的。 带云压缩的浏览器，比如Opera mini/Turbo 2, 只有GET才能在服务器端被预取的。 请求中的URL可以被缓存。 请使用GET. 大家有没有注意到，其实这里面很多方面的要求是和网站的运营相关的，而不是技术相关的。任何的技术行为中，其实多多少少都能看到商业的影子。 反之，就用POST. 特别是有一些东西你是不想让人家可以在浏览器地址栏里面可以输入的。比如，如果你设计一个blog系统, 设计这样一个URL来删掉所有帖子。 因为它们表达的语义不一样，这决定了主干网络可以对其做不同的处理。 get表达的是一种幂等的，只读的，纯粹的操作，即它除了返回结果不应该会产生其它副作用（如写数据库），因此绝大部分get请求（通常超过90%）都直接被CDN缓存了，这能大大减少web服务器的负担。 而post所表达的语义是非幂等的，有副作用的操作，所以必须交由web服务器处理。 把所有get请求换成post，意味着主干网络上的所有CDN都废掉了，web服务器要处理的请求数量将成百上千倍地增加，显然这不是一个聪明的做法！ 幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同。按照RFC规范，PUT，DELETE和安全方法都是幂等的。同样，这也仅仅是规范，服务端实现是否幂等是无法确保的。引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新时遇到POST会给用户提示的原因：POST语义不是幂等的，重复请求可能会带来意想不到的后果。 转自： 知乎 post 相比get 有很多优点，为什么现在的HTTP通信中大多数请求还是使用get？ 99%的人都理解错了HTTP中GET与POST的区别 GET和POST是什么？HTTP协议中的两种发送请求的方法。 HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。 HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 那么，“标准答案”里的那些区别是怎么回事？ 在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？ 在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 你以为本文就这么结束了？ 我们的大BOSS还等着出场呢。。。 这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。 GET和POST还有一个重大区别，简单的说： GET产生一个TCP数据包；POST产生两个TCP数据包。 长的说： 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 XHR对象的属性。示例中请求是同步的，JavaScript代码会等到服务器响应后再继续执行。收到相应后，响应的数据会自动填充XHR对象的属性。属性简介如下： responseText：获得字符串形式的响应数据。 responseXML：获得 XML 形式的响应数据。如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存着包含响应数据的XML DOM文档。 status：响应的HTTP状态。 HTTP状态码大全 常见的状态码： 200, OK，访问正常 301, Moved Permanently，永久移动 302, Move temporarily，暂时移动 304, Not Modified，未修改 307, Temporary Redirect，暂时重定向 401, Unauthorized，未授权 403, Forbidden，禁止访问 404, Not Found，未发现指定网址 500, Internal Server Error，服务器发生错误 基本上，只有2xx和304的状态码，表示服务器返回是正常状态。 statusText：HTTP状态的说明。不同于status属性，该属性包含整个状态信息，比如”200 OK“。 在收到响应后，第一步是检查status属性，以确定响应已经成功返回。可以将200 OK作为成功的标志。此时responseText属性的内容就绪。而且在内容类型正确的情况下，responseXML也能够访问了。 304状态码表示请求的资源没有被修改，可以直接使用浏览器中缓存的版本；当然，也意味着响应是有效的，为确保接受到适当的响应，应该像下面这样检查上述两种状态代码。 12345if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: "+xhr.status); &#125; readyState属性 0：未初始化。尚未调用open()方法 1：启动。已经调用open()方法，但尚未调用send()方法 2：发送。已经调用send()方法，但尚未接受到响应 3：接收，已经接受到部分响应数据。 4：完成。已经接受到全部响应数据，而且已经可以在客户端使用了。 123456789var xhr = new XMLHttpRequest(); console.log(xhr.readyState); // 0 xhr.open('GET', "hello.json", true); xhr.send(); console.log(xhr.readyState); // 1 xhr.onreadystatechange = function() &#123; console.log(xhr.readyState); // 2 3 4 &#125; 这里使用的异步调用open()方法，如果是同步调用，只会有0,4两个数字，同步调用open()，JS必定会在数据返回时才会执行后续的代码，数据返回时候readyState已经是4了，反过来说，只有为4的时候，返回的数据才真正的准备好 。 只要readyState属性的值由一个值变为另一个值，都会触发一次readystatechange事件。可以利用这个事件来检测每次状态变化后readyState的值。通常，我们只对readyState值为4的阶段感兴趣，因为这时所有数据都已经就绪。 onreadystatechange 事件 当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 当 readyState 等于 4 且状态为 200 时，表示响应已就绪： 1234567xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125; &#125; 亲自试一试 w3c: AJAX ASP/PHP 请求实例 AJAX 数据库实例 AJAX XML 实例 21.1.2HTTP头部信息每个HTTP请求和响应都会带有相应的头部信息，其中有的对开发人员有用，有的也没什么用。XHR对象提供了操作这两种头部（即请求头部和响应头部）信息的方法。默认情况下，在发送XHR请求时，还会发送下列信息。 Accept：浏览器能够处理的内容类型。 Accept-Charset：浏览器能够处理的字符集。 Accept-Encoding：浏览器能够处理的压缩编码。 Accept-Language：浏览器当前设置的语言。 Connection：浏览器与当前服务器之间连接的类型。 Cookie：当前页面设置的任何Cookie。 Host：发出请求的页面所在的域。 Referer：发出请求的页面的URI。注意，正确的拼写是referrer，但HTTP规范将这个头部字段拼写错了，将错就错。 User-Agent：浏览器的用户代理字符串。 setRequestHeader()方法可以设置自定义的请求头部信息，这个方法接受两个参数：头部字段的名称和头部字段的值。要成功发送请求头部信息，必须在调用open()方法之后且调用send()方法之前调用setRequsetHeader()。 12345678910111213var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125; &#125;;xhr.open("get", "example.php", true);xhr.setRequestHeader("MyHeader", "MyValue");xhr.send(null); getResponseHeader()方法可以取得相应的响应头部信息，需传入头部字段名称 getAllResponseHeaders()方法可以取得由一个包含所有头部信息的长字符串。 在服务器端，也可以利用头部信息向浏览器发送额外的、结构化的数据。在没有自定义信息的情况下，getAllResponseHeaders() 方法通常会返回如下所示的多行文本内容： 123456Date: Sun, 14 Nov 2004 18:04:03 GMTServer: Apache/1.3.29 (Unix)Vary: AcceptX-Powered-By: PHP/4.3.8Connection: closeContent-Type: text/html; charset=iso-8859-1 这种格式化的输出可以方便我们检查响应中所有头部字段的名称，而不必一个一个地检查某个字段是否存在。 21.2XMLHttpRequest 2级FormData 现代 Web 应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest 2 级为此定义了 FormData 类型。 FormData 为序列化表单以及创建与表单格式相同的数据（用于通过 XHR 传输）提供了便利。下面的代码创建了一个 FormData 对象，并向其中添加了一些数据。 12var data = new FormData();data.append("name", "Nicholas"); 这个 append() 方法接收两个参数：键和值，分别对应表单字段的名字和字段中包含的值。可以像这样添加任意多个键值对儿。 而通过向 FormData 构造函数中传入表单元素，也可以用表单元素的数据预先向其中填入键值对儿： 1var data = new FormData(document.forms[0]); 创建了 FormData 的实例后，可以将它直接传给 XHR 的 send() 方法，如下所示： 123456789101112131415var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125;&#125;;xhr.open("post","postexample.php", true);var form = document.getElementById("user-info");xhr.send(new FormData(form)); 使用 FormData 的方便之处体现在不必明确地在 XHR 对象上设置请求头部。XHR 对象能够识别传入的数据类型是 FormData 的实例，并配置适当的头部信息。 超时设定 IE8 为 XHR 对象添加了一个 timeout 属性，表示请求在等待响应多少毫秒之后就终止。在给 timeout 设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发 timeout 事件，进而会调用 ontimeout 事件处理程序。这项功能后来也被收入了 XMLHttpRequest 2 级规范中。来看下面的例子。 123456789101112131415161718192021var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; try &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125; catch (ex)&#123; // 假设由 ontimeout 事件处理程序处理 &#125; &#125;&#125;;xhr.open("get", "timeout.php", true);xhr.timeout = 1000; // 将超时设置为 1 秒钟（仅适用于 IE8+）xhr.ontimeout = function()&#123; alert("Request did not return in a second.");&#125;;xhr.send(null); 这个例子示范了如何使用 timeout 属性。将这个属性设置为 1000 毫秒，意味着如果请求在 1 秒钟内还没有返回，就会自动终止。请求终止时，会调用 ontimeout 事件处理程序。 但此时 readyState 可能已经改变为 4 了，这意味着会调用 onreadystatechange 事件处理程序。 可是，如果在超时终止请求之后再访问 status 属性，就会导致错误。为避免浏览器报告错误，可以将检查 status 属性的语句封装在一个 try-catch 语句当中。 overrideMimeType() 方法 Firefox 最早引入了 overrideMimeType() 方法，用于重写 XHR 响应的 MIME 类型。这个方法后来也被纳入了 XMLHttpRequest 2 级规范。 因为返回响应的 MIME 类型决定了 XHR 对象如何处理它，所以提供一种方法能够重写服务器返回的 MIME 类型是很有用的。比如，服务器返回的 MIME 类型是 text/plain，但数据中实际包含的是 XML。根据 MIME 类型，即使数据是 XML，responseXML 属性中仍然是 null。通过调用 overrideMimeType() 方法，可以保证把响应当作 XML 而非纯文本来处理。 1234var xhr = createXHR();xhr.open("get", "text.php", true);xhr.overrideMimeType("text/xml");xhr.send(null); 这个例子强迫 XHR 对象将响应当作 XML 而非纯文本来处理。调用 overrideMimeType() 必须在 send()方法之前，才能保证重写响应的 MIME 类型。 21.3 进度事件 Progress Events 规范是 W3C 的一个工作草案，定义了与客户端服务器通信有关的事件。这些事件最早其实只针对 XHR 操作，但目前也被其他 API 借鉴。有以下 6 个进度事件。 loadstart：在接收到响应数据的第一个字节时触发。 progress：在接收响应期间持续不断地触发。 error：在请求发生错误时触发。 abort：在因为调用 abort() 方法而终止连接时触发。 load：在接收到完整的响应数据时触发。 loadend：在通信完成或者触发 error、abort 或 load 事件后触发。 每个请求都从触发 loadstart 事件开始，接下来是一或多个 progress 事件，然后触发 error、abort 或 load 事件中的一个，最后以触发 loadend 事件结束。这些事件大都很直观，但其中两个事件有一些细节需要注意。 load 事件 Firefox 在实现 XHR 对象的某个版本时，曾致力于简化异步交互模型。最终，Firefox 实现中引入了 load 事件，用以替代 readystatechange 事件。响应接收完毕后将触发 load 事件，因此也就没有必要去检查 readyState 属性了。 而 onload 事件处理程序会接收到一个 event 对象，其 target 属性就指向 XHR 对象实例，因而可以访问到 XHR 对象的所有方法和属性。 然而，并非所有浏览器都为这个事件实现了适当的事件对象。结果，开发人员还是要像下面这样被迫使用 XHR 对象变量。 12345678910var xhr = createXHR();xhr.onload = function()&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125;&#125;;xhr.open("get", "altevents.php", true);xhr.send(null); 只要浏览器接收到服务器的响应，不管其状态如何，都会触发 load 事件。而这意味着你必须要检查 status 属性，才能确定数据是否真的已经可用了 progress 事件 Mozilla 对 XHR 的另一个革新是添加了 progress 事件，这个事件会在浏览器接收新数据期间周期性地触发。 而 onprogress 事件处理程序会接收到一个 event 对象，其 target 属性是 XHR 对象，但包含着三个额外的属性：lengthComputable、position 和 totalSize。 其中，lengthComputable 是一个表示进度信息是否可用的布尔值，position 表示已经接收的字节数，totalSize 表示根据 Content-Length 响应头部确定的预期字节数。有了这些信息，我们就可以为用户创建一个进度指示器了。下面展示了为用户创建进度指示器的一个示例。 123456789101112131415161718var xhr = createXHR();xhr.onload = function(event)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125;&#125;;xhr.onprogress = function(event)&#123; var divStatus = document.getElementById("status"); if (event.lengthComputable)&#123; divStatus.innerHTML = "Received " + event.position + " of " + event.totalSize +" bytes"; &#125;&#125;;xhr.open("get", "altevents.php", true);xhr.send(null); 为确保正常执行，必须在调用 open() 方法之前添加 onprogress 事件处理程序。在前面的例子中，每次触发 progress 事件，都会以新的状态信息更新 HTML 元素的内容。如果响应头部中包含 Content-Length 字段，那么也可以利用此信息来计算从响应中已经接收到的数据的百分比。 21.4跨域源资源共享跨来源资源共享（CORS），亦译为跨域资源共享，是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒)脚本的方法，以避开浏览器的同源策略[1]，是 JSONP模式的现代版。与 JSONP 不同，CORS 除了 GET 请求方法以外也支持其他的 HTTP 请求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS[2]。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。 （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 参考阮一峰跨域资源共享 CORS 详解 通过 XHR 实现 Ajax 通信的一个主要限制，来源于跨域安全策略。默认情况下，XHR 对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。但是，实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的。 同源策略：同一协议、同一域名、同一端口 凡有一项不满足 即失败。 CORS（Cross-Origin Resource Sharing，跨源资源共享）是 W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。 CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。比如一个简单的使用 GET 或 POST 发送的请求，它没有自定义的头部，而主体内容是 text/plain。在发送该请求时，需要给它附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。下面是 Origin 头部的一个示例： 1Origin: http://www.nczonline.net 如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发”*”）。例如： 1Access-Control-Allow-Origin: http://www.nczonline.net 如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。 1、IE 对 CORS 的实现微软在 IE8 中引入了 XDR（XDomainRequest）类型。这个对象与 XHR 类似，但能实现安全可靠的跨域通信。XDR 对象的安全机制部分实现了 W3C 的 CORS 规范。以下是 XDR 与 XHR 的一些不同之处。 cookie 不会随请求发送，也不会随响应返回。 只能设置请求头部信息中的 Content-Type 字段。 不能访问响应头部信息。 只支持 GET 和 POST 请求。 这些变化使 CSRF（Cross-Site Request Forgery，跨站点请求伪造）和 XSS（Cross-Site Scripting，跨站点脚本）的问题得到了缓解。 被请求的资源可以根据它认为合适的任意数据（用户代理、来源页面等）来决定是否设置 Access-Control- Allow-Origin 头部。作为请求的一部分，Origin 头部的值表示请求的来源域，以便远程资源明确地识别 XDR 请求。 XDR 对象的使用方法与 XHR 对象非常相似。也是创建一个 XDomainRequest 的实例，调用 open() 方法，再调用 send() 方法。 但与 XHR 对象的 open() 方法不同，XDR 对象的 open() 方法只接收两个参数：请求的类型和 URL。 所有 XDR 请求都是异步执行的，不能用它来创建同步请求。请求返回之后，会触发 load 事件，响应的数据也会保存在 responseText 属性中，如下所示。 123456var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;;xdr.open(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;);xdr.send(null); 在接收到响应后，你只能访问响应的原始文本；没有办法确定响应的状态代码。而且，只要响应有效就会触发 load 事件，如果失败（包括响应中缺少 Access-Control-Allow-Origin 头部）就会触发 error 事件。 遗憾的是，除了错误本身之外，没有其他信息可用，因此唯一能够确定的就只有请求未成功了。要检测错误，可以像下面这样指定一个 onerror 事件处理程序。 123456789var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;;xdr.onerror = function()&#123; alert("An error occurred.");&#125;;xdr.open("get", "http://www.somewhere-else.com/page/");xdr.send(null); 鉴于导致 XDR 请求失败的因素很多，因此建议你不要忘记通过 onerror 事件处理程序来捕获该事件；否则，即使请求失败也不会有任何提示。 在请求返回前调用 abort() 方法可以终止请求： 1xdr.abort(); // 终止请求 与 XHR 一样，XDR 对象也支持 timeout 属性以及 ontimeout 事件处理程序。下面是一个例子。 12345678910111213var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;;xdr.onerror = function()&#123; alert("An error occurred.");&#125;;xdr.timeout = 1000;xdr.ontimeout = function()&#123; alert("Request took too long.");&#125;;xdr.open("get", "http://www.somewhere-else.com/page/");xdr.send(null); 上述例子会在运行 1 秒钟后超时，并随即调用 ontimeout 事件处理程序。 为支持 POST 请求，XDR 对象提供了 contentType 属性，用来表示发送数据的格式，如下面的例子所示。 12345678910var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;;xdr.onerror = function()&#123; alert("An error occurred.");&#125;;xdr.open("post", "http://www.somewhere-else.com/page/");xdr.contentType = "application/x-www-form-urlencoded";xdr.send("name1=value1&amp;name2=value2"); 这个属性是通过 XDR 对象影响头部信息的唯一方式。 2、其他浏览器对 CORS 的实现 Firefox 3.5+、Safari 4+、Chrome、iOS 版 Safari 和 Android 平台中的 WebKit 都通过 XMLHttpRequest 对象实现了对 CORS 的原生支持。在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。 要请求位于另一个域中的资源，使用标准的 XHR 对象并在 open() 方法中传入绝对 URL 即可，例如： 123456789101112var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125;&#125;;xhr.open("get", "http://www.somewhere-else.com/page/", true);xhr.send(null); 与 IE 中的 XDR 对象不同，通过跨域 XHR 对象可以访问 status 和 statusText 属性，而且还支持同步请求。 跨域 XHR 对象也有一些限制，但为了安全这些限制是必需的。以下就是这些限制。 不能使用 setRequestHeader()设置自定义头部。 不能发送和接收 cookie。 调用 getAllResponseHeaders() 方法总会返回空字符串。 由于无论同源请求还是跨源请求都使用相同的接口，因此对于本地资源，最好使用相对 URL，在访问远程资源时再使用绝对 URL。这样做能消除歧义，避免出现限制访问头部或本地 cookie 信息等问题。 3、Preflighted Requests CORS 通过一种叫做 Preflighted Requests 的透明服务器验证机制支持开发人员使用自定义的头部、GET 或 POST 之外的方法，以及不同类型的主体内容。在使用下列高级选项来发送请求时，就会向服务器发送一个 Preflight 请求。这种请求使用 OPTIONS 方法，发送下列头部。 Origin：与简单的请求相同。 Access-Control-Request-Method：请求自身使用的方法。 Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号分隔。 以下是一个带有自定义头部 NCZ 的使用 POST 方法发送的请求。 123Origin: http://www.nczonline.netAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: NCZ 发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通。 Access-Control-Allow-Origin：与简单的请求相同。 Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔。 Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔。 Access-Control-Max-Age：应该将这个 Preflight 请求缓存多长时间（以秒表示）。 例如： 1234Access-Control-Allow-Origin: http://www.nczonline.netAccess-Control-Allow-Methods: POST, GETAccess-Control-Allow-Headers: NCZAccess-Control-Max-Age: 1728000 Preflight 请求结束后，结果将按照响应中指定的时间缓存起来。而为此付出的代价只是第一次发送这种请求时会多一次 HTTP 请求。 支持 Preflight 请求的浏览器包括 Firefox 3.5+、Safari 4+和 Chrome。IE 10 及更早版本都不支持。 4、带凭据的请求 默认情况下，跨源请求不提供凭据（cookie、HTTP 认证及客户端 SSL 证明 等 ）。 通 过 将 withCredentials 属性设置为 true，可以指定某个请求应该发送凭据。如果服务器接受带凭据的请求，会用下面的 HTTP 头部来响应。 1Access-Control-Allow-Credentials: true 如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给 JavaScript（于是，responseText 中将是空字符串，status 的值为 0，而且会调用 onerror() 事件处理程序）。 另外，服务器还可以在 Preflight 响应中发送这个 HTTP 头部，表示允许源发送带凭据的请求。 支持 withCredentials 属性的浏览器有 Firefox 3.5+、Safari 4+和 Chrome。IE 10 及更早版本都不支持。 5、跨浏览器的 CROS 即使浏览器对 CORS 的支持程度并不都一样，但所有浏览器都支持简单的（非 Preflight 和不带凭据的）请求，因此有必要实现一个跨浏览器的方案。 检测 XHR 是否支持 CORS 的最简单方式，就是检查是否存在 withCredentials 属性。再结合检测 XDomainRequest 对象是否存在，就可以兼顾所有浏览器了。 1234567891011121314151617181920function createCORSRequest(method, url)&#123; var xhr = new XMLHttpRequest(); if ("withCredentials" in xhr)&#123; xhr.open(method, url, true); &#125; else if (typeof XDomainRequest != "undefined")&#123; vxhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; xhr = null; &#125; return xhr;&#125;var request = createCORSRequest("get", "http://www.somewhere-else.com/page/");if (request)&#123; request.onload = function()&#123; // 对 request.responseText 进行处理 &#125;; request.send();&#125; Firefox、Safari 和 Chrome 中的 XMLHttpRequest 对象与 IE 中的 XDomainRequest 对象类似，都提供了够用的接口，因此以上模式还是相当有用的。这两个对象共同的属性/方法如下。 abort()：用于停止正在进行的请求。 onerror：用于替代 onreadystatechange 检测错误。 onload：用于替代 onreadystatechange 检测成功。 responseText：用于取得响应内容。 send()：用于发送请求。 以上成员都包含在 createCORSRequest() 函数返回的对象中，在所有浏览器中都能正常使用。 21.5其他跨域技术 在 CORS 出现以前，要实现跨域 Ajax 通信颇费一些周折。开发人员想出了一些办法，利用 DOM 中能够执行跨域请求的功能，在不依赖 XHR 对象的情况下也能发送某种请求。 虽然 CORS 技术已经无处不在，但开发人员自己发明的这些技术仍然被广泛使用，毕竟这样不需要修改服务器端代码。 5.1图像 Ping 上述第一种跨域请求技术是使用标签。我们知道，一个网页可以从任何网页中加载图像，不用担心跨域不跨域。这也是在线广告跟踪浏览量的主要方式。 可以动态地创建图像，使用它们的 onload 和 onerror 事件处理程序来确定是否接收到了响应。 动态创建图像经常用于图像 Ping。图像 Ping 是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或 204 响应。 通过图像 Ping，浏览器得不到任何具体的数据，但通过侦听 load 和 error 事件，它能知道响应是什么时候接收到的。来看下面的例子。 12345var img = new Image();img.onload = img.onerror = function()&#123; alert("Done!");&#125;;img.src = "http://www.example.com/test?name=Nicholas"; 这里创建了一个 Image 的实例，然后将 onload 和 onerror 事件处理程序指定为同一个函数。这样无论是什么响应，只要请求完成，就能得到通知。请求从设置 src 属性那一刻开始，而这个例子在请求中发送了一个 name 参数。 图像 Ping 最常用于跟踪用户点击页面或动态广告曝光次数。图像 Ping 有两个主要的缺点，一是只能发送 GET 请求，二是无法访问服务器的响应文本。因此，图像 Ping 只能用于浏览器与服务器间的单向通信。 5.2JSONP JSONP（JSON with Padding填充式 JSON 或参数式 JSON）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。是解决跨域问题的一种方案，不同于 JSON，其并不是一种数据交换格式，而只是一种绕过跨域的技巧。另一个解决这个问题的新方法是跨域源资源共享。 由于同源策略，一般来说位于server1.example.com的网页无法与 server2.example.com的服务器沟通，而HTML的 元素是一个例外。利用 元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。 JSONP 看起来与 JSON 差不多，只不过是被包含在函数调用中的 JSON，就像下面这样。 1callback(&#123; &quot;name&quot;: &quot;Nicholas&quot; &#125;); JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。下面是一个典型的 JSONP 请求。 1http://freegeoip.net/json/?callback=handleResponse 这个 URL 是在请求一个 JSONP 地理定位服务。通过查询字符串来指定 JSONP 服务的回调参数是很常见的，就像上面的 URL 所示，这里指定的回调函数的名字叫 handleResponse()。 JSONP 是通过动态元素来使用的，使用时可以为 src 属性指定一个跨域 URL。 这里的元素与元素类似，都有能力不受限制地从其他域加载资源。因为 JSONP 是有效的 JavaScript 代码，所以在请求完成后，即在 JSONP 响应加载到页面中以后，就会立即执行。来看一个例子。 1234567function handleResponse(response)&#123; alert("You’re at IP address " + response.ip + ", which is in " + response.city + ", " + response.region_name);&#125;var script = document.createElement("script");script.src = "http://freegeoip.net/json/?callback=handleResponse";document.body.insertBefore(script, document.body.firstChild); 上述例子通过查询地理定位服务来显示你的 IP 地址和位置信息。 JSONP 之所以在开发人员中极为流行，主要原因是它非常简单易用。与图像 Ping 相比，它的优点在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。 不过，JSONP 也有两点不足。 首先，JSONP 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃 JSONP 调用之外，没有办法追究。因此在使用不是你自己运维的 Web 服务时，一定得保证它安全可靠。 其次，要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给元素新增了一个 onerror 事件处理程序，但目前还没有得到任何浏览器支持。为此，开发人员不得不使用计时器检测指定时间内是否接收到了响应。但就算这样也不能尽如人意，毕竟不是每个用户上网的速度和带宽都一样。 5.3Comet Comet 是 Alex Russell（ Alex Russell 是著名 JavaScript 框架 Dojo 的创始人。）发明的一个词儿，指的是一种更高级的 Ajax 技术（经常也有人称为“服务器推送”）。 Ajax 是一种从页面向服务器请求数据的技术，而 Comet 则是一种服务器向页面推送数据的技术。 Comet 能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。 有两种实现 Comet 的方式：长轮询 和 流。 长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据。下图展示的是短轮询的时间线。 长轮询把短轮询颠倒了一下。页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断。下图展示了长轮询的时间线。 无论是短轮询还是长轮询，浏览器都要在接收数据之前，先发起对服务器的连接。两者最大的区别在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询是等待发送响应。 轮询的优势是所有浏览器都支持，因为使用 XHR 对象和 setTimeout() 就能实现。而你要做的就是决定什么时候发送请求。 第二种流行的 Comet 实现是 HTTP 流。流不同于上述两种轮询，因为它在页面的整个生命周期内只使用一个 HTTP 连接。具体来说，就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。比如，下面这段 PHP 脚本就是采用流实现的服务器中常见的形式。 123456789101112&lt;?php $i = 0; while(true)&#123; // 输出一些数据，然后立即刷新输出缓存 echo "Number is $i"; flush(); // 等几秒钟 sleep(10); $i++; &#125; 所有服务器端语言都支持打印到输出缓存然后刷新（将输出缓存中的内容一次性全部发送到客户端）的功能。而这正是实现 HTTP 流的关键所在。 在 Firefox、Safari、Opera 和 Chrome 中，通过侦听 readystatechange 事件及检测 readyState 的值是否为 3，就可以利用 XHR 对象实现 HTTP 流。 在上述这些浏览器中，随着不断从服务器接收数据，readyState 的值会周期性地变为 3。当 readyState 值变为 3 时，responseText 属性中就会保存接收到的所有数据。此时，就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。使用 XHR 对象实现 HTTP 流的典型代码如下所示。 123456789101112131415161718192021222324252627282930function createStreamingClient(url, progress, finished)&#123; var xhr = new XMLHttpRequest(), received = 0; xhr.open("get", url, true); xhr.onreadystatechange = function()&#123; var result; if (xhr.readyState == 3)&#123; // 只取得最新数据并调整计数器 result = xhr.responseText.substring(received); received += result.length; // 调用 progress 回调函数 progress(result); &#125; else if (xhr.readyState == 4)&#123; finished(xhr.responseText); &#125; &#125;; xhr.send(null); return xhr;&#125;var client = createStreamingClient("streaming.php", function(data)&#123; alert("Received: " + data); &#125;, function(data)&#123; alert("Done!"); &#125;); 这个 createStreamingClient() 函数接收三个参数：要连接的 URL、在接收到数据时调用的函数以及关闭连接时调用的函数。 有时候，当连接关闭时，很可能还需要重新建立，所以关注连接什么时候关闭还是有必要的。 只要 readystatechange 事件发生，而且 readyState 值为 3，就对 responseText 进行分割以取得最新数据。这里的 received 变量用于记录已经处理了多少个字符，每次 readyState 值为 3 时都递增。 然后，通过 progress 回调函数来处理传入的新数据。而当 readyState 值为 4 时，则执行 finished 回调函数，传入响应返回的全部内容。 虽然这个例子比较简单，而且也能在大多数浏览器中正常运行（IE 除外），但管理 Comet 的连接是很容易出错的，需要时间不断改进才能达到完美。浏览器社区认为 Comet 是未来 Web 的一个重要组成部分，为了简化这一技术，又为 Comet 创建了两个新的接口。 5.4服务器发送事件 SSE（Server-Sent Events，服务器发送事件）是围绕只读 Comet 交互推出的 API 或者模式。 SSE API 用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。 服务器响应的 MIME 类型必须是 text/event-stream，而且是浏览器中的 JavaScript API 能解析格式输出。 SSE 支持短轮询、长轮询和 HTTP 流，而且能在断开连接时自动确定何时重新连接。有了这么简单实用的 API，再实现 Comet 就容易多了。 支持 SSE 的浏览器有 Firefox 6+、Safari 5+、Opera 11+、Chrome 和 iOS 4+版 Safari。 1. SSE API SSE 的 JavaScript API 与其他传递消息的 JavaScript API 很相似。要预订新的事件流，首先要创建一个新的 EventSource 对象，并传进一个入口点： 1var source = new EventSource("myevents.php"); 注意，传入的 URL 必须与创建对象的页面同源（相同的 URL 模式、域及端口）。EventSource 的实例有一个 readyState 属性，值为 0 表示正连接到服务器，值为 1 表示打开了连接，值为 2 表示关闭了连接。另外，还有以下三个事件。 open：在建立连接时触发。 message：在从服务器接收到新事件时触发。 error：在无法建立连接时触发。 就一般的用法而言，onmessage 事件处理程序也没有什么特别的。 1234source.onmessage = function(event)&#123; var data = event.data; // 处理数据&#125;; 服务器发回的数据以字符串形式保存在 event.data 中。 默认情况下，EventSource 对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味着 SSE 适合长轮询和 HTTP 流。如果想强制立即断开连接并且不再重新连接，可以调用 close() 方法。 1source.close(); 2. 事件流 所谓的服务器事件会通过一个持久的 HTTP 响应发送，这个响应的 MIME 类型为 text/event-stream。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀 data:，例如： 123456data: foodata: bardata: foodata: bar 对以上响应而言，事件流中的第一个 message 事件返回的 event.data 值为”foo”，第二个 message 事件返回的 event.data 值为”bar”，第三个 message 事件返回的 event.data 值为 “foo\nbar”（注意中间的换行符）。 对于多个连续的以 data:开头的数据行，将作为多段数据解析，每个值之间以一个换行符分隔。只有在包含 data:的数据行后面有空行时，才会触发 message 事件，因此在服务器上生成事件流时不能忘了多添加这一行。 通过 id:前缀可以给特定的事件指定一个关联的 ID，这个 ID 行位于 data:行前面或后面皆可： 12data: fooid: 1 设置了 ID 后，EventSource 对象会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个包含名为 Last-Event-ID 的特殊 HTTP 头部的请求，以便服务器知道下一次该触发哪个事件。在多次连接的事件流中，这种机制可以确保浏览器以正确的顺序收到连接的数据段。 5.5Web Sockets 要说最令人津津乐道的新浏览器 API，就得数 Web Sockets 了。Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。 在 JavaScript 中创建了 Web Socket 之后，会有一个 HTTP 请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会使用 HTTP 升级从 HTTP 协议交换为 Web Socket 协议。 也就是说，使用标准的 HTTP 服务器无法实现 Web Sockets，只有支持这种协议的专门服务器才能正常工作。 由于 Web Sockets 使用了自定义的协议，所以 URL 模式也略有不同。未加密的连接不再是 http://，而是 ws://；加密的连接也不是 https://，而是 wss://。 在使用 Web Socket URL 时，必须带着这个模式，因为将来还有可能支持其他模式。 使用自定义协议而非 HTTP 协议的好处是，能够在客户端和服务器之间发送非常少量的数据，而不必担心 HTTP 那样字节级的开销。由于传递的数据包很小，因此 Web Sockets 非常适合移动应用。毕竟对移动应用而言，带宽和网络延迟都是关键问题。 使用自定义协议的缺点在于，制定协议的时间比制定 JavaScript API 的时间还要长。 Web Sockets 曾几度搁浅，就因为不断有人发现这个新协议存在一致性和安全性的问题。Firefox 4 和 Opera 11 都曾默认启用 Web Sockets，但在发布前夕又禁用了，因为又发现了安全隐患。目前支持 Web Sockets 的浏览器有 Firefox 6+、Safari 5+、Chrome 和 iOS 4+版 Safari。 1. Web Sockets API 要创建 Web Socket，先实例一个 WebSocket 对象并传入要连接的 URL： 1var socket = new WebSocket("ws://www.example.com/server.php"); 注意，必须给 WebSocket 构造函数传入绝对 URL。同源策略对 Web Sockets 不适用，因此可以通过它打开到任何站点的连接。至于是否会与某个域中的页面通信，则完全取决于服务器。（通过握手信息就可以知道请求来自何方。） 实例化了 WebSocket 对象后，浏览器就会马上尝试创建连接。与 XHR 类似，WebSocket 也有一个表示当前状态的 readyState 属性。不过，这个属性的值与 XHR 并不相同，而是如下所示。 WebSocket.OPENING (0)：正在建立连接。 WebSocket.OPEN (1)：已经建立连接。 WebSocket.CLOSING (2)：正在关闭连接。 WebSocket.CLOSE (3)：已经关闭连接。 WebSocket 没有 readystatechange 事件；不过，它有其他事件，对应着不同的状态。readyState 的值永远从 0 开始。要关闭 Web Socket 连接，可以在任何时候调用 close() 方法。 1socket.close(); 调用了 close() 之后，readyState 的值立即变为 2（正在关闭），而在关闭连接后就会变成 3。 2. 发送和接收数据 Web Socket 打开之后，就可以通过连接发送和接收数据。要向服务器发送数据，使用 send() 方法并传入任意字符串，例如： 123var socket = new WebSocket("ws://www.example.com/server.php");socket.send("Hello world!"); 因为 Web Sockets 只能通过连接发送纯文本数据，所以对于复杂的数据结构，在通过连接发送之前，必须进行序列化。下面的例子展示了先将数据序列化为一个 JSON 字符串，然后再发送到服务器： 123456var message = &#123; time: new Date(), text: "Hello world!", clientId: "asdfp8734rew"&#125;;socket.send(JSON.stringify(message)); 接下来，服务器要读取其中的数据，就要解析接收到的 JSON 字符串。 当服务器向客户端发来消息时，WebSocket 对象就会触发 message 事件。这个 message 事件与其他传递消息的协议类似，也是把返回的数据保存在 event.data 属性中。 1234socket.onmessage = function(event)&#123; var data = event.data; // 处理数据&#125;; 与通过 send() 发送到服务器的数据一样，event.data 中返回的数据也是字符串。如果你想得到其他格式的数据，必须手工解析这些数据。 3. 其他事件 WebSocket 对象还有其他三个事件，在连接生命周期的不同阶段触发。 open：在成功建立连接时触发。 error：在发生错误时触发，连接不能持续。 close：在连接关闭时触发。 WebSocket 对象不支持 DOM 2 级事件侦听器，因此必须使用 DOM 0 级语法分别定义每个事件处理程序。 1234567891011var socket = new WebSocket("ws://www.example.com/server.php");socket.onopen = function()&#123; alert("Connection established.");&#125;;socket.onerror = function()&#123; alert("Connection error.");&#125;;socket.onclose = function()&#123; alert("Connection closed.");&#125;; 在这三个事件中，只有 close 事件的 event 对象有额外的信息。 close 事件的事件对象有三个额外的属性：wasClean、code 和 reason。其中，wasClean 是一个布尔值，表示连接是否已经明确地关闭；code 是服务器返回的数值状态码；而 reason 是一个字符串，包含服务器发回的消息。可以把这些信息显示给用户，也可以记录到日志中以便将来分析。 123socket.onclose = function(event)&#123; console.log("Was clean? " + event.wasClean + " Code=" + event.code + " Reason=" + event.reason);&#125;; 5.6SSE 与 Web Sockets 面对某个具体的用例，在考虑是使用 SSE 还是使用 Web Sockets 时，可以考虑如下几个因素。 首先，你是否有自由度建立和维护 Web Sockets 服务器？因为 Web Socket 协议不同于 HTTP，所以现有服务器不能用于 Web Socket 通信。SSE 倒是通过常规 HTTP 通信，因此现有服务器就可以满足需求。 第二个要考虑的问题是到底需不需要双向通信。如果用例只需读取服务器数据（如比赛成绩），那么 SSE 比较容易实现。如果用例必须双向通信（如聊天室），那么 Web Sockets 显然更好。 别忘了，在不能选择 Web Sockets 的情况下，组合 XHR 和 SSE 也是能实现双向通信的。 21.6安全首先，可以通过 XHR 访问的任何 URL 也可以通过浏览器或服务器来访问。下面的 URL 就是一个例子。 1/getuserinfo.php?id=23 如果是向这个 URL 发送请求，可以想象结果会返回 ID 为 23 的用户的某些数据。谁也无法保证别人不会将这个 URL 的用户 ID 修改为 24、56 或其他值。因此，getuserinfo.php 文件必须知道请求者是否真的有权限访问要请求的数据；否则，你的服务器就会门户大开，任何人的数据都可能被泄漏出去。对于未被授权系统有权访问某个资源的情况，我们称之为 CSRF（Cross-Site Request Forgery，跨站点请求伪造）。未被授权系统会伪装自己，让处理请求的服务器认为它是合法的。受到 CSRF 攻击的 Ajax 程序有大有小，攻击行为既有旨在揭示系统漏洞的恶作剧，也有恶意的数据窃取或数据销毁。为确保通过 XHR 访问的 URL 安全，通行的做法就是验证发送请求者是否有权限访问相应的资源。有下列几种方式可供选择。 要求以 SSL 连接来访问可以通过 XHR 请求的资源。 要求每一次请求都要附带经过相应算法计算得到的验证码。 请注意，下列措施对防范 CSRF 攻击不起作用。 要求发送 POST 而不是 GET 请求——很容易改变。 检查来源 URL 以确定是否可信——来源记录很容易伪造。 基于 cookie 信息进行验证——同样很容易伪造。 XHR 对象也提供了一些安全机制，虽然表面上看可以保证安全，但实际上却相当不可靠。 实际上，前面介绍的 open() 方法还能再接收两个参数：要随请求一起发送的用户名和密码。带有这两个参数的请求可以通过 SSL 发送给服务器上的页面，如下面的例子所示。 1xhr.open(&quot;get&quot;, &quot;example.php&quot;, true, &quot;username&quot;, &quot;password&quot;); // 不要这样做！！ 即便可以考虑这种安全机制，但还是尽量不要这样做。把用户名和密码保存在 JavaScript 代码中本身就是极为不安全的。任何人，只要他会使用 JavaScript 调试器，就可以通过查看相应的变量发现纯文本形式的用户名和密码。 小结 Ajax 是无需刷新页面就能够从服务器取得数据的一种方法。关于 Ajax，可以从以下几方面来总结一下。 负责 Ajax 运作的核心对象是 XMLHttpRequest（XHR）对象。 XHR 对象由微软最早在 IE5 中引入，用于通过 JavaScript 从服务器取得 XML 数据。 在此之后，Firefox、Safari、Chrome 和 Opera 都实现了相同的特性，使 XHR 成为了 Web 的一个事实标准。 虽然实现之间存在差异，但 XHR 对象的基本用法在不同浏览器间还是相对规范的，因此可以放心地用在 Web 开发当中。 同源策略是对 XHR 的一个主要约束，它为通信设置了“相同的域、相同的端口、相同的协议”这一限制。试图访问上述限制之外的资源，都会引发安全错误，除非采用被认可的跨域解决方案。 这个解决方案叫做 CORS（Cross-Origin Resource Sharing，跨源资源共享），IE8 通过 XDomainRequest 对象支持 CORS，其他浏览器通过 XHR 对象原生支持 CORS。图像 Ping 和 JSONP 是另外两种跨域通信的技术，但不如 CORS 稳妥。 Comet 是对 Ajax 的进一步扩展，让服务器几乎能够实时地向客户端推送数据。实现 Comet 的手段主要有两个：长轮询和 HTTP 流。所有浏览器都支持长轮询，而只有部分浏览器原生支持 HTTP 流。 SSE（Server-Sent Events，服务器发送事件）是一种实现 Comet 交互的浏览器 API，既支持长轮询，也支持 HTTP 流。 Web Sockets 是一种与服务器进行全双工、双向通信的信道。与其他方案不同，Web Sockets 不使用 HTTP 协议，而使用一种自定义的协议。这种协议专门为快速传输小数据设计。虽然要求使用不同的 Web 服务器，但却具有速度上的优势。 各方面对 Ajax 和 Comet 的鼓吹吸引了越来越多的开发人员学习 JavaScript，人们对 Web 开发的关注也再度升温。与 Ajax 有关的概念都还相对比较新，这些概念会随着时间推移继续发展。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《JavaScript高级程序设计》（4）]]></title>
    <url>%2Fnote%2F2018%2Fundefined26%2Fbe32fa2a.html</url>
    <content type="text"><![CDATA[[美] Nicholas C.Zakes 著 李松峰 曹力 译 （第三版） 第十章DOM 第十一章DOM扩展 由于书上写的好啰嗦，受不鸟了。所以决定先从,w3cshool了解些基础，以后在深挖。 可参考JavaScript中的DOM对象，写的很好。本文写的匆忙，自己看的。O(∩_∩)O哈哈~ “W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM 模型被构造为对象的树。 HTML DOM 树 1.DOM 节点根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点： 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 节点树中的节点彼此拥有层级关系。 父（parent）、子（child）和同胞（sibling）等术语用于描述这些关系。 2.DOM 方法和属性方法是我们可以在节点（HTML 元素）上执行的动作。 可通过 JavaScript （以及其他编程语言）对 HTML DOM 进行访问。 所有 HTML 元素被定义为对象，而编程接口则是对象方法和对象属性。 方法是您能够执行的动作（比如添加或修改元素）。 属性是您能够获取或设置的值（比如节点的名称或内容）. 一些常用的 HTML DOM 属性： innerHTML - 节点（元素）的文本值 parentNode - 节点（元素）的父节点 childNodes - 节点（元素）的子节点 attributes - 节点（元素）的属性节点 nodeName 属性nodeName 属性规定节点的名称。 nodeName 是只读的 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 与属性名相同 文本节点的 nodeName 始终是 #text 文档节点的 nodeName 始终是 #document nodeValue 属性nodeValue 属性规定节点的值。 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本本身 属性节点的 nodeValue 是属性值 nodeType 属性nodeType 属性返回节点的类型。nodeType 是只读的。 比较重要的节点类型有： 元素类型 NodeType 元素 1 属性 2 文本 3 注释 8 文档 9 1234567891011121314151617181920&lt;html&gt;&lt;body&gt;&lt;p id="intro"&gt;Hello World!&lt;/p&gt;&lt;script&gt;var txt=document.getElementById("intro"); //得到一个元素节点 [object HTMLParagraphElement]document.write(txt);// [object HTMLParagraphElement]document.write(txt.innerHTML);//Hello World innerHTMl得到这个元素的文本值document.write(txt.nodeName);//p 元素节点的标签名document.write(txt.firstChild); //得到元素p的文本节点[object Text]document.write(txt.nodeValue);// null document.write(txt.firstchild.nodeValue);// Hello World document.write(txt.nodeType); //1 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 现实生活中的对象 某个人是一个对象。 人的方法可能是 eat(), sleep(), work(), play() 等等。 所有人都有这些方法，但会在不同时间执行它们。 一个人的属性包括姓名、身高、体重、年龄、性别等等。 所有人都有这些属性，但它们的值因人而异。 DOM 对象方法 方法 描述 document .getElementById() 返回带有指定 ID 的元素。 getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组nodelist(由于浏览器内核解析不一样)）。 getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 A .appendChild(B) 把新的子节点添加到指定节点。B 为新建节点，A为已有节点。追加到A后面。 将新元素作为父元素的最后一个子元素进行添加。 removeChild() 删除子节点。 replaceChild(A,B) 替换子节点。A是替换，B是被替换 insertBefore() 在指定的子节点前面插入新的子节点。 createAttribute() 创建属性节点。 document .createElement(‘p’) 创建元素节点p。 createTextNode(‘我想做个好人’) 创建文本节点。我想做个好人 getAttribute() 返回指定的属性值。 setAttribute() 把指定属性设置或修改为指定的值。 getElementsByTagName() 开始于一个具体的父级元素并且从它自上而下递归地在DOM树中搜索符合标签名称参数的子元素。 注意调用 getElementsByTagName() 的不是那个文件节点 document，事实上是使用这个方法 element.getElementsByTagName()。 1234var div1 = document.getElementById("div1");var div1Paras = div1.getElementsByTagName("p");//div1中的pdocument.getElementsByTagName("p");// 获得整个文件中的p。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;div id="main"&gt;&lt;p id='p1'&gt;DOM 很有用！&lt;/p&gt;&lt;p id='p2'&gt;本例演示 &lt;b&gt;getElementsByTagName&lt;/b&gt; 方法。&lt;/p&gt; //返回的是一个同名数组&lt;/div&gt;&lt;script&gt;x=document.getElementById("main").getElementsByTagName("p");document.write( x);//[object HTMLCollection]document.write(x[0]);//[object HTMLParagraphElement]document.write(x[0].innertHTML );// DOM 很有用！document.write("div 中的第一段的文本: " + x[0].innerHTML); x[0].innertHTML ='New Text'//改变 HTML 内容document.write(x[0].innertHTML );// New Textx[0].style.color ='blue' //改变样式x[0].style.fontSize='larger ' //创建一个新元素var para=document.createElement("p");//创建元素节点var node=document.createTextNode("This is new.");//创建文本节点para.appendChild(node);//把文本节点与元素节点连接var element=document.getElementById("main"); element.appendChild(para);//追加到已有元素上作为子节点 var child=document.getElementById("p1");element.insertBefore(para,child);//插入到指定子节点前 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 能否在不引用父元素的情况下删除某个元素？ 很抱歉。DOM 需要了解您需要删除的元素，以及它的父元素。 这里提供一个常用的解决方法：找到您需要删除的子元素，然后使用 parentNode 属性来查找其父元素： 12var child=document.getElementById("p1");child.parentNode.removeChild(child); 替换某个元素 1234567891011121314&lt;div id="div1"&gt;&lt;p id="p1"&gt;This is a paragraph.&lt;/p&gt;&lt;p id="p2"&gt;This is another paragraph.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para=document.createElement("p");var node=document.createTextNode("This is new.");para.appendChild(node);var parent=document.getElementById("div1");var child=document.getElementById("p1");parent.replaceChild(para,child);&lt;/script&gt; 修改 HTML 元素修改 HTML DOM 意味着许多不同的方面： 改变 HTML 内容 改变 CSS 样式 改变 HTML 属性 创建新的 HTML 元素 删除已有的 HTML 元素 改变事件（处理程序） 改变元素内容的最简答的方法是使用 innerHTML 属性。 如需向 HTML DOM 添加新元素，您首先必须创建该元素（元素节点），然后把它追加到已有的元素上。 下面两个例子在按钮被点击时改变 元素的背景色： 实例12345678&lt;html&gt;&lt;body&gt;&lt;input type="button" onclick="document.body.style.backgroundColor='lavender';"value="Change background color" /&gt;&lt;/body&gt;&lt;/html&gt; 亲自试一试 在本例中，由函数执行相同的代码： 实例123456789101112131415&lt;html&gt;&lt;body&gt;&lt;script&gt;function ChangeBackground()&#123;document.body.style.backgroundColor="lavender";&#125;&lt;/script&gt;&lt;input type="button" onclick="ChangeBackground()"value="Change background color" /&gt;&lt;/body&gt;&lt;/html&gt; 事件发生时，可以执行 JavaScript，比如当用户点击一个 HTML 元素时。 如需在用户点击某个元素时执行代码，请把 JavaScript 代码添加到 HTML 事件属性中： 1onclick=JavaScript 在本例中，当用户点击时，会改变 &lt;h1&gt; 元素的内容： 实例123456&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1 onclick="this.innerHTML='hello!'"&gt;请点击这段文本!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 在本例中，会从事件处理程序中调用函数： 实例1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt;function changetext(id)&#123;id.innerHTML="hello!";&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 onclick="changetext(this)"&gt;请点击这段文本!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 导航节点关系您能够使用三个节点属性：parentNode、firstChild 以及 lastChild ，在文档结构中进行导航。 DOM 根节点这里有两个特殊的属性，可以访问全部文档： document.documentElement - 全部文档 document.body - 文档的主体 childNodes 和 nodeValue除了 innerHTML 属性，您也可以使用 childNodes 和 nodeValue 属性来获取元素的内容。 childNodes [0]相当于firstChild. 下面的代码获取 id=”intro” 的 元素的值： 实例123456789101112&lt;html&gt;&lt;body&gt;&lt;p id="intro"&gt;Hello World!&lt;/p&gt;&lt;script&gt;var txt=document.getElementById("intro").childNodes[0].nodeValue;document.write(txt);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; firstChild returns the first child node childNodes returns a collection of all child nodes 它返回指定元素的子元素集合，包括html节点，所有属性，文本。如果代码中有换行、空格就会增加文本节点，这样用它来返回真正的子节点就会不准确 . 每一个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种类数组对象，但不是数组，用于保存一组有序的节点。可以通过someNode.childNodes[0]andsomeNode.childNodes.item(0)来访问。 firstElementChild returns the first child element children returns a collection of all child elements childNodes属性:标准的，它返回指定元素的子元素集合，包括html节点，所有属性，文本。如果代码中有换行、空格就会增加文本节点，这样用它来返回真正的子节点就会不准确 . 每一个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种类数组对象，但不是数组，用于保存一组有序的节点。可以通过someNode.childNodes[0]andsomeNode.childNodes.item(0)来访问。 children属性:非标准的，它返回指定元素的子元素集合。经测试，它只返回html节点，甚至不返回文本节点。 difference .children is a property of an Element. Only Elements have children, and these children are all of type Element. However .childNodes is a property of Node. .childNodes can contain any node. So a concrete example would be 1234var el = document.createElement("div");el.textContent = "foo"el.childNodes.length === 1; // TextNode is a node childel.children.length === 0; // no Element children firstChild属性：获取指定元素的第一个子节点，可以是元素节点，也可以是文本节点。 问题：若父元素与第一个子元素之间存在空白节点，firstChild获取到的将是空白节点而不是第一个子元素。 解决：使用firstElementChild属性。 问题：IE6/7/8中不支持firstElementChild属性。 解决：使用children[0]属性。 firstElementChild属性： 获取指定元素的第一个子元素节点，不会检测到文本节点。 对于元素间的空格，IE9及以前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这样导致了在使用childNodes和firstChild等属性时的行为不一致。 =&gt;childNodes =&gt;firstChild =&gt;lastChild =&gt;nextSibling（） =&gt;previousSibling（） 为了弥补上述这一差异，而同时又保持DOM规范不变，Element Traversal规范新定义了一组属性。（即） =&gt;childElementCount：返回子元素（不包括文本节点和注释）的个数 =&gt;firstElementChild：指向第一个子元素；firstChild的元素版。 =&gt;lastElementChild：指向最后 一个子元素；lastChild的元素版。 =&gt;previousElementSibling：指向前一个同辈元素；previousSibling的元素版。 =&gt;nextElementSibling：指向最后一个同辈元素；nextSibling的元素版。 对于arguments对象使用Array.prototype.slice（）方法可以将其转为数组，也可将NodeList转化. 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;ul id="source"&gt; &lt;li&gt;北京空气质量：&lt;b&gt;90&lt;/b&gt;&lt;/li&gt; &lt;li&gt;上海空气质量：&lt;b&gt;70&lt;/b&gt;&lt;/li&gt; &lt;li&gt;天津空气质量：&lt;b&gt;80&lt;/b&gt;&lt;/li&gt; &lt;li&gt;广州空气质量：&lt;b&gt;50&lt;/b&gt;&lt;/li&gt; &lt;li&gt;深圳空气质量：&lt;b&gt;40&lt;/b&gt;&lt;/li&gt; &lt;li&gt;福州空气质量：&lt;b&gt;32&lt;/b&gt;&lt;/li&gt; &lt;li&gt;成都空气质量：&lt;b&gt;90&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var all = document.getElementById("source").childNodes.length;document.write(all); //15//把childNodes换为children all 为7 多多调试下 //无聊玩 对于arguments对象使用Array.prototype.slice（）方法可以将其转为数组，也可将NodeList转化var all = document.getElementById("source").childNodes;var arrAll = Array.prototype.slice.call(all,0);alert(arrAll instanceof Array );document.write(arrAll);//[object Text],[object HTMLLIElement],[object HTMLLIElement],[object Text],[object HTMLLIElement],[object Text],[object HTMLLIElement],[object Text],[object HTMLLIElement],[object Text],[object HTMLLIElement],[object Text],[object HTMLLIElement],[object Text] //移除第一个li（北京质量）function myFunction()&#123;var list=document.getElementById("source");list.removeChild(list.childNodes[0]); //就为了这一句&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; innerText/outerText,innerHTML/outerHTML 某元素的innerText指的是由其元素的开始标签和结束标签所包含的那一段HTML代码被去除格式后的纯文本。 outerText与其不同的是它包含元素的开始和结束标签。 上述四个属性不仅可以读取，还可以赋值。outerText和innerText的区别在于outerText赋值时会把标签一起赋值掉 Unlike innerText, though, innerHTML lets you work with HTML rich text and doesn’t automatically encode and decode text. In other words, innerText retrieves and sets the content of the tag as plain text, whereas innerHTML retrieves and sets the content in HTML format. 即innerHTML保留html标签 element.innerHTMLnode.innerTextvalue 属性设置或返回 textarea 的文本 （value是表单元素特有的属性,输入输出的是转义文本 ）。 通过CSS选择器选取元素Document对象的方法querySelectorAll()，它接受一个CSS选择器的字符串参数，返回一个代表文档中匹配选择器的所有元素的NodeList对象，并不是实时的。如果没有匹配的元素，则返回一个空的NodeList对象。 1document.querySelectorAll(&apos;.div&apos;) //匹配所有class名为div的元素 还有一个querySelector()方法，其原理和querySelectorAll()是一样的，不过它返回第一个匹配的元素（以文档顺序），如果没有匹配的元素就返回null。 它们支持复杂的CSS选择器。 12345// 选中data-tip属性等于title的元素 document.querySelectorAll(&apos;[data-tip=&quot;title&quot;]&apos;);// 选中div元素，那些class含ignore的除外 document.querySelectorAll(&apos;div:not(.ignore)&apos;); 但是，它们不支持CSS伪元素的选择器（比如:first-line和:first-letter）和伪类的选择器（比如:link和:visited），即无法选中伪元素和伪类。 这两个方法在Element节点上也有定义 3.HTML DOM 实例Document 对象1234567891011121314&lt;html&gt;&lt;body&gt;&lt;script type="text/javascript"&gt;document.write("Hello World!")；document.write("&lt;h1&gt;Hello World!&lt;/h1&gt;")；// 可写HTMLdocument.write(document.title)；document.write(document.URL);document.write(document.referrer);//referrer 属性返回加载本文档的文档的 document.write(document.domain); //返回域名&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.事件更多细节请参考《JavaScript 闯关记》之事件 JS与HTML之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器(或处理程序)来预定事件，以便事件发生时执行相应的代码。事件就是 Web 浏览器通知应用程序发生了什么事情，支持页面行为(javascript)与页面的外观（html css）之间的松耦合 ，这种在传统软件工程中被称为观察员模式。 观察者模式又叫做发布订阅者模式(Publish/Subscribe)，它可以让多个观察者对象同时监听某一个主题对象，这个主题对象的状态变化时会通知所有的订阅者，使得它们能够做出反应。JS的事件模型就是一种观察者模式的体现，当对应的事件被触发时，监听该事件的所有监听函数都会被调用。 事件通常与函数配合使用，这样就可以通过发生的事件来驱动函数执行。 4.1概念： 事件event）：是指用户或者浏览器自身执行的某种动作。如：click、load和mouseover。 事件类型（event type）：用来说明发生什么类型事件的字符串，有时候，称为事件名称（event name），如：’mousemove’，’keydown’，’load’ 事件目标（event target）：发生的事件与之相关的对象，比如x（x=document.getElementById(‘p1’)）。 事件处理程序（event handle/listener）：处理或者响应事件的函数。 事件对象（event object）：与特定事件相关且包含有关事件详细信息的对象，事件对象作为参数传递给事件处理程序函数（IE8除外，仅能通过window.event得到）。 4.2事件绑定要想让 JavaScript 对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称。 在JavaScript中，有三种常用的绑定事件的方法： 在DOM元素中直接绑定； 在JavaScript代码中绑定； 绑定事件监听函数。 使用事件监听绑定事件 绑定事件的另一种方法是用 addEventListener() 或 attachEvent() 来绑定事件监听函数。下面详细介绍，事件监听。 事件监听（三个事件阶段）关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。 事件目标阶段(target phase)。事件到达目标元素, 触发目标元素的监听函数 。 事件委托（代理）事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。 事件在冒泡过程中会上传到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托(Event delegation)。 我们有一个div元素，它包含三个按钮: 12345&lt;div id="box"&gt; &lt;input type="button" value="按钮" id="btn"&gt; &lt;input type="button" value="按钮2" id="btn2"&gt; &lt;input type="button" value="按钮3" id="btn3"&gt;&lt;/div&gt; 我们可以在父节点上一次性的为所有子节点注册监听函数: 123456789var box = document.getElementById('box');box.addEventListener('click', function(event) &#123; if (event.target.tagName.toLowerCase() === 'input') &#123; // some code box.removeChild(event.target);// 移除所点击的input按钮。 //target始终指向触发元素，参考 &#125; 所有的事件都会走一遍这个流程。 如果点击了 (text) 那么在 div、body、……绑定的事件都会执行，除非有一个事件阻止了事件冒泡。 因此我们可以给父元素绑定一个事件，这样子元素的事件就会冒泡到父元素。 对于非target节点则先执行捕获在执行冒泡 对于target节点则是先执行先注册的事件，无论冒泡还是捕获。 三个事件阶段的demo必看。 补充：JS中的事件委托或是事件代理详解 4.3事件流首先在介绍DOM事件之前我们先来认识下DOM的不同级别。针对不同级别的DOM，我们的DOM事件处理方式也是不一样的。 4.3.1DOM级别与DOM事件转自简书DOM 事件深入浅出 DOM级别一共可以分为4个级别：DOM0级，DOM1级，DOM2级和 DOM3级，而DOM事件分为3个级别：DOM0级事件处理，DOM2级事件处理和DOM3级事件处理。如下图所示： 有人可能会问，为什么没有DOM1级事件处理呢？因为1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。 关于DOM级别这里不做详细的介绍，下面主要介绍下不同级别DOM中的不同事件。 1.DOM0级事件 在了解DOM0级事件之前，我们有必要先了解下HTML事件处理程序，也是最早的这一种的事件处理方式，代码如下： 1234567&lt;button type="button" onclick="showFn()"&gt;&lt;/button&gt;&lt;script&gt; function showFn() &#123; alert('Hello World'); &#125;&lt;/script&gt; 以上代码我们通过直接在HTML代码里定义了一个onclick的属性触发showFn方法，这样的事件处理程序最大的缺点就是HTML于JS强耦合，我们一旦需要修改函数名就得修改两个地方。当然其优点是不需要操作DOM来完成事件的绑定。 那么什么是DOM0级处理事件呢？DOM0级事件就是将一个函数赋值给一个事件处理属性，比如： 1234567891011&lt;button id="btn" type="button"&gt;&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); btn.onclick = function() &#123; alert('Hello World'); &#125; // btn.onclick = null; 解绑事件 &lt;/script&gt; 以上代码我们给button定义了一个id，通过JS获取到了这个id的按钮，并将一个函数赋值给了一个事件处理属性onclick，这样的方法便是DOM0级处理事件的体现。我们可以通过给事件处理属性赋值null来解绑事件。 DOM0级事件处理程序的缺点在于一个处理程序无法同时绑定多个处理函数，比如我还想在按钮点击事件上加上另外一个函数。 2.DOM2级事件 DOM2级事件在DOM0级事件的基础上弥补了一个处理程序无法同时绑定多个处理函数的缺点，允许给一个处理程序添加多个处理函数。代码如下： 12345678910111213&lt;button id="btn" type="button"&gt;&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); function showFn() &#123; alert('Hello World'); &#125; btn.addEventListener('click', showFn, false); // btn.removeEventListener('click', showFn, false); 解绑事件 &lt;/script&gt; DOM2级事件定义了addEventListener和removeEventListener两个方法，分别用来绑定和解绑事件，方法中包含3个参数，分别是绑定的事件处理属性名称（不包含on）、处理函数和是否在捕获时执行事件处理函数。如果我们还需要添加一个鼠标移入的方法，只需要： 1btn.addEventListener('mouseover', showFn, false); 这样点击按钮和鼠标移入时都将触发showFn方法。 需要注意的是IE8级以下版本不支持addEventListener和removeEventListener，需要用attachEvent和detachEvent来实现： 12btn.attachEvent('onclick', showFn); // 绑定事件 btn.detachEvent('onclick', showFn); // 解绑事件 这里我们不需要传入第三个参数，因为IE8级以下版本只支持冒泡型事件。 3.DOM3级事件 DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下： UI事件，当用户与页面上的元素交互时触发，如：load、scroll 焦点事件，当元素获得或失去焦点时触发，如：blur、focus 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel 文本事件，当在文档中输入文本时触发，如：textInput 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified 同时DOM3级事件也允许使用者自定义一些事件。 4.3.2DOM事件流上文中讲到了addEventListener的第三个参数为指定事件是否在捕获阶段执行，设置为true表示事件在捕获阶段执行，而设置为false表示事件在冒泡阶段执行。那么什么是事件冒泡和事件捕获呢？可以用下图来解释： 事件流（event propagation）： 描述的是从页面中接收事件的顺序。IE的事件流是事件冒泡流（event bubbling），其他事件流是事件捕获流（event capturing）（由网景公司制定）。 1、事件冒泡流：事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后，逐级向上传播到较为不具体的节点（文档）。所谓事件冒泡就是事件像泡泡一样从最开始生成的地方一层一层往上冒，比如上图中a标签为事件目标，点击a标签后同时也会触发p、li上的点击事件，一层一层向上直至最外层的html或document。下面是代码示例： 。所有现代浏览器都支持事件冒泡，故而，放心使用。 12345678910111213141516&lt;div id="box"&gt; &lt;a id="child"&gt;事件冒泡&lt;/a&gt;&lt;/div&gt;&lt;script&gt; var box = document.getElementById('box'), child = document.getElementById('child');child.addEventListener('click', function() &#123; alert('我是目标事件'); &#125;, false); box.addEventListener('click', function() &#123; alert('事件冒泡至DIV'); &#125;, false);&lt;/script&gt; 上面的代码运行后我们点击a标签，首先会弹出’我是目标事件’提示，然后又会弹出’事件冒泡至DIV’的提示，这便说明了事件自内而外向上冒泡了。 那么我们如何阻止事件冒泡呢？这里就涉及事件的Event对象中的stopPropagation方法，如下： 1234child.addEventListener('click', function(e) &#123; alert('我是目标事件'); e.stopPropagation();&#125;, false); 加上stopPropagation方法后，我们再次点击a标签就不会触发div上的click事件了 事件捕获 和事件冒泡相反，事件捕获是自上而下执行，我们只需要将addEventListener的第三个参数改为true就行。 12345678910111213141516&lt;div id="box"&gt; &lt;a id="child"&gt;事件冒泡&lt;/a&gt;&lt;/div&gt;&lt;script&gt; var box = document.getElementById('box'), child = document.getElementById('child'); child.addEventListener('click', function() &#123; alert('我是目标事件'); &#125;, true); box.addEventListener('click', function() &#123; alert('事件冒泡至DIV'); &#125;, true);&lt;/script&gt; 此时我们点击a标签，首先弹出的是’事件冒泡至DIV’，其次弹出的是’我是目标事件’，正好与事件冒泡相反。 事件对象（event object）指的是与特定事件相关且包含该事件详细信息的对象。我们可以通过传递给事件处理程序的参数获取事件触发后所产生的一系列方法和属性。 4.4事件对象（event）事件对象。 在触发DOM上的某个事件时，会产生一个事件对象，这个事件包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其它与特定事件相关的信息。 w3c HTML DOM Event 对象 Event对象其实是一个事件处理程序的参数，当调用事件时，我们只需要将其传入事件函数就可以获取。代码如下： 123function getEvent(event) &#123; event = event || window.event;&#125; 上面的事件函数传入了一个名叫Event的参数作为事件对象，同时做了浏览器兼容处理。在IE8及以前本版之中，通过设置属性注册事件处理程序时，调用的时候并未传递事件对象，需要通过全局对象window.event来获取。所以上述代码中我们利用 || 来做判断，如果event对象存在则使用event，不存在则使用window.event。 Event对象包含了几个方法和多个属性，通过这些方法和属性我们可以获取事件的详细信息并进行相关处理。 4.4.1Event对象方法下面列出了 2 级 DOM 事件标准定义的方法。IE 的事件模型不支持这些方法： 方法 描述 initEvent() 初始化新创建的 Event 对象的属性。 preventDefault() 通知浏览器不要执行与事件关联的默认动作。 stopPropagation() 不再派发事件。 Event对象主要有以下两个方法，用于处理事件的传播（冒泡、捕获）和事件的取消。 1.stopPropagationstopPropagation方法主要用于阻止事件的进一步传播，比如阻止事件继续向上层冒泡。 12345function getEvent(event) &#123; event.stopPropagation();&#125;child.addEventListener('click', getEvent, false); 如果你需要兼容IE8及以下版本浏览器，则需要利用cancelBubble来代替stopPropagation，因为低版本IE不支持stopPropagation方法。 123456789function getEvent(event) &#123; event = event || window.event; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125;&#125; cancelBubble是IE事件对象的一个属性，设置这个属性为true能阻止事件进一步传播。 2.preventDefaultpreventDefault方法用于取消事件的默认操作，比如a链接的跳转行为和表单自动提交行为就可以用preventDefault方法来取消。代码如下： 1&lt;a id="go" href="https://www.baidu.com/"&gt;禁止跳转&lt;/a&gt; 123456789var go = document.getElementById('go');function goFn(event) &#123; event.preventDefault(); console.log('我没有跳转！');&#125;go.addEventListener('click', goFn, false); 通过preventDefault，我们成功阻止了a链接的跳转行为。不过，在IE9之前的浏览器中需要设置returnValue属性为false来实现。如下： 1234567891011function goFn(event) &#123; event = event || window.event; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; console.log('我没有跳转！');&#125; 除了以上Event对象的两个主要方法，当前DOM事件规范草案在Event对象上还定义了另一个方法，命名为stopImmediatePropagation。 3.stopImmediatePropagation和stopPropagation相比，stopImmediatePropagation同样可以阻止事件的传播，不同点在于其还可以把这个元素绑定的同类型事件也阻止了。如： 123456789101112131415var go = document.getElementById('go');function goFn(event) &#123; event.preventDefault(); event.stopImmediatePropagation(); // 阻止事件冒泡并阻止同类型事件 console.log('我没有跳转！');&#125;function goFn2(event) &#123; console.log('我是同类型事件！');&#125;go.addEventListener('click', goFn, false);go.addEventListener('click', goFn2, false); 我们在a链接上继续加了一个点击事件，如果我们在goFn方法中添加了stopImmediatePropagation方法，那么goFn2方法将不会被执行，同时也不会将点击事件冒泡至上层。 需要注意的是，stopImmediatePropagation目前一部分浏览器尚不支持，但是像jQuery这样的库封装了跨平台的stopImmediatePropagation方法。 4.4.2Event对象属性下面列出了 2 级 DOM 事件标准定义的属性。 属性 描述 bubbles 返回布尔值，指示事件是否是起泡事件类型。 cancelable 返回布尔值，指示事件是否可拥可取消的默认动作。 currentTarget 返回其事件监听器触发该事件的元素。 eventPhase 返回事件传播的当前阶段。 target 返回触发此事件的元素（事件的目标节点）。 timeStamp 返回事件生成的日期和时间。 type 返回当前 Event 对象表示的事件的名称。 与Event对象的方法相比，因Event对象的属性相对较多，文本无法一一讲解，所以主要介绍实际项目中常用的Event对象属性。 1.type属性通过type我们可以获取事件发生的类型，比如点击事件我们获取的是’click’字符串。 1234567var go = document.getElementById('go');function goFn(event) &#123; console.log(event.type); // 输出'click'&#125;go.addEventListener('click', goFn, false); 2.target属性target属性主要用于获取事件的目标对象，比如我们点击a标签获取的是a标签的html对象。 123456789var go = document.getElementById('go');function goFn(event) &#123; var target = event.target; console.log(target === go) // 返回true&#125;go.addEventListener('click', goFn, false); 在IE8及之前版本，我们需要使用srcElement而非target。兼容方案如下： 123456function goFn(event) &#123; var event = event || window.event, target = event.target || event.srcElement; console.log(target === go) // 返回true&#125; this、target、currentTarget. 在事件处理程序内部，对象 this 始终等于 currentTarget 的值，而 target 则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则 this、currentTarget 和 target 包含相同的值。来看下面的例子。 12345var btn = document.getElementById("myBtn");btn.onclick = function(event)&#123; console.log(event.currentTarget === this); // true console.log(event.target === this); // true&#125;; 这个例子检测了 currentTarget 和 target 与 this 的值。由于 click 事件的目标是按钮，因此这三个值是相等的。如果事件处理程序存在于按钮的父节点中（例如 document.body），那么这些值是不相同的。再看下面的例子。 12345document.body.onclick = function(event)&#123; console.log(event.currentTarget === document.body); // true console.log(this === document.body); // true console.log(event.target === document.getElementById("myBtn")); // true&#125;; 当单击这个例子中的按钮时，this 和 currentTarget 都等于document.body，因为事件处理程序是注册到这个元素上的。然而，target 元素却等于按钮元素，因为它是 click 事件真正的目标。由于按钮上并没有注册事件处理程序，结果 click 事件就冒泡到了 document.body，在那里事件才得到了处理。 3. 鼠标事件属性在用鼠标触发事件时，主要的事件属性包含鼠标的位置和按键的状态，比如：clientX和clientY指定了鼠标在窗口坐标中的位置，button和which指定了按下的鼠标键是哪个。 12345678910111213141516function moveFn(event) &#123; console.log(event.screenX) // 获取鼠标基于屏幕的X轴坐标 console.log(event.screenY) // 获取鼠标基于屏幕的Y轴坐标 console.log(event.clientX) // 获取鼠标基于浏览器窗口的X轴坐标 console.log(event.clientY) // 获取鼠标基于浏览器窗口的Y轴坐标 console.log(event.pageX) // 获取鼠标基于文档的X轴坐标 console.log(event.pageY) // 获取鼠标基于文档的Y轴坐标&#125;function clickFn(event) &#123; console.log(event.button) // 获取鼠标按下的键。非IE浏览器中0为鼠标左键，1为鼠标中键，2为鼠标右键 console.log(event.which) // 获取指定事件上哪个键盘键或鼠标按钮被按下&#125;document.addEventListener('mouseover', moveFn, false);document.addEventListener('click', clickFn, false); 4.键盘事件属性在用键盘触发事件时，主要的事件属性包含键盘的按键keyCode和是否按下特殊键，比如：keyCode指定了按下键的键码值，ctrlKey指定是否按下了ctrl键。 123456789function keyFn(event) &#123; console.log(event.keyCode); // 获取按下键的键码值 console.log(event.ctrlKey); // 获取是否按下了ctrl键 console.log(event.shiftKey); // 获取是否按下了shift键 console.log(event.altKey); // 获取是否按下了alt键 console.log(event.metaKey); // 获取是否按下了meta键&#125;document.addEventListener('keyup', keyFn, false); 事件句柄 HTML 4.0 的新特性之一是有能力使 HTML 事件触发浏览器中的动作（action），比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，这些属性可插入 HTML 标签来定义事件动作。 属性 当以下情况发生时，出现此事件 onabort 图像加载被中断 onblur 元素失去焦点 onchange 用户改变域的内容 onclick 鼠标点击某个对象 ondblclick 鼠标双击某个对象 onerror 当加载文档或图像时发生某个错误 onfocus 元素获得焦点 onkeydown 某个键盘的键被按下 onkeypress 某个键盘的键被按下或按住 onkeyup 某个键盘的键被松开 onload 某个页面或图像被完成加载 onmousedown 某个鼠标按键被按下 onmousemove 鼠标被移动 onmouseout 鼠标从某元素移开 onmouseover 鼠标被移到某元素之上 onmouseup 某个鼠标按键被松开 onreset 重置按钮被点击 onresize 窗口或框架被调整尺寸 onselect 文本被选定 onsubmit 提交按钮被点击 onunload 用户退出页面]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《被嫌弃的松子的一生》中的松子要怎么做才能改变命运?]]></title>
    <url>%2Fnote%2F2018%2Fundefined23%2Fbc922f3.html</url>
    <content type="text"><![CDATA[对于非家人的方式就是：“你怎样对我，我就怎样对你。你的态度就是我的态度”。 爱自己，学会拒绝，完善自我。不要老是以圣人自诩，站在道德高地不觉得冷吗 面对无人幸免的孤独，对温暖的依恋是人类的本能。松子在这一点上走到了极致：即使自己被轻贱、被损害，也贪恋男人带来的一点点温暖，无法离开。 自古到今，圣人的结局都是一样的——奉献一生，上十字架。 松子的悲剧在于，生而为人，却没有按“人”的行为来处世，当然得不到人的幸福。人世的规律是，不劳而获，不会珍惜。 先爱自己，才能爱别人。能把一个人的生活过得潇洒，才能把两个人的幸福抓牢。 所有的爱的前提都是自我。首先一个人要完善了自我，才有资格去谈爱。同样，松子面临的是相同的问题。松子需要的是对自我的追求。不要把希望寄托在任何一个人身上。 妄图靠新建一段关系来解决原有问题都是要黄的。比如，靠结婚让生活变得更有趣。比如，养个孩子希望孩子实现当年自己没有实现的理想等。 松子的第一个问题在于没有边界意识。树立边界，意味着尊重自我，对自己负责，以及明白也仅能对自己负责。有了边界，才能学会拒绝外界的无理要求，也才能获得别人的尊重。一个连自己都不尊重的人，是无法赢得别人尊重的。这也是为什么松子对别人「好」却不被领情的原因，因为她的「好」是卑微的，是委曲求全的。这样的「好」，在别人眼里没有价值，也不会被感激。 在人格没有独立、完整和健康之前，所有自以为的「深情」，不过是一种自我感动式的牺牲和为了博得对方付出的「筹码」。 只有强者才有爱的能力，弱者的「爱」无论怎样伪装，本质都是一种变相的索取，其潜台词是「我都对你这么好了，你怎么还不来爱我？」。所以松子的「爱」往往得到的不是「爱来爱往」，而是拳打脚踢（里面的渣男依旧被谴责！无论怎样都不应该使用暴力！）。因为这样自我牺牲式的「爱」不仅廉价，还会让周围的人有一种被道德绑架的压力。 这里的「强者」不是指外在的名利地位，而是内在的独立、人格的健全以及价值观的笃定。所谓弱者也是相对而暂时的，当一个人不再需要从外界汲取能量才能生存，就逆袭成了强者。 当年看完松子给了我满满的负能量，松子，她太软弱了，她小心翼翼的追求爱，甚至曲意逢迎。这种爱毫无价值，一碰即碎。她恨，但她更多的是在恨自己，对于别人，不是不恨，是恨不起来。随之而来的是破罐子破摔，最后来一句“生而为人，对不起”。这是牢笼，冲不出去，那肯定是要死在里面的。 这样的松子，活着，比死了难捱。 所以，要知道什么时候该说“对不起”，什么时候该说“你滚蛋” 她似乎对人永远无错，对比起来永远别人不好，她让所有人感到自己不好，自己愧对她，她就是这样以此获得自己对自己高尚和正确的心理 需求。越往后，就越到那些暴虐的人那里找这种清白感， 就是越烂的人，她还就越好，对比的清清楚楚，心理觉得自己那么好那么好的需要就被很容易的满足了。并且当这个人对她不好或者要离开她 就正中她下怀： 你看你们那么坏，我是最好的人。可我这么这么苦，都是你们的错。 所以，我想说的是，松子其实自己有大错。 不是不爱自己云云，反而，她其实太爱自己。 她带着太多伤痛，不愿放下和原谅。把自己的恨握得太紧。一直抓着直到最后。 如果她及时原谅了父亲和妹妹，主要是父亲，并下决心依靠自己，而不是用自己的牺牲去要挟别人和掌控别人。不再从别人处挣认同和关注–得不到就觉得自己又受了害，不积累怨恨，不要用不满足，才能过上正常和有尊严和爱的生活吧。 最大的问题，影片要告诉我们的，就是放下。放下你童年受的伤害即使是虐待。原谅和忘却。即使你有一千一万个理由痛恨。这也就是上面有的回复说童年缺失爱的孩子，他的人生真的不可控么？我觉得影片正是想以松子的故事告诫大家，不管你有什么理由恨，请放下。因为这终将阻碍自己心灵的成长和成熟。 放下一路上积累的伤害。 伤害总会有，一生之中难以避免，不要携带和累积，而是主动清理和放下。不要一直向外界要爱，自己做一个能给与真爱的人。 只有这样，松子才会开始对自己的生命负责。才不再会通过自虐获得那一点点赖以生存的清白感。只有这样，才能真正去睁开眼睛，爱别人。 毕竟，只有原谅了这个世界，才能不再去交换爱，而是给与爱，对人对己。 电影《狗镇》 在结尾，车上两父女对话，我听到的对话版本是这样的： 傲娇女：他们是人，生活苦逼的人，他们有不可避免的人性的弱点，所以不能怪他们！ 萌爹：你不能因为狗依随它的本能做事就原谅它，狗也是可以学习的。 女：仁慈也错吗？ 爹：你不能抹杀他们的主观能动性。凭什么你自己犯错了，你会要求自己被惩罚，他们就不能？因为他们都是受本能驱动的，被环境塑造的？那你何尝不是？你给了自己一套严格的道德标准，错了就要惩罚自己，却不允许别人拥有这样一套标准。你太傲慢了！请尊重他们也有有错被罚的道德公平，请尊重他们的道德，他们的主观能动性。 “你说我傲慢……” “你视掠夺为天经地义！” “我就是讨厌你这点，你才是傲慢！” “我原谅别人，所以我傲慢？” “人犯了错，你必须惩罚、指责他们。你不惩罚，是不给他们知错的机会；你原谅他们，是因为你自以为你的道德高于他人，这就是傲慢！” 《在缅甸寻找乔治欧威尔》这本书里，曾提到一个缅甸传说。 有一个村庄，出没着一条恶龙，它神通广大，但无恶不作，每年要求村庄献祭一个处女，每年这个村庄都会有一个英雄去与恶龙搏斗，但无人生还。又一个少年英雄出发时，有人悄悄尾随。英雄用剑刺死恶龙，然后坐在尸身上，看着龙穴内闪烁的珠宝，慢慢地长出鳞片、尾巴和触角，最终变成恶龙。 当没有约束时，你会释放自己的恶吗？ 它的恐怖之处在于，它是一个锐利的、寒光闪闪的追问。在这个追问之下，我们自以为是的道德变得弱不经风：如果你是狗镇人，你会对一个无辜者施暴吗？再假如，暴力是民主化的，是被允许的，安全的、正当的，没有后顾之忧的，你也能从中获得某种满足的，满城皆如是、无人是例外的，你还敢信心满满地说不么？ 在看完《狗镇》之后，我长久地处于一种颤栗状态，是真实的肉体颤栗，而非修辞。它不由分说地，把我推到人性的法庭，拷问我的良知，审判我的德行，以至于后来，它们统统站不住脚，变成了可疑的存在。 我会吗？我敢和整个镇子唱反调吗？ 附： 真正的圣母心啊，是：能力不足，却心怀天下。为了自己的正义，让无辜的同伴惨死，永远说着冠冕堂皇的话，拖累队伍时身先士卒，在总有人救自己的前提下作死，然后风险全部被身边的人承担。害死全场角色还能哭哭啼啼的抹泪的彪悍人物。 注：本文均摘自知乎，侵删。]]></content>
      <categories>
        <category>泛娱乐</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>知乎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《鲁迅全集》--随笔]]></title>
    <url>%2Fnote%2F2018%2Fundefined22%2Ffc9c3c70.html</url>
    <content type="text"><![CDATA[对于迅哥的文章，读了很多次，可是很快就忘了。为了加深理解与记忆，决定写些感想。 彷徨祝福 “怎么死的?还不是穷死的?” “五年前的花白的头发，即今已经全白，全不像四十上下的人;脸上瘦削不堪，黄中带黑，而且消尽了先前悲哀的神色，仿佛是木刻似的;只有那眼珠间或一轮，还可以表示她是一个活物。她一手提着竹篮，内中一个破碗，空的;一手拄着一支比她更长的竹竿，下端开了裂:她分明已经纯乎是一个乞丐了。” 祥林嫂，做错了什么了吗。 没有， 弱小，贫穷都会是那些人打笑你的原因，他们容不下你。旧社会吃人，人吃人，封建礼制吃人。 生而为人，我很抱歉。 生活，有时就是这样，它不断派来一些傻逼的人，傻逼的事，不断折磨着你。它要削去你的美好的品质，剥去你的精气神，它要你行尸走肉，它要你屈服。 想到自己在生活中也会打趣我的室友，我的打趣过分吗？我的室友乐意接受吗？]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《高效能人士的七个习惯》]]></title>
    <url>%2Fnote%2F2018%2Fundefined16%2F371d2aad.html</url>
    <content type="text"><![CDATA[史蒂芬·柯维 著 甘肃人民出版社 第一部分重新探讨自我第一章：由内而外全面改造自己 品德成功论强调，圆满的生活与基本品德是不可分的。惟有修养自己具备品德才能享受真正的成功与恒久的快乐。 德为先早期的论著强调品德是成功之本，诸如正直、谦虚、诚信、公正。而近年来成功学由重视品德转而强调个人魅力，即胜者为王，毫不避讳地鼓励玩弄手段、欺骗他人。道德不过是用来装点门面，要紧的还是速成的技巧与捷径。 书里有个例子我的很好。由于受速成观念的影响，是否也渴望孩子能快速做成某些事，取得成功。当孩子做不到时，觉得有失颜面。我们扮演模范父母及维持形象，更甚于对孩子的关切。而我们的动机与观点强烈影响着孩子。 作者认为：只要有品德缺陷，终究成不了大器。 1234567891011121314151617181920作者的观点引起了我的讨论。首先，人人都是道德完人理想国，在可预见的时间内是不会实现的。高度的道德与现实生活水平或者个人利益是对立的吗？（额，作为还未毕业，未经社会洗礼的雏，在这坐而论道）如果周围太多人通过不是很道德的手段，过着比你舒服顺利的生活，你会受此影响吗？道德是既得利益者作为维稳和保护自己蛋糕的手段吗？作为还在校园里以道德圣人自居的我，遇到生活的柴米油盐还能保持道德底线吗？这个所谓的底线是什么？这个底线会随着前提条件而改变吗？如果底线不会改变，说明前提条件不够分量。通俗的例子是：让你陪我一晚上，给你100元，1000、100000、随着0的增多，大多人应该都会动摇吧。我的观点是：1.老老实实做人 如果不可以2.你可以欺骗，你可以玩弄手段。但是都应当以不损害别人的前提下。如果不可以算了怎么选择是自己的路，这些都是坐而论道，一切都要在事实中检验。实践是检验真理的唯一标准。 遇到事情多倾听我们总是透过自己思维的有色镜，去看这个世界，所以凡事多倾听。思维决定了行动和态度。 思维转换，一图胜千言： 请忽略图中文字。如果先看图1-1，再看图1-2一般会看到一个妙龄美人。先看图1-3再看图1-2，则会看到一个老妇。 遵循成长和变化的原则 步子大了，容易扯着蛋。 承认无知，暴露无知是求知的第一步（啊，回想起来，自己总是一副什么都懂的样子） 少倚重外力（比如，权势、美貌、武力。当外力失去了呢），堵不如疏。 如果，你讨厌一个人的话，即使表面表现的多么好，总会被人察觉。 第二章七个习惯–概论 习惯对我们的生活有绝大的影响，因为它是一贯的。在不知不觉中，经年累月影响着我们的品德，暴露出我们的本性，左右着我们的成败。 其实我认为培养习惯就是把一些行为变为潜意识。 “习惯”的定义本书将习惯定义为“知识”、“技巧”与“意愿”三者的混合体。 知识是理论性的观念，指点我们“做什么“及”为何做“。技巧是指”如何做“。意愿则是”想做“，表示我们有付出行动的愿望。要培养一种习惯，三项缺一不可。 成长模式图：成长三阶段 依赖：以自我为中心，成败由他人负责。 独立：自己负责，自由选择 互赖：从“我们出发”，合作共赢。 “有效性”的定义本书介绍的七个习惯最合乎效能原则，且效果最为持久。 “效能”：产出与产能必须平衡。不能一直索取。付出与索取是同时存在的。 产出：希望获得的结果。产能：借以达到目标的资产或本领。 例：要想车子骑得久，就要常常维护。 第二部分个人的成功：从依赖到独立第三章 习惯一：积极主动—个人愿景的原则 人性的本质是主动而非被动，不仅能消极选择反应，更能主动创造有利环境。 采取主动并不表示要强求、惹人厌或具有攻击性，只是不逃避为自己追求规划未来的责任。 别人的评价并不代表真正的你，充其量不过反映了说话者自身的想法与缺点而已。 我们受外界环境影响极大，但并不是起决定作用。现在社会盛传的“的决定论”，可分为三大类： 基因决定论：认为人的本性是祖先遗传下来的。比如脾气不好。 心理决定论：强调你的个性是受父母的影响。父母的教养方式与童年经验。 环境决定论：主张环境决定人的本性。周遭环境的人与事，经济情况、国家政策。 选择的自由对于外界的刺激，我们有选择如何回应的自由与能力。 积极主动积极主动是追求圆满人生的首要准则。它的含义不仅在于采取主动，还代表人必须为自己负责。 个人行为取决于自身，而非外在环境，不要把自己的行为归咎于外在环境或他人； 理智可以战胜情感，根据自身原则或价值观做有意识的选择； 人有能力也有责任创造有利的外在环境。 积极主动是人类的天性，如若不然，那就表示一个人有意或无意间原则消极被动。消极被动的人容易被外界影响。 天气好，高兴。不好，没精神。 受人礼遇，就愉快积极，反之则逃避退缩。 太多人只等待命运的安排或贵人的相助。 本书的其余六个习惯，都是以积极主动的精神为后盾。每个习惯都仰赖你积极主动，如果你消极等待，你就会受制于人，一旦受制于人，发展与机会便不在降临。 不要说“我办不到”我们可以利用自我意识检讨自身的观念，以言语为例，它颇能真切反映一个人对环境的态度。 习惯于被动消极的人，言语中就会流露出推卸责任的个性。 言语态度对照： 消极被动 我已无能为力 我就是这样一个人 他使我怒不可遏 他们不会接受的 我被迫······ 我不能 我必须 如果 积极主动 试试看有没有其它的可能性 我可以选择不同的作风 我可以控制自己的情绪 我可以想出有效的表达方式 我能选择恰当地回应 我选择 我情愿 我打算 做什么都是自愿，哪有什么被迫。自己的路，自己走。没有借口。 推诿责任的话语往往会强化宿命论。说者会一遍一遍被自己洗脑，变得更加自怨自艾，怪外部环境的不是。不要抱怨，去行动。爱，不仅是一种感觉，更是一种责任。爱，内含的是关心、照顾。 关注圈与影响圈（重要）从一个人对周遭事务关注范围的大小，以及发挥影响力的意志强弱，也能判断态度是否积极。每个人都有一些关注的问题，包括健康、子女、事业、经济状况或世界局势，这些可归入关注圈。其中有些是个人可以掌握的，有些则无能为力。把个人可以控制的事情圈起来，就形成“影响圈”。 着重于“影响圈”的人，脚踏实地，不好高骛远；把心力投注于自己能有所作为的事情，所获成就将使影响圈逐渐扩大。 反之消极的人全神贯注在自己不能掌控的事情上，时刻不忘环境的种种限制，他人的种种缺失，徒为无法改变的状况担忧。结果是怨天尤人，畏畏缩缩，受迫害的感觉日益强烈。由于着力方向错误而产生的副作用，影响圈便会缩小。 如果影响圈大于关注圈，可能此人自私浅薄。（这话感觉怪怪的） 积极主动的人，关注圈与影响圈不相上下，如此影响力才能做最有效的发挥。 总结： 不要关心天塌不塌，先关心今天有没有饭吃。不要关注叙利亚的战况，关注自己的家人。 然而又有一句话说，仰望星空，脚踏实地。 对比自己，每天关心大国能不能成功复兴，今年的经济危机会不会爆发，普通民众如何平安度过。 社会主义制度在中国还能走多远，社会大同还能不不能实现。 我好像出了偏差。 如何面对问题根据自主程度的高低，人生的问题可分为三类： 个人可直接控制。解决之道在于改变习惯。（本书习惯1.2.3讨论的就是这类） 个人可间接控制。改进发挥影响力的方法 无法控制。以微笑、真诚平和的态度，接纳这些问题。 无论什么问题，第一步就是改变习惯。 犯了错误要坦白承认。被毒蛇咬了，不是要先去抓蛇，这样会使毒性散的更快，应该尽快设法吸出毒汁。所以，不要一错再错。 第四章 习惯二：以终为始—自我领导原则 太多人成功之后，反而感到空虚；得到名利之后，却发现牺牲了更可贵的事物。因此，我们必需掌握真正重要的愿景，然后勇往直前坚持到底，是生活充满意义。 假设你正在前往殡仪馆的路上，要去参加一位至亲的丧礼，抵达之后亲朋好友集聚一堂，是为了向你告别。假设现在亲族代表、友人、同事即将上台追述你的生平。 请认真想一想，你最希望听到什么样的评语。 展 开 脑 洞 他的前半生经历了太多磨难，但它挺了过来。但同时也留下了很多难以愈合的心理创伤，他内心冷漠、不懂得爱、孤独，在人前可能总是面带微笑，一切都无所谓。其实所有的无情都是太过于深情。命运多舛，但他内心始终有光，即使他多次想过“生而为人，我很抱歉”，但他仍坚信未来有希望，他只是想抓住生活的最后一根稻草。后来赶上了编程的末班车，企图改变旧有的生活阶级。最后他的时常治愈自己的心理创伤，慢慢他拥有了真正的伙伴。他回家乡给亲人立了碑，他一生未娶，潜行修行技术，终于完善解决了人们生活中的难题，推动了人们的进步，实实在在改进了人们的生活，最后成一方扫地僧。他想回家建厂，让家乡热闹起来，不是只有过年外出打工的人才在家，而是孩子始终有家人的陪伴。慢慢着他学会主动联系他人，不，我想他学不会. 以终为始要究的是你的理想是什么？ 确定了你的人生目标，中间的路才不会太过弯曲，迷失自我。 想起一个故事： 在雪地里，孩子和父亲在比谁走出的路线更直。 孩子只顾脚下，父亲则始终以一个远方的参照物为标准。结果当然，父亲胜。 而你人生的终极目标，应该是你的人生盖棺定论时，你最想获得的评价。 所以每天都要问，假如今天是我生命中最后一天,你会怎样做 即方向比努力更重要，战略比战术更重要，道比术重要。 当生活出现苦难或挑战，就可以根据价值观与个人使命宣言决定相应的解决之道。 个人使命宣言是是行为处事的根本大法，好比一国宪法。不管世事如何多变，环境多么坚困，它依然不为所动。确定个人使命之后，我们就不必借助成见或偏见来面对局面，如此一来便能保持安全感。 直至核心想要确立个人使命，必须从影响圈的核心开始，因为这是一切思想观念的核心，也是安全感、人生方向、智慧与力量的源泉。 “安全感”代表价值观、认同、自尊自重与归属感。（参考：《被嫌弃的松子的一生》中的松子要怎么做才能改变命运?） 人生方向是生命的追求方向以及决断所依据的原则。 智慧是对事物的认知、理解与判断能力。 力量则指采取行动、达成目标的能耐。 这四者相辅相成，安全感与明确的方向可以带来智慧，智慧则能激发行动。若四者健全均衡发展，便能产生高尚的人格、平和的个性与完美正直的个体。 这四方面的成熟度，同样可以用依赖–独立–互赖三阶段来衡量。处于最底层依赖阶段的人，则极度缺乏安全感，他们凭借社会价值制定方向，对外界认识不清，缺乏行动勇气或受人摆布。若是在最高层依赖层次，则能肯定自我，处事泰然；他们明知自己努力的方向，深谙待人接物的艺术，积极主动。 你的生活重心是什么 配偶 家庭 金钱 工作 名利 享乐 宗教 自我 正确的重心是以原则为重心，综合了其它重心。 第五章 习惯三：要事第一—自我管理原则事情分四象限： 紧急 不紧急 重要 I II 不重要 III IV 管理方法标准 一、一致：个人理想与使命、角色与目标、工作重心与计划、欲望与自制之间，应该和谐一致。 二、平衡：管理方法应该有助于生活平衡发展、提醒我们扮演不同的角色，以免忽略了家人、健康、个人发展等重要的人生层面。不要以为某方面的成功可以补偿其它方面的遗憾，终非长久之计。难道成功的事业可以弥补破碎的婚姻、羸弱的身体或性格的缺失。 三、有重心:drooling_face:安排人生，多关注第二象限，重要不紧急的事情。 然而啊，有些人活着就已拼尽全力，一直在重要紧急的事情里出不来。穷人努力不叫努力，是拼命。富人才有资格谈努力。 四、重人性：管理的重点在人不在事。计划赶不上变化，有效的个人管理偶尔也需牺牲效率，更重视人际关系的得失。日程表的作用在于协助推行工作，并不是因进度落后而产生内疚感。 五、能变通：因地制宜。 个人管理四步骤 确定角色–不用长远，一周就好。 选择目标–为每个角色制定未来一周欲达成的2-3个重要成果。（务必有真正重要但不紧急的事） 安排进度–每个目标都可以当做某天的第一要务。 逐日调整–每天安排好行事计划，大小事务。 还有：授权（下达指令还是充分信任）、立即行动。 第三部分公众的成功：从独立到互赖。 第六章你不是一座孤岛未完-待续]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《JavaScript高级程序设计》（3）]]></title>
    <url>%2Fnote%2F2018%2Fundefined16%2F23e5c293.html</url>
    <content type="text"><![CDATA[[美] Nicholas C.Zakes 著 李松峰 曹力 译 （第三版） 第六章面向对象的程序设计 第七章函数表达式 第六章面向对象的程序设计ECMA-262把对象定义为：“无需属性的组合，其属性可以包含基本值、对象或者函数” 6.1理解对象6.1.1属性类型ES中有两种属性：数据属性和访问器属性。ECMA-62定义这些属性是为了实现js引擎用的，因此在js中不能直接访问它们。为了表示特性是内部值，一般把它们放在两对方括号内，如[[writable]]. 1.数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有四个描述其行为的特性。 value value是该属性的属性值，默认为undefined。 writable writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。 enumerable enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for…in循环、Object.keys()）跳过该属性。 configurable configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。 Object.getOwnPropertyDescriptor该方法可以获取属性描述对象。它的第一个参数是一个对象，第二个参数是一个字符串，对应该对象的某个属性名。 123var person = &#123; name : '窦唯' &#125;;Object.getOwnPropertyDescriptor(person , 'name' )//&#123;value: "窦唯", writable: true, enumerable: true, configurable: true&#125; Object.defineProperty()要修改属性默认的特性,必须用ECMAScript5的Object.defineProperty(),接受三个参数,属性所在对象,属性名称,一个描述符对象。其中描述符对象属性的特性必须是value 、configurable、writable和enumerable四个数据属性。如果一次性定义或修改多个属性，可以使用Object.defineProperties方法。 12345678var person = &#123;&#125;; Object.defineProperty(person,'name',&#123; value : '窦唯', writable : false &#125;); console.log(person.name);//窦唯 person.name = '大仙'; console.log(person.name);//窦唯,当writable为true时，返回大仙。 在调用Object.defineProperty()方法创建一个新属性时，如果不指定configurable、writable和enumerable特性的默认值都是false，value不指定是undefined。 1234567var person = &#123;&#125;; Object.defineProperty(person,'name',&#123; 'value' : '窦唯', 'writable' : false &#125;);Object.getOwnPropertyDescriptor(person,'name');// &#123;value: "窦唯", writable: false, enumerable: false, configurable: false&#125; 2.访问器属性访问器属性不包含数据值,它们包含一对getter和setter函数,(不过这两个函数都不是必须的)，默认都是undefined。访问器属性不能直接定义，必须用Object.defineProperty()来定义。 在读取访问器属性时会调用getter函数，在写入访问器属性时调用setter函数。访问器属性具以下四个特性： configurable enumerable set get 访问器属性作用的对象是属性 1234567891011121314151617var book = &#123; _year: 2004, edition: 1 &#125;; Object.defineProperty(book, "year", &#123; get: function () &#123; return this._year; &#125;, set: function (newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;); book.year = 2005; console.log(book.edition);//2 通过访问器属性的可以设置一个属性值，进而改变另一个属性。 year用_year代替.前面加下划线是常用的用法,表示只能用对象方法访问的属性.如果用year回导致死循环赋值. 6.2创建对象虽然Object构造函数或对象字面量都可以用来创建单个对象，但这个方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重读代码(当创建多个具有相同属性的实例时，会有大量的代码重复)。为此引入了工厂模式。 6.2.1工厂模式工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到ES中无法创建类，于是开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节。例： 12345678910111213141516function createPerson (name,age,job) &#123; var o = new Object(); ////这个对象就相当于模子 o.name = name; o.age= age; o.job=job ; o.sayName= function() &#123; alert(this.name); &#125;; return o; //函数被调用时就会返回这个对象&#125;var person1 = createPerson("小明",29,"歌手");var person2 = createPerson("李志", 30,"singer");console.log(person1 instanceof Object); //trueconsole.log(person1 instanceof createPerson); //false 工程模式与构造函数模式差别就在于此 工厂模式解决了创建多个相似对象的问题，但却没有解决对象识别问题（即怎么知道一个对象的类型）。存疑？？？ 6.2.2构造函数模式ECMAScript中构造函数可以创建特定类型的对象。类似于Array、Date等原生构造函数，也可以创建自定义的构造函数。例如，使用构造函数模式将前面的例子重写如下。 1234567891011121314function Person (name,age,job) &#123; this.name = name; this.age= age; this.job=job ; this.sayName= function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person("小明",29,"歌手");var person2 = new Person("李志", 30,"singer");console.log(person1 instanceof Object); //trueconsole.log(person1 instanceof person); //true 工程模式与构造函数模式差别就在于此 构造函数与工厂模式创造的函数的不同之处： 没有显式地创建对象； 直接将属性和方法赋值给了this对象； 没有return语句； 函数首字母大写（为了区别于普通函数）； 调用函数时用到new操作符。 1.把构造函数当作函数 构造函数与其他函数唯一区别在于是否通过new操作符来调用。前面的Person函数可以通过以下方式来调用： 123456789// 当成构造函数来用var person1 = new Person("小明",29,"歌手");//作为普通函数来用Person("小明",29,"歌手"); //添加到WindowWindow.sayName();//'小明'//在另一个对象作用域中调用var o = new Object ();Person.call(o, "小明",29,"歌手");o.sayName();//'小明' 2.函数构造问题 构造函数的最大的问题在于每次创建实例的时候都要重新创建一次方法 ,然而创建两次完全相同的方法是没有必要的，因此，我们可以将函数移到对象外面 . 不同实例上的同名函数是不相等的。 12345678910111213function Person (name,age,job) &#123; this.name = name; this.age= age; this.job=job ; this.sayName=sayName,&#125;function sayName()&#123; alert(this.name);&#125;var person1 = new Person("小明",29,"歌手");var person2 = new Person("李志", 30,"singer"); person1和person2对象就共享了在全局作用域的一个sayName（）函数，这样就由两个变为一个。新问题来了：在全局作用域中，定义的函数实际上只能被某个对象调用，让全局作用域有点名不副实，而且如果对象需要定义多个函数，那么就要定义多个全局函数，那么这个引用类型就丝毫没有封装性可言了。这个问题可以通过原型模式来解决。 6.2.3原型模式在js里面，每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示。 12345678910111213function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123;alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //"Nicholas"var person2 = new Person();person2.sayName(); //"Nicholas"alert(person1.sayName == person2.sayName); //true 1.理解原型对象无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype 属性所在函数的指针。就拿前面的例子来说，Person.prototype. constructor 指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。 创建了自定义的构造函数之后，其原型对象默认只会取得constructor 属性；至于其他方法，则都是从Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262 第5 版中管这个指针叫[[Prototype]]，而在其他实现中，这个属性对脚本则是完全不可见的,这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。以前面使用Person 构造函数和Person.prototype 创建实例的代码为例，图6-1 展示了各个对象之间的关系。 图6-1 展示了Person 构造函数、Person 的原型属性以及Person 现有的两个实例之间的关系。虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。 isPrototypeOf(object)判断该对象是否为另一个对象的原型。如果[[Prototype]]指向调用isPrototypeOf(object)方法的对象（Person.prototype）,那么这个方法就返回true。如下所示： 1alert (Person.prototype.isPrototypeOf(persona1) );//true ES5增加了一个方法，Object.getPrototypeof(),这个方法返回[[Prototype ]]的值。例如： 12alert（Object.getPrototypeof(person1) == Person.prototype); //true alert（Object.getPrototypeof(person1).name);//"Nicholas " 每当代码读取某个属性时，都会执行一次搜索，目标是否具有给定名字的属性。搜索首先从对象实例本身开始，如果找到返回该属性值。否则接着搜素指针方向的原型对象。 如果实例中有与原型中同名的属性，在搜索是会返回实例中的属性值，即原型中的属性值会被屏蔽，仍存在，当实例中的属性被删除时，则原型中的同名属性可被访问到。 接下来怎么知道是来自实例还是原型链呢。 hasOwnProperty(),当给定的属性存在于实例中，返回true。 1234567891011121314function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123;alert(this.name);&#125;;var person1 = new Person();person1.name = "Greg";alert (personl.hasOwnProperty("name")); //truealert（"age" in person1）;//true 2.原型与in操作符单独使用in操作符会在能够通过对象访问的属性是返回true，不管是在原型链还是实例中。 同时使用in操作符和hasOwnProperty()方法，就可以确定该属性是存在于对象中还是原型中。 12345function hasPrototypeProperty(object,name)&#123; return !object.hasOwnproperty(name)&amp;&amp;(name in object );&#125;alert (hasPrototypeProperty(person ,"age")) //ture 其实这个函数个单独的hasOwnProperty()效果基本一样。hasOwnProperty()确定属性在实例中，这个函数确定属性在原型中。 在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的属性。（不可枚举的属性，[[enumerable]]标记为false的属性比如toString()、valueof()等） Object.keys()方法，接受一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。 1234567891011121314151617function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123;alert(this.name);&#125;;var keys = Object.keys(Person.prototype);alert (keys); //"name ,age ,job ,sayName"var p1 = new Person ();p1.name = "rob"p1.age = 31;var p1keys = Object.keys(p1);alert (p1keys);// "name ,age " 取得了所有的可枚举的实例属性 取得了所有实例属性，不管是否可枚举通过Object.getOwnPropertyNames(); 12var keys = Object.getOwnPropertyNames(Person.prototype);alert (keys); // "constructor, name ,age ,job ,sayName" 3.更简单的原型语法前面的例子中每添加一个属性和方法就要敲一遍Person.prototype，为了减少不必要的输入，也为了从视觉上更好地封装原型的功能，用对象字面量来重写整个原型。如下： 1234567891011function Person()&#123;&#125;Person.prototype =&#123; constructor:Person ,//constructor属性的属性值设置为：Person。 name : "Nicholas", age : 29, job : "Software Engineer", sayName : function()&#123; alert(this.name); &#125;&#125;; 在上面代码中，我们把Person.prototype以一个对象字面量的形式创建新对象。结果相同，但有一个例外：constructor属性不再指向Person了。每创建一个函数，就会同时创建它的prototype对象，这个对象也会自动获得constructor属性。而第二个方法则本质上重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数（如果constructor属性很重要，可以显式的把constructor属性的属性值设置为：Person。constructor：Person。而这种重设会导致它可以被枚举）。此时，尽管Instanceof操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了。 4.原型的动态性不重写原型，创建实例是在修改原型之前还是之后，属性都能够从实例反映出来。 12345678910111213141516function Person ()&#123;&#125;var friend = new Person ();//先创建实例Person.prototype.sayHi = function ()&#123; alert ("hi");&#125;;friend.sayHi(); //hifunction Person ()&#123;&#125;Person.prototype.sayHi = function ()&#123; alert ("hi");&#125;;var friend = new Person ();//后创建实例friend.sayHi(); //hi 重写原型，实例只有在重写之后创建，属性才能被实例访问到。 123456789function Person ()&#123;&#125;var friend = new Person ();Person.prototype=&#123; sayHi : function ()&#123; alert ("hi"); &#125;&#125;;friend.sayHi(); //error 123456789function Person ()&#123;&#125;Person.prototype = &#123; sayHi : function ()&#123; alert ("hi"); &#125;&#125;;var friend = new Person ();friend.sayHi(); //hi 重写原型对象切断了现有原型与任何之前已经存在的对象实例的联系；它们引用的仍然是最初的原型。 5.原生对象的原型原型模式不仅体现在创建自定义类型方面，就连所有的原生引用类型，都是采用这种模式创建的。因此通过原生对象的原型，不仅可以取得所有默认方法的引用，而且可以定义新方法。在Array.prototype中可以找到sort()方法。例：下面给基本包装类型String添加了一个名为statWith()的方法 12345String.prototype.starsWith = function (text)&#123; return this.indexOf(text) == 0;&#125;;var msg = "Hello world";alert (msg.starsWith("Hello")); //ture 验证文本msg里是否有字符串，且在起始位。 6.原型对象的问题问题是啥，问题是有原型模式的共享的优点引起的。如果对某一个实例在原型上进行修改，则会影响到其它实例，总是通过实例添加修改不方便， 所以呢，就有了接下来讲的组合。 12345678910111213141516171819function Person()&#123;&#125;Person.prototype =&#123; constructor:Person ,//constructor属性的属性值设置为：Person。 name : "Nicholas", age : 2, job : "Software Engineer", friends : ["Shelby","Court"], sayName : function()&#123; alert(this.name); &#125;&#125;;var persona1 = new Person ();var persona2 = new Person ();persona1.friends.push("van");alert (persona1.friends); // Shelby,court,vanalert (persona2.friends); // Shelby,court,van 6.2.4组合使用构造函数模式和原型模式构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。结果，每个实例都会有自己的一份实例属性副本（修改不会互相影响），但同时有共享着对方方法的引用。 123456789101112131415161718function Person (name,age,job) &#123; this.name = name; this.age= age; this.job=job ; this.friends = ["Shelby","Court"];&#125;Person.prototype =&#123; constructor:Person ,//constructor属性的属性值设置为：Person。 sayName : function()&#123; alert(this.name); &#125;&#125;var person1 = new Person("小明",29,"歌手");var person2 = new Person("李志", 30,"singer");person1.friends.push("van");alert (person1.friends); // Shelby,court,vanalert (person2.friends); // Shelby,court 6.2.5动态原型模式6.3继承许多OO 语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript 中无法实现接口继承。ECMAScript 只支持实现继承，而且其实现继承主要是依靠原型链来实现的。 补充：签名. 签名可以用来实现类型检查、函数重载、接口（interface）等等，而这些东西 js 都没有。 看wiki解释Type signature 在计算机科学中，类型签名或类型注释定义了函数，子例程或方法的输入和输出。类型签名包括参数的数量，参数的类型以及函数包含的参数的顺序。通常在重载解析期间使用类型签名来选择要在许多重载表单之间调用的函数的正确定义。 ​ 补充完毕 6.3.1原型链ES中主要利用原型链来实现继承，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的针，而实例都包含一个指向原型对象的内部指针。如图： 那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。实现原型链有一种基本模式，其代码大致如下。 12345678910111213141516171819//父类function SuperType()&#123;this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123;return this.property;&#125;;//子类function SubType()&#123;this.subproperty = false;&#125;SubType.prototype.getSubValue = function ()&#123;return this.subproperty;&#125;;//怎么实现继承SubType.prototype = new SuperType(); // 父类的实例赋值于子类的原型,即实例里的固有[[Prototype]]、property属性赋予子类的的原型，既造成两个原型链的链接，即现在父类的原型被指向子类的原型，那么子类的原型也同时拥有了父类constructor属性和getSuperValue方法，同时父类的constructor属性覆盖了子类的constructor属性，即子类的constructor属性被重写，相当于子类的原型被重写。这时instance.constructor指向SuperType。现在原型搜素机制是先搜子类的实例，然后子类的原型接着搜索父类的原型。var instance = new SubType();alert(instance.getSuperValue()); //true 1.别忘记默认的原型 2.确认原型与实例的关系两种方式： 使用instanceof操作符。实例与原型链中出现过的构造函数，结果会返回true。 123alert( instance instanceof Object);//true alert( instance instanceof SuperType);//true alert( instance instanceof SubType);//true 使用isPrototypeOf()方法.同样只要是原型链中出现过的原型，都可以说是该原型链所派生实例的原型。 1alert (Object.prototype.isPrototypeof(instance));//ture Object 换为SuperType、SubType同样成立 3.谨慎地定义和方法（本章多余，写出来不想删了）12345678910111213141516171819202122//父类型function SuperType()&#123;this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123;return this.property;&#125;;//子类function SubType()&#123;this.subproperty = false;&#125;SubType.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;;//实现继承SubType.prototype = new SuperType(); //重写父类型中的方法SubType.prototype.getSuperValue =function ()&#123; return false ;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //false 当重写父类的方法时，通过父类型调用，仍是原来的方法，通过子类型调用则是重写后的方法。 4.原型链的问题原型链并非十分完美, 它包含如下两个问题. 问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享; 问题二: 在创建子类型 的实例时,不能向超类型(例如父类型)的构造函数中传递参数. 有鉴于此, 实践中很少会单独使用原型链. 为此,下面将有一些尝试以弥补原型链的不足. 6.3.2借用构造函数为解决原型链中上述两个问题, 我们开始使用一种叫做借用构造函数(constructor stealing)的技术(也叫经典继承). 基本思想:即在子类型构造函数的内部调用超类型构造函数. 123456789101112function Father()&#123; this.colors = ["red","blue","green"];&#125;function Son()&#123; Father.call(this);//继承了Father,且向父类型传递参数&#125;var instance1 = new Son();instance1.colors.push("black");console.log(instance1.colors);//"red,blue,green,black"var instance2 = new Son();console.log(instance2.colors);//"red,blue,green" 可见引用类型值是独立的 很明显,借用构造函数一举解决了原型链的两大问题: 其一, 保证了原型链中引用类型值的独立,不再被所有实例共享; 其二, 子类型创建时也能够向父类型传递参数. 随之而来的是, 如果仅仅借用构造函数,那么将无法避免构造函数模式存在的问题–方法都在构造函数中定义, 因此函数复用也就不可用了.而且超类型(如Father)中定义的方法,对子类型而言也是不可见的. 考虑此,借用构造函数的技术也很少单独使用. 6.3.3组合继承组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式. 基本思路: 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承. 这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性. 如下所示. 12345678910111213141516171819202122232425function Father(name)&#123; this.name = name; this.colors = ["red","blue","green"];&#125;Father.prototype.sayName = function()&#123; alert(this.name);&#125;;function Son(name,age)&#123; Father.call(this,name);//继承实例属性，第一次调用Father() this.age = age;&#125;Son.prototype = new Father();//继承父类方法,第二次调用Father()Son.prototype.sayAge = function()&#123; alert(this.age);&#125;var instance1 = new Son("louis",5);instance1.colors.push("black");console.log(instance1.colors);//"red,blue,green,black"instance1.sayName();//louisinstance1.sayAge();//5var instance1 = new Son("zhai",10);console.log(instance1.colors);//"red,blue,green"instance1.sayName();//zhaiinstance1.sayAge();//10 组合继承避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为 JavaScript 中最常用的继承模式. 而且, instanceof 和 isPrototypeOf( )也能用于识别基于组合继承创建的对象. 6.3.4原型式继承该方法最初由道格拉斯·克罗克福德于2006年在一篇题为 《Prototypal Inheritance in JavaScript》(JavaScript中的原型式继承) 的文章中提出. 他的想法是借助原型可以基于已有的对象创建新对象， 同时还不必因此创建自定义类型. 大意如下: 在object()函数内部, 先创建一个临时性的构造函数, 然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例. 12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 从本质上讲, object() 对传入其中的对象执行了一次浅复制. 下面我们来看看为什么是浅复制. 12345678var person = &#123; friends : ["Van","Louis","Nick"]&#125;;var anotherPerson = object(person);anotherPerson.friends.push("Rob");var yetAnotherPerson = object(person);yetAnotherPerson.friends.push("Style");alert(person.friends);//"Van,Louis,Nick,Rob,Style" 在这个例子中,可以作为另一个对象基础的是person对象,于是我们把它传入到object()函数中,然后该函数就会返回一个新对象. 这个新对象将person作为原型,因此它的原型中就包含引用类型值属性. 这意味着person.friends不仅属于person所有,而且也会被anotherPerson以及yetAnotherPerson共享. 在 ECMAScript5 中,通过新增 object.create() 方法规范化了上面的原型式继承. object.create() 接收两个参数: 一个用作新对象原型的对象(可选的)一个为新对象定义额外属性的对象 12345678var person = &#123; friends : ["Van","Louis","Nick"]&#125;;var anotherPerson = Object.create(person);anotherPerson.friends.push("Rob");var yetAnotherPerson = Object.create(person);yetAnotherPerson.friends.push("Style");alert(person.friends);//"Van,Louis,Nick,Rob,Style" object.create() 只有一个参数时功能与上述object方法相同, 它的第二个参数与Object.defineProperties()方法的第二个参数格式相同: 每个属性都是通过自己的描述符定义的.以这种方式指定的任何属性都会覆盖原型对象上的同名属性.例如: 123456789var person = &#123; name : "Van"&#125;;var anotherPerson = Object.create(person, &#123; name : &#123; value : "Louis" &#125;&#125;);alert(anotherPerson.name);//"Louis" 提醒: 原型式继承中, 包含引用类型值的属性始终都会共享相应的值, 就像使用原型模式一样. 1234567891011121314151617181920212223242526272829function Parent() &#123; this.a = 1; this.b = [1, 2, this.a]; this.c = &#123; demo: 5 &#125;; this.show = function () &#123; console.log(this.a , this.b , this.c.demo); &#125;&#125;function Child() &#123; this.a = 2; this.change = function () &#123; this.b.push(this.a); this.a = this.b.length; this.c.demo = this.a++; &#125;&#125;Child.prototype = new Parent();var parent = new Parent();var child1 = new Child();var child2 = new Child();child1.a = 11;child2.a = 12;parent.show();// 1,[1,2,1],5child1.show();//11,[1,2,1],5child2.show();12,[1,2,1],5child1.change();child2.change(); 第七章函数表达式函数的定义参考5.5章。 7.1递归递归函数是在一个函数通过名字调用自身的情况下构成的，如下所示。 1234567function factorial(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * factorial(num-1); &#125;&#125; 这是一个经典的递归阶乘函数。虽然这个函数表面看来没什么问题，但下面的代码却可能导致它出错。 123var anotherFactorial =factorial;factorial = null;alert(anotherFactorial(4));//出错！ 以上代码先把 factorial()函数保存在变量 anotherFactorial 中，然后将 factorial 变量设置为 null，结果指向原始函数的引用只剩下一个。但在接下来调用 anotherFactorial()时，由于必须执行 factorial()，而 factorial 已经不再是函数，所以就会导致错误。在这种情况下，使用 arguments.callee 可以解决这个问题。我们知道， arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用，例如： 12345678function factorial (num) &#123; // body... if (num&lt;=1) &#123; return 1; &#125;else&#123; return num*arguments.callee(num-1); &#125; &#125; 使用 arguments.callee 代替函数名，可以确保无论怎样调用函数都不会出问题。因此，在编写递归函数时，使用 arguments.callee 总比使用函数名更保险。但在严格模式下，不能通过脚本访问 arguments.callee，访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果。例如： 1234567var factorial = (function f(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * f(num-1); &#125;&#125;); 以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 factorial。即便把函数赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。 7.2闭包闭包：是指有权访问另一个函数作用域中的变量的函数。 创建闭包的常用方式，就是在一个函数内部创建另一个函数。 7.2.1闭包与this在闭包中使用this对象也可能会导致一些问题。this的对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的的方法调用时，this等于那个对象 12345678910补充：function fun()&#123; return 5&#125;var a=fun//把函数指针地址复制一份var b=fun()//立即调用函数，返回函数运行结果function b ()()//运行b的子函数function b ()()()//运行b的孙函数 比如： 12345678910111213function createComparisonFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName];//访问外部函数中的变量 var value2 = object2[propertyName]; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 加深理解，两个代码段。 1234567891011121314//代码1var name = "The Window";var object = &#123; name : "My Object", getNameFunc : function()&#123; return function b ()&#123; return this.name; &#125;; &#125; &#125;;alert(object.getNameFunc()());//The Windowalert(object.getNameFunc();//function b ()&#123; return this.name; &#125;; 123456789101112131415161718192021var name = "The Window";var object = &#123; name : "My Object", getNameFunc : function()&#123; return function b ()&#123; return this.name; &#125;; &#125; &#125;;alert(object.getNameFunc()());上面的代码效果等同于var name = "The Window";function b ()&#123; return this.name; &#125;;alert( b());//首先alert(object.getNameFunc())返回函数b，即把b函数推出对象object。 1234567891011var name = "The Window";var object = &#123; name : "My Object", getNameFunc : function()&#123; return this.name; &#125; &#125;;alert(object.getNameFunc());//My Object 1234567891011121314151617//代码2var name = "The Window";var object = &#123; name : "My Object", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()());//My Object 关于this 1234567891011121314var name = "The Window";var object = &#123; name : "My Object", getName : function()&#123; return this.name; &#125; &#125;;// 几种调用object.getName()的方式object.getName();//My Object(object.getName)();//My Object(object.getName=object.getName)();//The Window复制表达式的值是函数本身，所以this的不能得到维持。 补充：函数与方法 他们大致是一样的，只不过方法（method）通常在函数内部，这就意味着方法可以操作函数（function）内部的数据，这是其一；另外，从传参的角度来讲，方法（method）相比函数（function）显式传递来说，通常是隐式传参，这是其二。 方法是作为对象的属性的函数。。。 由于JavaScript中的函数(包括闭包)会创建并携带外部的作用域链；所以，建议： 闭包的嵌套不要太深；闭包嵌套越深，占用的内存空间就越大； 不要使用过多的闭包；因为闭包较占内存； 闭包不会造成内存泄漏。程序写错了才会造成内存泄漏。 另外，那些书讲的事情应该是：老浏览器（主要是IE6）由于垃圾回收有问题导致很容易出现内存泄漏。但是那是浏览器实现的bug。如果书里面没把这个意思写清楚，那就是本烂书，不要看了，赶紧扔掉。 闭包会造成内存泄露？ 错。 说这话的人根本不知道什么是内存泄露。内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。 闭包里面的变量明明就是我们需要的变量，凭什么说是内存泄露？ 这个谣言是如何来的？ 因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。 这是 IE 的问题，不是闭包的问题。 7.2.2闭包与变量闭包只能取得包含函数中任何变量的最后一个值。闭包保存的是整个变量对象，而不是某个特殊的变量，下面这个例子可以清楚的说明这个问题。 12345678910111213141516171819202122232425262728293031323334function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result; &#125; var funcs = createFunctions(); alert(fucs);//此时p是包含函数function() &#123;return i;&#125;的数组。//every function outputs 10 for (var i=0; i &lt; funcs.length; i++)&#123; document.write(funcs[i]() + "&lt;br /&gt;"); //输出10个10 &#125; function createFunctions()&#123; var result = new Array(); for(var i=0;i&lt;10;i++)&#123; result[i]=function(num)&#123; return function()&#123; return num; &#125;; &#125;(i); &#125; return result;&#125;var fuc=createFunctions(); fuc[0]();//0 function(num){…}(i)是自执行函数，由于函数的参数是按值传递的，也就是说，被传递的i会被复制给函数内部的局部变量num，所以每次执行的i并不相同，那么函数内部的变量num的值也就并不相同 . 自运行函数是什么？其实就是函数运行的返回值。 循环结束后十个函数已经定义好了，但是一次都没有调用过。它们读写同一个 i 。 因为是按引用传递的。 引用传递你知道吧？就是传递一个内存地址，每次值发生变化，i也会跟着变化，他们是同一个内存地址。 变化到最后i就固定10了。 7.3模块级作用域]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《JavaScript高级程序设计》（2）]]></title>
    <url>%2Fnote%2F2018%2Fundefined07%2F9b59a5f6.html</url>
    <content type="text"><![CDATA[[美] Nicholas C.Zakes 著 李松峰 曹力 译 （第三版） 本文以JS高程为主线， 阮一峰的《 JavaScript标准参考教程》为辅。 第四章 变量、作用域和内存问题 第五章 引用类型 第四章 变量、作用域和内存问题本章内容： 理解基本类型和引用类型的值 理解执行环境 理解垃圾收集 4.1 基本类型和引用类型的值基本类型的访问是按值访问的，就是说你可以操作保存在变量中的实际的值。我们不能给基本类型添加属性和方法。 基本类型的值是不可变的： 比如一个字符串： 1var name = 'jozo'; name.toUpperCase(); // 输出 'JOZO' console.log(name); // 输出 'jozo' 会发现原始的name并未发生改变，而是调用了toUpperCase()方法后返回的是一个新的字符串。 4.1.1 复制变量值复制基本类型的值，会在对象变量上创建一个新值，然后把该值复制到为新变量分配的位置上。例： 12var num1 = 5;var num2 = num1; 其过程如下： 复制前的变量值 num1 5（Number类型） 复制后的变量对象 num2 5（Number类型） num1 5（Number类型） 这两个变量可以独立操作而不受任何影响。 复制引用类型的值，会把对象变量的值复制一份，然后把该值放到 到为新变量分配的位置上。例子： 1234var obj1 = new Object();var obj2 = obj1;obj2.name = "我有名字了";console.log(obj1.name); // 我有名字了 由上面例子，我们声明了一个引用数据类型变量obj1，并把它赋值给了另外一个引用数据类型变量obj2。当我们obj2添加了一个name属性并赋值”我有名字了”。obj1同样拥有了和obj2一样的name属性。说明这两个引用数据类型变量指向同一个堆内存对象。obj1赋值给obj2，实际只是把这个堆内存对象在栈内存的引用地址复制了一份给了obj2，但它们本质上共同指向了同一个堆内存对象。 下面我们来演示这个引用数据类型赋值过程： 自然，给obj2添加name属性，实际上是给堆内存中的对象添加了name属性，obj2和obj1在栈内存中保存的只是堆内存对象的引用地址，虽然也是拷贝了一份，但指向的对象却是同一个。故而改变obj2引起了obj1的改变。 这一段引自本链接 4.1.2 传递参数访问变量有按值和按引用两种方式（如同变量的基本类型值的复制和引用类型的值的复制），而参数只按值传递。 其实可以这么理解，只有按值传递。只不过基本类型传递是变量本身实在的值，而引用类型传递是也是变量的值，只不过这里的值是引用地址。 4.2 执行环境及作用域执行环境：定义了变量和函数有权访问的其他数据，决定了他们各自的行为。 JavaScript中的运行环境大概包括三种情况：（1）全局环境：JavaScript代码运行起来会首先进入该环境（2）函数环境：当函数被调用执行时，会进入当前函数中执行代码（3）eval 全局执行环境是最外层的一个执行环境。在web浏览器中全局执行环境被认为是window对象。每个函数都有自己的执行环境。内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境的任何变量和函数；这是因为某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数也会被销毁。这也解释了局部变量不能在变量对象被外访问到的原因。 作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。当代码在一个环境中执行时，都会创建一个作用域链。 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。 4.2.1 延长作用域链：虽然执行环境只有两种——全局作用域和局部作用域，但是还是可以通过某种方式来延长作用域链。因为有些语句可以在作用域链的顶部增加一个临时的变量对象。有两种情况会发生这种现象：1、try-catch语句的catch块；2、with语句； 4.2.2 没有块级作用域在其他类c语言中由花括号封闭的代码块都有自己的作用域，即js中执行环境。 任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。比如： 1234if （true）&#123; var color = "blue";&#125;alert color; 在js中color在外部仍可以访问到，而在有块级作用域的语言中，则访问不到。只有函数后的的代码块才是执行环境。 4.3 垃圾收集内存生命周期 不管什么程序语言，内存生命周期基本是一致的： 分配你所需要的内存 使用分配到的内存（读、写） 不需要时将其释放\归还 垃圾回收的机制原理：找出不再使用的变量，然后释放掉其占用的内存。垃圾回收器会按照固定的时间或预定的的时间间隔周期性的执行。 来看下局部变量的生命周期。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，一旦函数结束，局部变量就没有存在必要了，可以释放它们占用的内存。但并不是所有的变量都那么容易判断是否还有存在的必要。 垃圾回收器必须知道哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来回收。用于标记无用变量的策略有很多，常见的有两种方式： 1. 标记清除垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量的标记和被环境中的变量引用的变量的标记，此后，如果变量再被标记则表示此变量准备被删除。 简单来说：垃圾收集器中有俩次判断变量是否要被收集。如果这俩次没逃脱掉，那就肯定要被收集的。一是变量未被引用，二是已经执行过finalize方法。。。也就是俩次标记，具体可以查下Jvm垃圾收集算法。参考自 2. 引用计数引用计数的含义是跟踪记录每个值被引用的次数。 注意是值被引用的计数，释放的是值所占的内存。 当创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1，在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1，需要释放一个对象时，就将该对象的引用计数减1，直至对象的引用计数为0，对象的内存会被立刻释放。 这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 示例 12345678910111213141516var o = &#123; a: &#123; b:2 &#125;&#125;; // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o// 很显然，没有一个可以被垃圾收集var o2 = o; // o2变量是第二个对“这个对象”的引用o = 1; // 现在，“这个对象”的原始引用o被o2替换了，即现在“这个对象”只被o2一个引用。var oa = o2.a; // 引用“这个对象”的a属性// 现在，“这个对象”有两个引用了，一个是o2，一个是oao2 = "yo"; // 最初的对象现在已经是零引用了 // 他可以被垃圾回收了 // 然而它的属性a的对象还在被oa引用，所以还不能回收oa = null; // a属性的那个对象现在也是零引用了 // 它可以被垃圾回收了 该算法有个限制：无法处理循环引用。 两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收 12345678function f()&#123; var o = &#123;&#125;; var o2 = &#123;&#125;; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o return "azerty";&#125;f(); 解除引用；一旦数据不再有用，通过将其值设置为null来释放其引用。 局部变量就是在离开执行环境时自动被解除引用。解除引用不意味释放内存，而是让值脱离执行环境，以便垃圾收集器运行时将其收回。 4.4 堆内存与栈内存在JS中，每一个数据都需要一个内存空间。内存空间又被分为两种，栈内存(stock)与堆内存 栈内存 堆内存 存储基础数据类型 存储引用数据类型 按值访问 按引用访问 存储的值大小固定 存储的值大小不定，可动态调整 由系统自动分配内存空间 由程序员通过代码进行分配 主要用来执行程序 主 要用来存放对象 空间小，运行效率高 空间大，但是运行效率相对较低 先进后出，后进先出 无序存储，可根据引用直接获取 第五章 引用类型引用类型的值（对象）是引用类型的一个实例。引用类型是一种数据结构，用于将数据和功能组织在一起。它也被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。 上面这句话应该意味着 引用类型是类在js中进行了修正以更符合js的要求一个变种。 面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 新对象是使用new操作符后跟一个构造函数来创建的，构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。例： 1var person = new Object(); 这行代码创建了Object引用类型的一个新实例，然后把该实例保存在了变量person中。使用的构造函数是Object，它只为新对象定义了默认的属性进和方法。 对象：对象是类的一个实例 ，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 下图中男孩女孩为类，而具体的每个人为该类的对象： 参考链接：Java 对象和类 5.1 Object 类型对象就是一组“键值对”（key-value，键名和键值）的集合，是一种无序的复合数据集合。 对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键值），所以加不加引号都可以。但是如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。如果属性的值还是一个对象，就形成了链式引用。 创建Object实例的方法有两种。第一种是使用new操作符后跟Object构造函数，如下所示： 123var person = new Object（）；person.name = "xiangming";person.age = 29; 另一种方法是使用对象字面量表示法。 12345678910111213var person = &#123; person.name ： "xiangming"; 5 ： true； person.age ： 29； //最后一个属性后面，加逗号可能会在旧版本浏览器，如ie7等中导致错误。 //数值属性值会自动转换为字符串。&#125;；var person = &#123;&#125;；person.name = "xiangming";person.age = 29; // 这两个例子是等价的。 这里的左花括号表示对象字面量的开始，if（）{}这里的则表示一个语句块的开始。因此也解释了函数作用域的一个疑问，即在在if后面的{}定义的局部变量为什么在外部仍可以访问到，也因此if后的{}不是一个执行环境。 访问对象属性一般都是用点表示法，在js中也可以用方括号表示法。在使用方括号时要将访问的属性以字符串的形式放在方括号里。例： 12alert(person["name"]); //xiaomingalert(person.name); 方括号方法的优点是可以通过访问变量来访问属性，例： 12var propertyName = "name";alert(personn[propertyName]); 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字保留字，有些不能用点表示法来访问，可以使用方括号表示法。 for…in 循环for…in循环用来遍历一个对象的全部属性。 for…in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。它不仅遍历对象自身的属性，还遍历继承的属性。举例来说，对象都继承了toString属性，但是for…in循环不会遍历到这个属性。 123456var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for…in循环遍历到，因为它默认是“不可遍历”的。 如果继承的属性是可遍历的，那么就会被for…in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for…in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 1234567var person = &#123; name: &apos;老张&apos; &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name 5.2 Array 类型数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。任何类型的数据，都可以放入数组。 如果数组的元素还是数组，就形成了多维数组。 123var a = [[1, 2], [3, 4]];a[0][1] // 2a[1][1] // 4 本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。 数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。通过数字索引可以增加和替换数据项。 12345var arr = ['a', 'b', 'c'];alert(arr.toString());Object.keys(arr)// ["0", "1", "2"]alert = (arr.length); //3 arr[5] = `e`;//arr = ['a', 'b', 'c',,,e];第四项和第五项为undefined。 上面代码中，Object.keys方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。 JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。 创建数组的方式也有两种：第一种使用Array构造函数，如下： 12var colors = new Array();//new操作符可省略 1234var colors = new Array(20);//length值为20的数组 var colors = new Array("Greg");//如果传递的是非数值类型的参数，会创建包含那个值的数组。 第二种方法使用字面量表示法 12var colors = ["red","blue",]// 创建两项或三项的数组（不同的版本的浏览器解解析有bug）第三项是undefined，所小心逗号 length 属性数组的length属性，返回数组的成员数量。 1['a', 'b', 'c'].length // 3 JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说length属性的最大值就是 4294967295。 只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1。 12345var a = [];a['p'] = 'abc';a.length // 0a[2.1] = 'abc';a.length // 0 上面代码将数组的键分别设为字符串和小数，结果都不影响length属性。因为，length属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以length属性保持为0。 5.2.1 检测数组参考3.4.1typeof 操作符。 确定某个对象是不是数组 123if (value instanceof Array)&#123; //对数组执行某些操作&#125; instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页包含多个框架，实际上就是存在多个不同的全局执行环境，从而存在多个不同版本的Array构造函数。如果一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架原生创建的的数组分别具有各自不同的构造函数。 为结决这个问题，ES5新增了Array.isArray()方法， 123if (Array.isArray(value))&#123; //对数组执行某些操作&#125; 5.2.2 转换方法所有的对象都具有toLocaleString()、toString()和valueOf()方法。其中调用valueOf()返回的还是数组本身，而调用数组的toLocaleString()方法会返回数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。 跳出数组的视角来看这几个定义，其实要分清这几个性价比实在不高，先放着： valueOf() 方法返回一个String对象的原始值（primitive value）。 String 全局对象是一个用于字符串或一个字符序列的构造函数。String 对象用于处理文本（字符串）。 toString() 方法返回一个表示该对象的字符串。 toString()与String()的区别就在于String()还能转换null和undefined值，可以说是toString()的增强版。 toLocaleString() 方法返回一个该对象的字符串表示。此方法被用于派生对象为了特定语言环境的目的（locale-specific purposes）而重载使用。 什么是对象，尴尬，有说js里所有的事物都是对象：字符串、数值、数组、函数… 此外，JavaScript 允许自定义对象。 所有事物都是对象JavaScript 提供多个内建对象。（心里mmp） String()方法在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。String()函数遵循下列转换规则： 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果；如果值是null，则返回”null”；如果值是undefined，则返回”undefined”。参靠3.4.5-5 123var arr = ['a', 'b', 'c'];alert(arr.toString());//a,b,calert(arr.valueOf())//["a", "b", "c"] 另外，toLocalString()方法经常也会返回与toString()和valueOf()方法相同的值，但也不总是如此。当调用数组的toLocaleString()方法时，它也会创建一个数组的以逗号分割的字符串。而与前两个方法唯一的不同指出在于，这因此i是为了取得每一项的值，调用的是每一项的toLocaleString()方法，而不是toString()方法。请看下面这个例子： 1234567891011121314151617181920var person1 = &#123; toLocaleString: function () &#123; return "Nikolaos"; &#125;, toString: function () &#123; return "小明"; &#125;&#125;var person2 = &#123; toLocaleString: function () &#123; return "Grigorios"; &#125;, toString: function () &#123; return "Greg"; &#125;&#125;;var people = [person1, person2];alert(people); //小明,Gregalert(people.toString()); //小明,Gregalert(people.toLocaleString()); //Nikolaos,Grigorios join() 方法只接收一个参数，即用作分隔符的字符串。 1234var colors =['red','green','blue'];alert(colors);//red,green,bluealert(colors.join(',')); //red,green,bluealert(colors.join('||')); //red||green||blue 5.2.3 栈方法ES数组也提供了一种让数组行为类似于其他数据结构的方法。 栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构。只在栈的顶部增添和移除。 push（）方法可以接收任意数量的参数，把它们逐个添加到数组的末尾，返回修改后的数组的长度。 pop（）方法从数组末尾移除最后一项，减少数组的length的值，返回移除的项。 123456var colors = Array();var count = colors.push('red','green');alert(count);//2alert(colors);// red,greenvar item = colors.pop();alert(item); // green 5.2.4 队列方法队列FIFO（先进先出）。在末端添加项，前端移除项。 shift 移除数组第一个项，并返回该项。 unshift在数组前端添加任意个项，返回数组新长度。 12345var colors = ['red','green'];alert(colors.shift()); //redvar item = colors.unshift('yellow','blue');alert(item); //4alert(colors);//yellow,blue,red,green 5.2.5 重排序方法reverse()方法会反转数组项的顺序。（仅仅是翻转而已，并不按大小） sort()方法按升序排列数组项。（比较字符串大小，不是数值大小） 为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以 确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 默认这个返回值，是按升序排列的，把1改为返回一个大于0的值，3返回一个小于0的值，就可按降序排列。 如下所示。 123var values = [0, 1, 5, 10, 15];values.sort();alert(values); //0,1,10,15,5 以下就是一个简单的比较函数： 123456789101112function compare(value1, value2) &#123;if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); //0,1,5,10,15 对于数值类型或者valueOf（）方法会返回数值类型的对象类型，可用一个更简单的比较函数。 123456function compare(value1, value2) &#123; return value2 - value1&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);//降序 当value2-value1降序，value1-value2升序，而sort默认升序，显然是用1-2.//这里修改了原数组 5.2.6 操作方法concat()concat() 方法用于连接两个或多个数组。 该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 语法 1arrayObject.concat(arrayX,arrayX,......,arrayX) arrayX 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个，如果没有参数那么仅是复制了原函数。 如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。 12var a = [1,2,3];document.write(a.concat(4,5));//1,2,3,4,5 push()和concat()方法都可以将传的参数添加到数组的后面，只不过push()是在原数组上操作（改变的是原数组），concat()不会改变原数组，创建原数组的副本，并且把传的参数添加到新数组后面。 push()传递的参数是数组时，将整个数组传给原数组末尾，如示例中得到的结果[“a”, “b”, Array[2], Array[3]] 1234var arr = ['a','b'];console.log(arr); // ["a", "b"]arr.push(['c','d'],[1,2,3]);console.log(arr); // ["a", "b", Array[2], Array[3]] slice()slice()方法它也能基于当前数组创建一个新数组，而且对原数组也并不会有任何影响。slice()接受一个或两个参数，即要返回项的起始和结束位置（但不包括结束位置的项）。当只给slice()传递一个参数时，该方法返回从该参数指定位置开始到当前数组末尾的所有项。如下面示例： 当传递的参数是负值,用数组长度加上该负值。结束位置小于或等于开始位置，将返回一个空数组。 slice()方法和concat()方法类似，会在原数组上构建一个新数组，并不会影响原数组。 参考自，w3cplus。 splice()可删除、插入、替换。splice()方法还会影响原数组 在splice()方法中指定两个参数，第一个参数是指定开始删除数组项位置，第二个数是指删除数组项的个数。 splice(0,2)会删除数组中前两项。 指定三个参数，第一个参数为插入的起始位置，第二个参数为0(要删除的数组项数量，因为删除数量是为0，所以不做删除)，第三个参数是要插入的数组项。（数组项可任意多） 123456789101112var colors = ['red','green','blue'];var removed = colors.splice(0,1);alert(colors); //green,bluealert(removed);//redremoved = colors.splice(1,0,'yellow','orange');alert(colors);//grenn,yellow,orange,bluealert(removed);返回一个空数组，因为删除项为0；removed = colors.splice(1,1,'red','purple');alert(colors);//grenn,red,purple,orange,bluealert(removed); 5.2.7 位置方法ES5为数组实例添加了两个位置方法：indexOf()和lastIndexi().这两个方法都可以接收两个参数：要查找的项和（可选）表示查找位置起点的索引。indexOf()从数组的开头（位置0）开始，lastIndexi()从数组的末尾开始。 12var colors = ['red','green','blue'];alert(colors.indexOf('green'));// 1 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1.在比较查找的第一项与数组中的每一项时，要使用全等操作符，要严格相等。 5.2.8 迭代方法五个迭代方法 都接受两个参数：要在每一项上运行的函数 和 运行该函数的作用域（可选）。传入这些方法中的函数会接收三个参数：数组项的值，该项在数组中的位置和数组对象本身。 ES5为数组定义了五个迭代方法： forEach()：对数组中每一项运行给定函数。该函数没有返回值。 every(): 对数组中的每一项运行给定函数。如果函数对每一项都返回 true，则返回 true。 some(): 对数组中每一项运行给定函数。如果函数对 任一项返回 true，则返回 true filter(): 对数组中的每一项运行给定函数。返回该函数会返回 true 的项组成的数组。 map(): 对数组中每一项运行给定函数。返回每次函数调用的结果组成的数组。 1234567891011121314151617181920212223242526var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; // item:当前遍历项，index:当前项索引，array:数组对象本身 var everyResult = numbers.every(function (item, index, array) &#123; return item &gt; 2; &#125;); alert(everyResult);//false var someResult = numbers.some(function (item, index, array) &#123; return item &gt; 2; &#125;); alert(someResult);//true var filterResult = numbers.filter(function (item, index, array) &#123; return item &gt; 2; &#125;); alert(filterResult);//[3,4,5,4,3] var mapResult = numbers.map(function (item, index, array) &#123; return item * 2; &#125;); alert(mapResult);//[2,4,6,8,10,8,6,4,2] //forEach 本质上和for循环没有区别 var forEachResult=numbers.forEach(function(item,index,array)&#123; //执行某些操作 比如 alert(item) &#125;); 5.2.9 归并算法ECMAScript 5 新增两个归并数组的方法：reduce() 和 reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。使用reduce()还是reduceRight()，主要取决于要从哪头开始遍历，除此之外，它们完全相同。前者从数组的第一项开始，后者从从最后一项开始 。reduce()方法接受两个参数 ：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。 我们先说一说第一个参数。这个参数（函数）接收 4 个参数：前一个值，当前值，项的索引和数组对象。 来个例子🌰： 12345678910// 使用 reduce() 方法可以执行求数组里所有值之和的操作var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array) &#123; console.log(prev); // 共执行四次，依次输出 1， 3， 6， 10 console.log(cur); // 共执行四次，依次输出 2， 3， 4， 5 console.log(index); // 共执行四次，依次输出 1, 2, 3, 4 console.log(array); // 共执行四次，每次都输出原数组 [1,2,3,4,5] return prev + cur;&#125;)console.log(sum); // 15 第一次执行回调函数，prev 是 1（数组的第一项） ，cur 是 2（数组的第二项），index 是 1（注意并没从 0 开始）。第二次，prev 是 3 （1 加 2 的结果），cur 是 3 （数组的第三项），index 是 2。 这个过程会持续到把数组中的每一项都访问一遍，最后返回结果（一共执行四次，得到 1 + 2 + 3 + 4 + 5 = 15）。 5.3 Date 类型静态方法（Date.方法()而不是通过变量名.方法）Date对象是 JavaScript 原生的时间库。它以1970年1月1日00:00:00(UTC)作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。 要创建一个日期对象，使用new操作符和Date构造函数即可，如下 12345var now = new Date();now; //Mon May 14 2018 08:28:34 GMT+0800 (中国标准时间)var now = new Date(100000);now;// Thu Jan 01 1970 08:01:40 GMT+0800 (中国标准时间) 在调用构造函数而不传递参数的情况下，新创建的对象自动获取当前时间,如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数(即从UTC时间1970年一月一日午夜起至该日期经过的毫秒数)。 为了简化这一过程，ES提供了两个方法：Date.parse()和Date.UTC() 1. Date.parse()Date.parse()方法接收一个表示日期的字符串数，然后返回相应的毫秒数，如果接收的字符串不能被解析，则返回NaN，但是由于浏览器不同，不一定返回NaN。 日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区。但是，其他格式也可以被解析。 由于 parse() 是 Date 的一个静态方法 , 所以应该使用Date.parse() 来调用，而不是作为 Date 的实例方法。 1234var now = new Date(Date.parse('2014-03-07')); //Fri Mar 07 2014 08:00:00 GMT+0800 (中国标准时间)var now = new Date(Date.parse('2014-03-07'));与 var now = new Date('2014-03-07');now;是等价的。Date构造函数会在后台调用Date.parse()。 2. Date.UTC()接受和构造函数最长形式的参数相同的参数（从2到7），并返回从 1970-01-01 00:00:00 UTC 开始所经过的毫秒数。 参数分别为年份、月份（0-11）、日（1-31）、小时（0-23）、分钟、秒以及毫秒数。前两个参数必须，月，默认天数1，其它默认为0 。 3. Date.now()Date.now() 方法返回自1970年1月1日 00:00:00 UTC到当前时间的毫秒数。 因为 now() 是Date的一个静态函数，所以必须以 Date.now() 的形式来使用。 总： 1234new Date();new Date(value);new Date(dateString);new Date(year, month [, day [, hours [, minutes [, seconds [, milliseconds]]]]]); 实例方法Date的实例对象，有几十个自己的方法，除了valueOf和toString，可以分为以下三类。 to类：从Date对象返回一个字符串，表示指定的时间。get类：获取Date对象的日期和时间。set类：设置Date对象的日期和时间。 valueOf方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法和Date.now()。 方法 描述 Date() 返回当日的日期和时间。 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getFullYear() 从 Date 对象以四位数字返回年份。 getYear() 请使用 getFullYear() 方法代替。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。 getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。 getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。 getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。 getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。 getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。 parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。 setMonth() 设置 Date 对象中月份 (0 ~ 11)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setYear() 请使用 setFullYear() 方法代替。 setHours() 设置 Date 对象中的小时 (0 ~ 23)。 setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setTime() 以毫秒设置 Date 对象。 setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。 setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。 setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。 setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。 setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。 setUTCSeconds() 根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。 setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。 toSource() 返回该对象的源代码。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toDateString() 把 Date 对象的日期部分转换为字符串。 toGMTString() 请使用 toUTCString() 方法代替。 toUTCString() 根据世界时，把 Date 对象转换为字符串。 toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串。 toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 UTC() 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 valueOf() 返回 Date 对象的原始值。 set: 12345var d = new Date ('January 6, 2013');d // Sun Jan 06 2013 00:00:00 GMT+0800 (CST)d.setDate(9) // 1357660800000 返回的是毫秒数d // Wed Jan 09 2013 00:00:00 GMT+0800 (CST) 返回设置后的日期显示 to: 12var d = new Date(); d.toUTCString() //"Mon, 14 May 2018 02:05:17 GMT" get: 12var d = new Date()d.getDate()//14 当前日期（5.14） GMT与UTC两个时区 5.4 RegEXp 类型字面量知识点补充参考链接 字面量是由语法表达式定义的常量；或，通过由一定字词组成的语词表达式定义的常量。 数组字面量(Array literals) 布尔字面量(Boolean literals) 浮点数字面量(Floating-point literals) 整数(Intergers) 对象字面量(Object literals) RegExp literals 字符串字面量(String literals) 数组字面值是一个封闭在方括号对([])中的包含有零个或多个表达式的列表，其中每个表达式代表数组的一个元素。 1var a=[3]; 布尔类型有两种字面量：true和false。 整数和浮点数他们数值本身就是其字面量。 对象字面值是封闭在花括号对({})中的一个对象的零个或多个”属性名-值”对的（元素）列表。 一个正则表达式是字符被斜线（译注：正斜杠“/”）围成的表达式。 。 1var re = /ab+c/; 字符串字面量是由双引号（”）对或单引号（’）括起来的零个或多个字符 ​ 补充完毕 使用下面类似Perl的语法，就可以创建一个正则表达式。 1var expression = / pattern/flags; 其中模式部分是正则表达式，每一个正则表达式都可带有一个或多个标志（flags），用以表明正则表达式的行为。 如果指定，标志可以具有以下值的任意组合： g 全局搜索。也就是匹配目标字符串中所有可能的匹配项，而不是只进行第一次匹配。 i 不区分大小写搜索。 m 多行搜索。 y 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。 u Unicode; 将模式视为Unicode序列点的序列 RegExp 构造函数创建了一个正则表达式对象，用于将文本与一个模式匹配。 新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。 1var regex = /xyz/; 另一种是使用RegExp构造函数。 1var regex = new RegExp('xyz'); 123var regex = new RegExp('xyz', 'i');// 等价于var regex = /xyz/i; 两种方法的不同之处在于：字面量，在加载脚本后，正则表达式字面值提供正则表达式的编译（又引擎编译）。当正则表达式保持不变时，使用此方法可获得更好的性能。 使用构造函数提供正则表达式的运行时编译。使用构造函数，当你知道正则表达式模式将会改变，或者你不知道模式，并从另一个来源，如用户输入。 方括号方括号用于查找某个范围内的字符： 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 [^adgk] 查找给定集合外的任何字符。 `(red\ blue\ green)` 查找任何指定的选项。 元字符元字符（Metacharacter）是拥有特殊含义的字符： 元字符 描述 . 查找单个字符，除了换行和行结束符。 \w 查找单词字符。 \W 查找非单词字符。 \d 查找数字。 \D 查找非数字字符。 \s 查找空白字符。 \S 查找非空白字符。 \b 匹配单词边界。 \B 匹配非单词边界。 \0 查找 NUL 字符。 \n 查找换行符。 \f 查找换页符。 \r 查找回车符。 \t 查找制表符。 \v 查找垂直制表符。 \xxx 查找以八进制数 xxx 规定的字符。 \xdd 查找以十六进制数 dd 规定的字符。 \uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。 n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 初步熟悉正则 5.4.1 RegExp 实例属性 ignoreCase：返回一个布尔值，表示是否设置了i标志。 global：返回一个布尔值，表示是否设置了g标志。 RegExp.prototype.multiline：返回一个布尔值，表示是否设置了m标志。以上三个属性仅为修饰。 lastIndex：返回一个数值，表示下一次开始搜索的位置，起始为0，该属性可读写。 source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。 然而并没多大用处，因为这些信息全部包含在模式声明中， 1234567var r = /abc/igm;r.ignoreCase // truer.global // truer.multiline // truer.lastIndex // 0r.source // "abc" 5.4.2 实例方法exec（）该方法是专为捕获数组而设立的。exec()接受一个参数，即要应用模式的字符串，然后返回第一个包含匹配项信息的数组，如果没有找到匹配，则返回 null。返回的数组虽然是Array实例。但包含两个额外属性：index和input。其中index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串，在数组中，第一项是整个模式匹配的字符串，其他项是与模式中的捕获匹配的字符串（如果没有捕获组，则该数组只包含一项）。 12345678910var text = "mom and dad and baby";var pattern = /mom( and dad( and baby)?)?/gi; var matches = pattern.exec(text);matches；//["mom and dad and baby", " and dad and baby", " and baby", index: 0, input: "mom and dad and baby", groups: undefined]alert(matches.index); //0alert(matches.input); //"mom and dad and baby"alert(matches[0]); //"mom and dad and baby"alert(matches[1]); //" and dad and baby"alert(matches[2]); //" and baby" 需要注意的是，使用 exec() 方法，即使在正则表达式中设置了全局模式（g 标志），它也只会返回字符串中的第一个匹配项。区别在于，不设置全局模式的情况下，在同一个字符串上调用多次 exec() 将始终返回第一个匹配项的信息。而设置了全局模式后，在同一个字符串上调用多次 exec() 方法将会在之前查找完的位置继续向下查找新的匹配项。例如： 1234567891011121314151617181920212223242526var text = "cat, bat, sat, fat"; var pattern1 = /.at/; //'.'匹配除换行符之外的任何单个字符。 var matches = pattern1.exec(text); matches; //["cat", index: 0, input: "cat, bat, sat, fat", groups: undefined]alert(matches.index); //0alert(matches[0]); //catalert(pattern1.lastIndex); //0 matches = pattern1.exec(text); alert(matches.index); //0alert(matches[0]); //catalert(pattern1.lastIndex); //0 var pattern2 = /.at/g; var matches = pattern2.exec(text); alert(matches.index); //0alert(matches[0]); //catalert(pattern2.lastIndex); //0 matches = pattern2.exec(text); alert(matches.index);//5 "cat, ",bat在字符串的起始位index是6，而输出是5，所以index输出的应是匹配项起始位的前一位，而依次规则第一位的index应该是-1，实际是0，依次此规则对于第一位不适合。alert(matches[0]); //batalert(pattern2.lastIndex); //8 test()它接受一个字符串参数，在模式与该参数匹配的情况下返回true；否则返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容时，使用这个非常方便，因此test方法经常被用在if语句中， 123456var text = "000-00-0000"; var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/; if (pattern.test(text))&#123; alert("The pattern was matched.");&#125; 支持正则表达式的 String 对象的方法方法 描述search 检索与正则表达式相匹配的值。match 找到一个或多个正则表达式的匹配。replace 替换与正则表达式匹配的子串。split 把字符串分割为字符串数组。 5.4.3 RegExp 构造函数属性 input (简写为$_) 最近一次要匹配的字符串。 lastMatch(简写$&amp;) 最近一次的匹配项 lastParen(简写$+) 最近一次匹配的捕获组。 leftContext(简写$`) input字符串中lastMatch之前的文本 rightContext(简写$’) input字符串中lastMatch之后的文本 multiline(简写$*) 布尔值，表示是否所有表达式都使用多行模式。 12345678910var text ="you are in haorooms 博客，看文章呢";var pattern =/(.)aorooms/g;if(pattern.test(text))&#123; console.log(RegExp.$_); //you are in haorooms 博客，看文章呢 console.log(RegExp["$`"]);//you are in console.log(RegExp["$'"]);//博客，看文章呢 console.log(RegExp["$&amp;"]);//haorooms console.log(RegExp["$+"]);//h console.log(RegExp["$*"]);//false&#125; 除了上面几个属性之外还有 （RegExp.$1,RegExp.$2,RegExp.$3,RegExp.$4,RegExp.$5,RegExp.$6,RegExp.$7,RegExp.$8,RegExp.$9）,一共有9个。用来存储匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。其实，说简单的，就是可以获得（）括号内匹配的字符串。 1234567var text ="you are in haorooms 博客，看文章呢";var pattern =/(.)ao(..)om(.)/g;if(pattern.test(text))&#123; console.log(RegExp.$1);//h console.log(RegExp.$2);//ro console.log(RegExp.$3);//s &#125; 5.5 Function 类型Function（函数）类型实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具备属性和方法，由于函数是对象，因此函数名实际上也是一个指向函数对象的指针。参考4.1章节。没有函数重载的概念。 函数定义： 通过函数声明 123function sum (num1 ,numb2)&#123; return num1 + num2;&#125; 通过函数表达式 123var sum = function (num1 ,numb2)&#123; return num1 + num2;&#125;; 两者区别有两点： 解析器在向执行环境中加载数据时，解析器会先读取函数声明，并使其在执行任何代码之前可用（可以访问）；对于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。函数提升，参考3.3.1变量提升。例： 1234567891011121314151617181920212223函数声明alert (sum (10,10));function sum (num1,numb2)&#123; return num1 + num2;&#125;;//等同于function sum (num1,numb2)&#123; return num1 + num2;&#125;;alert (sum (10,10));函数表达式alert (sum (10,10));var sum = function (num1 ,numb2)&#123; return num1 + num2;&#125;;等同于var sum ;alert (sum (10,10));var sum = function (num1 ,numb2)&#123; return num1 + num2;&#125;; js引擎会把函数声明提升到顶部。而对于通过函数表达式定义的函数则会抛出错误。 通过函数表达式定义的函数，形式看起来好像常规的变量赋值语句，即创建一个函数并将他赋值给变量functionName。这种情况下创建的函数叫匿名函数。因为function关键字后面没有标识符，匿名函数的name属性是空字符串，也就是没有。 1234567891011121314151617181920 var sayHello; console.log(typeof (sayHey));//=&gt;function console.log(typeof (sayHo));//=&gt;undefined if (true) &#123; function sayHey() &#123; console.log("sayHey"); &#125; sayHello = function sayHo() &#123; console.log("sayHello"); &#125; &#125; else &#123; function sayHey() &#123; console.log("sayHey2"); &#125; sayHello = function sayHo() &#123; console.log("sayHello2"); &#125; &#125; sayHey();// =&gt; sayHey2 //2019 5 23测，谷歌和火狐都返回sayHey，360极速返回sayHey2sayHello();// =&gt; sayHello 分析：sayHey是用函数声明创建的，在JS解析时JS编译器将函数定义进行了函数提升，也就是说，在解析JS代码的时候，JS编译器（条件判断不形成新的作用域，两个sayHey函数定义都被提升到条件判断之外）检测到作用域内有两个同名的sayHey定义，第一个定义先被提升，第二个定义接着被提升（第二个定义在第一个定义之下），第二个定义覆盖了第一个sayHey定义，所以sayHey（）输出sayHey2；而sayHello是用函数表达式创建的，其表达式的内容是在JS运行时（不是解析时）才能确定（这里条件判断就起到作用了），所以sayHello表达式执行了第一个函数定义并赋值，则sayHello（）输出sayHello。 5.5.1 作为值的函数因为ECMAScriopt中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不久可以像传递参数一样把一个函数传递个另一个函数，而且可以将一个函数作为另一个函数的结果返回。 1234567891011121314151617function callSomeFunction(someFunction, someArgument) &#123; return someFunction(someArgument);&#125;function ad10(num) &#123; return num + 10;&#125;var result1 =callSomeFunction(add10,10);alert(result1); //20function getGreeting(name) &#123; return "Hello, " + name;&#125;var result2 = callSomeFunction(getGreeting, "Icey");alert(result2); //"Hello Icey" 要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。 从函数中返回另一个函数的应用： 12345678910111213function createComparisonFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 按照某个对象的属性进行排序。 123456var data = [&#123;name:"Icey", age:25&#125;, &#123;name:"Root", age:24&#125;];data.sort(createComparisonFunction("name"));alert(data[0].name); //"Icey"data.sort(createComparisonFunction("age"));alert(data[0].name); //"Root" sort()方法参考。5.2.5重排序方法。 5.5.2 函数内部属性(arguments和this)在函数内部，有两个特殊的对象：arguments和this。其中，arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。请看下面这个非常经典的阶乘函数。 1234567function factorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * factorial(num-1); &#125;&#125; 定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。 1234567function factorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * arguments.callee(num-1); &#125;&#125; 在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如： 1234567var trueFactorial = factorial;factorial = function()&#123; return 0;&#125;; alert(trueFactorial(5)); //120alert(factorial(5)); //0 在此，变量trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回0的函数赋值给factorial变量。如果像原来的factorial()那样不使用arguments.callee，调用trueFactorial()就会返回0。可是，在解除了函数体内的代码与函数名的耦合状态之后，trueFactorial()仍然能够正常地计算阶乘，至于factorial()，它现在只是一个返回0的函数。函数内部的另一个特殊对象是this，其行为与java和C#中的this大致类似。换句话说，this引用的是函数执行的环境对象——或者也可以说是this值(当在网页的全局作用域中调用函数时，this对象引用的就是window)。来看下面的例子。 在闭包中使用this对象也可能会导致一些问题。this的对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的的方法调用时，this等于那个对象。7.2章闭包。 12345678910window.color = "red";var o = &#123;color : "blue"&#125;; function sayColor()&#123; alert(this.color);&#125;sayColor(); // redo.sayColor = sayColor; o.sayColor(); // blue 上面这个函数sayColor()是在全局作用域中定义的，this对象引用了window对象。由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。当在全局作用域中调用sayColor()时，this引用的是全局对象window，换句话说，对this.color求值会转换成对window.color求值，于是结果就返回了”red”。而当把这个函数赋给对象o并调用o.sayColor()时，this引用的是对象o，因此对this.color求值会转换成对o.color求值，结果就返回了”blue”。 请读者一定要牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的sayColor()函数与o.sayColor()指向的仍然是同一个函数。 5.5.3 函数属性和方法每个函数都包含两个属性：length 和 prototype length:当前函数希望接受的命名参数的个数 prototype：是保存他们所有实例方法的真正所在 1234567891011121314function sayName(name) &#123; alert(name); &#125; function sum(num1, num2) &#123; return num1 + num2; &#125; function sayHi() &#123; alert("hi"); &#125; alert(sayName.length);//1 参数个数一个 alert(sum.length);//2 参数个数2个 alert(sayHi.length);//0 没有参数 每个函数都包含两个非继承而来的方法：apply() 和 call() 这两个方法都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。（通俗的说就是在一个函数里通过这两个方法引用另一个函数） 首先 apply() 接受两个参数：一个是函数运行的作用域，另一个参数数组（可以是数组实例也可以是 arguments 对象） 1234567891011121314151617181920212223function sum(num1, num2) &#123; return num1 + num2; &#125; function callSum1(num1, num2) &#123; return sum.apply(this, arguments);//传入arguments对象 &#125; function callSum2(num1, num2) &#123; return sum.apply(this, [num1, num2]); &#125; alert(callSum1(10, 10));//20 alert(callSum2(10, 10));//20 如果没有运用applyfunction callSum1(num1, num2) &#123; return sum;//传入arguments对象 &#125; alert(callSum1(10, 10));// function sum(num1, num2) &#123; return num1 + num2; &#125; 其次，call 方法第一个参数没有变化，变化的是其余的参数都是传递参数，传递给函数的参数需要逐个列举出来 12345678function sum(num1, num2) &#123; return num1 + num2; &#125; function callSum(num1, num2) &#123; return sum.call(this, num1, num2); &#125; alert(callSum(10, 10)); //20 至于使用哪个方法更方便，完全取决于你的意愿。如果没有参数，用哪个都一样。 为了更好地理解，再举个栗子： 12345678910111213141516171819这个函数可能有点难理解或者小错误，引入这个例子主要为了立即这两个方法function animal(name,food) &#123; this.name = name, this.food = food, this.say = function() &#123; console.log(name +&quot; likes &quot; + this.food + &apos;.&apos;); &#125;&#125;function rabbit(name,food) &#123; animal.call(this,name,food);&#125;var Judy = new rabbit(&apos;Judy&apos;,&apos;carrot&apos;);Judy.say();// &gt;&gt;&gt; Judy likes carrot.可以看出，我们声明了一个叫Judy的对象，我们并没有在rabbit对象里添加任何属性和方法，但是我们使用call()继承了原本属于animal的属性和方法。就可以做到animal函数所有能做到的事情。本例引用链接：https://segmentfault.com/a/1190000004581945 但是，apply 和 call 方法的出现绝对不是只是为了怎样去传递参数。 它们真正的用武之地在于扩充函数赖以运行的作用域。 123456789101112window.color = "red"; var o = &#123;color: "blue"&#125;; function sayColor() &#123; alert(this.color); &#125; sayColor();//red sayColor.call(this);//red sayColor.call(window);//red ayColor.call(o);//blue 使用 apply 和 call 来扩充作用域的最大的好处就是不需要与方法有任何的耦合关系。 ECMAScript5 还定义了一个方法：bind()。这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind 函数的值 12345678910window.color = "red";var o = &#123;color: "blue"&#125;; function sayColor() &#123; alert(this.color); &#125; var bindFun = sayColor.bind(o); bindFun();//blue 5.6 基本包装类型为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型：Boolean、Number 和String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值得时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。如下例子： 12var s1="some text"; var s2=s1.substring(2); 这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值，而下一行代码调用了 s1的 substring() 方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要·从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。 创建 String 类型的一个实例； 在实例上调用指定的方法； 销毁这个实例 123var s1 = new String('test'); var s2 = s1.substring(2);s1 = null; 上面三个步骤也分别使用于Boolean和Number类型对应的布尔值和数字值。 引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能再运行时为基本类型值添加属性和方法。如下面例子： 123var s1="some text" s1.color="red"; alert(s1.color);//undefined 当然，可以显示的地调用 Boolean、Number 和 String 来创建基本包装类型的对象。不过，应该在绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本包装类型还是引用基本包装类型的值。对基本包装类型的实例调用 typeof 会返回 “object”，而且所有基本包装类型的对象都会被转换为布尔值 true。 Object 构造函数也会像工厂方法一样，根据传入值得类型返回相应基本包装类型的实例。例如： 12var obj=new Object("some text"); alert(obj instanceof String);//true 把字符串传给 Object 构造函数，就会创建 String 的实例；而传入数值参数会得到Number 的实例，传入布尔值参数就会得到 Boolean 的实例。 要注意的是，使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。例如： 12345var value="25"; var number=Number(value); //转型函数 alert(typeof number); //"number" var obj=new Number(value); //构造函数 alert(typeof obj); //"object" 在这个例子中，变量 number 中保存的是基本类型的值 25，而变量 obj 中保存的是Number 的实例。 5.6.1,5.6.2,5.6.3这三小节，请参考位W3c。ECMAScript 引用类型 5.6.1 Boolean 类型Boolean 对象将覆盖 Object 对象的 ValueOf() 方法，返回原始值，即 true 和 false。ToString() 方法也会被覆盖，返回字符串 “true” 或 “false” 5.6.2 Number 类型Number是与数字对应的引用类型。要创建Number对象，可以在调用Number构造函数时，向其中传递相应的数值。例： 1var numberObject = new Number (10); 与Boolean类型一样，Number类型也重写了valueOf(),toLocaleString()和toString()方法。重写后valueOf()返回对象表示的基本类型的值。另外两个方法返回字符串形式的数值。 补充：toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式，例： 123var num =10;alert(num.toString());//'10'alert(num.toString(2))//'1010' toFixed() 方法toFixed() 方法返回的是具有指定位数小数的数字的字符串表示。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toFixed(2)); //输出 "68.00" 在这里，toFixed() 方法的参数是 2，说明应该显示两位小数。该方法返回 “68.00”，空的字符串位由 0 来补充。对于处理货币的应用程序，该方法非常有用。toFixed() 方法能表示具有 0 到 20 位小数的数字，超过这个范围的值会引发错误。 toExponential() 方法与格式化数字相关的另一个方法是 toExponential()，它返回的是用科学计数法表示的数字的字符串形式。 与 toFixed() 方法相似，toExponential() 方法也有一个参数，指定要输出的小数的位数。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toExponential(1)); //输出 "6.8e+1" 这段代码的结果是 “6.8e+1”，前面解释过，它表示 6.8x101。问题是，如果不知道要用哪种形式（预定形式或指数形式）表示数字怎么办？可以用 toPrecision() 方法。 toPrecision() 方法toPrecision() 方法根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。例如， 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(1)); //输出 "7e+1" 这段代码的任务是用一位数字表示数字 68，结果为 “7e+1”，以另外的形式表示即 70。的确，toPrecision() 方法会对数进行舍入。不过，如果用 2 位数字表示 68，就容易多了： 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(2)); //输出 "68" 当然，输出的是 “68”，因为这正是该数的准确表示。不过，如果指定的位数多于需要的位数又如何呢？ 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(3)); //输出 "68.0" 在这种情况下，toPrecision(3) 等价于 toFixed(1)，输出的是 “68.0”。 toFixed()、toExponential() 和 toPrecision() 方法都会进行舍入操作，以便用正确的小数位数正确地表示一个数 5.6.3 String 类型String 类型是字符串的对象包装类型。创建如下： 1var oStringObject = new String("hello world"); String 对象的 valueOf() 方法和 toString() 方法都会返回 String 类型的原始值。 length 属性 String 对象具有属性 length，它是字符串中的字符个数： 12var oStringObject = new String("hello world");alert(oStringObject.length); //输出 "11" 1.字符方法两个方法 charAt() 和 charCodeAt() 访问的是字符串中的单个字符。这两个方法都有一个参数，即要操作的字符的位置。 charAt() 方法返回的是包含指定位置处的字符的字符串： 12var oStringObject = new String("hello world");alert(oStringObject.charAt(1)); //输出 "e" 如果想得到的不是字符，而是字符代码，那么可以调用 charCodeAt() 方法： 12var oStringObject = new String("hello world");alert(oStringObject.charCodeAt(1)); //输出 "101" 2.字符串操作方法参考javascript中字符串常用操作总结 concat() 方法 用于把一个或多个字符串连接到 String 对象的原始值上。 1234var oStringObject = new String("hello "); var sResult = oStringObject.concat("world"); alert(sResult); //输出 "hello world" alert(oStringObject); //输出 "hello " 较常见的是用加号（+）连接字符串 1234var oStringObject = new String(&quot;hello &quot;); var sResult = oStringObject + &quot;world&quot;; alert(sResult); //输出 &quot;hello world&quot; alert(oStringObject); //输出 &quot;hello &quot; substring()1stringObject.substring(start,end) substring()是最常用到的字符串截取方法，它可以接收两个参数(参数不能为负值)，分别是要截取的开始位置和结束位置，它将返回一个新的字符串，其内容是从start处到end-1处的所有字符。若结束参数(end)省略，则表示从start位置一直截取到最后。 1234var str = 'abcdefg';console.log(str.substring(1, 4)); //返回bcdconsole.log(str.substring(1)); //返回bcdefgconsole.log(str.substring(-1)); //返回abcdefg，传入负值时会视为0 slice()1stringObject.slice(start,end) slice()方法与substring()方法非常类似，它传入的两个参数也分别对应着开始位置和结束位置。而区别在于，slice()中的参数可以为负值，如果参数是负数，则将负值与字符串长度相加。 12345var str = 'abcdefg';console.log(str.slice(1, 4)); //返回bcdconsole.log(str.slice(-3, -1)); //返回efconsole.log(str.slice(1, -1)); //返回bcdefconsole.log(str.slice(-1, -3)); //返回空字符串，若传入的参数有问题，则返回空 substr() stringObject.substr(start,length) substr()方法可在字符串中抽取从start下标开始的指定数目的字符。其返回值为一个字符串，包含从 stringObject的start（包括start所指的字符）处开始的length个字符。如果没有指定 length，那么返回的字符串包含从start到stringObject的结尾的字符。另外如果start为负数，第一个参数加上字符串的长度，第二个负值转换为0. 1234var str = 'abcdefg';console.log(str.substr(1, 3)) //返回bcdconsole.log(str.substr(2)) //返回cdefgconsole.log(str.substr(-2, 4)) //返回fg，目标长度较大的话，以实际截取的长度为准 3.字符串位置的方法indexOf()与lastIndexOf()参考5.2.7 位置方法。 在使用第二个参数的情况下，可以通过循环调用这两个方法来找到所有匹配的子字符串，例： 123456789var stringValue = 'lorem ipsum dolor sit amet, consectetur adipisicing elit ';var positions = new Array ();var pos = stringValue.index('e');while (pos &gt; -1)&#123; position.push (pos); pos = stringValue.index ('e', pos+1);&#125;alert (positions);//'3，24，32，35，52' 4.trim() 方法从字符串中移除前导空格、尾随空格和行终止符。 rim() 方法并不影响原字符串本身，它返回的是一个新的字符串。 1234 stringObj.trim()var orig = ' foo ';console.log(orig.trim()); // 'foo' 5.字符串大小写转换方法 toLowerCase() toLocaleLowerCase() toUpperCase() toLocaleUpperCase() 12var oStringObject = new String("Hello World");alert(oStringObject.toLocaleUpperCase()); //输出 "HELLO WORLD" 6.字符串的模式匹配方法match()12stringObject.match(substr)stringObject.match(regexp) match()方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 如果参数中传入的是子字符串或是没有进行全局匹配的正则表达式，那么match()方法会从开始位置执行一次匹配，如果没有匹配到结果，则返回null。否则则会返回一个数组，该数组的第0个元素存放的是匹配文本，除此之外，返回的数组还含有两个对象属性index和input，分别表示匹配文本的起始字符索引和stringObject 的引用(即原字符串)。 1234var str = '1a2b3c4d5e';console.log(str.match('h')); //返回nullconsole.log(str.match('b')); //返回["b", index: 3, input: "1a2b3c4d5e"]console.log(str.match(/b/)); //返回["b", index: 3, input: "1a2b3c4d5e"] 如果参数传入的是具有全局匹配的正则表达式，那么match()从开始位置进行多次匹配，直到最后。如果没有匹配到结果，则返回null。否则则会返回一个数组，数组中存放所有符合要求的子字符串，并且没有index和input属性。 123var str = '1a2b3c4d5e';console.log(str.match(/h/g)); //返回nullconsole.log(str.match(/\d/g)); //返回["1", "2", "3", "4", "5"] search ()stringObject.search(substr) stringObject.search(regexp) search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。它会返回第一个匹配的子字符串的起始位置，如果没有匹配的，则返回-1。 1234var str = 'abcDEF';console.log(str.search('c')); //返回2console.log(str.search('d')); //返回-1console.log(str.search(/d/i)); //返回3 replace()stringObject.replace(regexp/substr,replacement) replace()方法用来进行字符串替换操作，它可以接收两个参数，前者为被替换的子字符串（可以是正则），后者为用来替换的文本。 如果第一个参数传入的是子字符串或是没有进行全局匹配的正则表达式，那么replace()方法将只进行一次替换（即替换最前面的），返回经过一次替换后的结果字符串。 123var str = 'abcdeabcde';console.log(str.replace('a', 'A'));console.log(str.replace(/a/, 'A')); 如果第一个参数传入的全局匹配的正则表达式，那么replace()将会对符合条件的子字符串进行多次替换，最后返回经过多次替换的结果字符串。 123var str = 'abcdeabcdeABCDE';console.log(str.replace(/a/g, 'A')); //返回AbcdeAbcdeABCDEconsole.log(str.replace(/a/gi, '$返回')); //返回$bcde$bcde$BCDE replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。 字符 替换文本 $1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 直接量符号。 1234var str = 'www.denpe.com';var searchStr = 'denpe';var result = str.replace(searchStr, "$$ - $` - $&amp; - $'");console.log(result); // www.$ - www. - denpe - .com.com 从上面例子可看到 denpe 被替换成了 $ - www. - denpe - .com。 参数search 表示$ 匹配子串左边内容 匹配到的子串 匹配子串右边内容 变量名 $$ $` $&amp; $’ 代表的值 $ www. denpe .com JavaScript String.prototype.replace() 方法详解 split()stringObject.split(separator,howmany) split()方法用于把一个字符串分割成字符串数组。第一个参数separator表示分割位置(参考符)，第二个参数howmany表示返回数组的允许最大长度(一般情况下不设置)。 1234var str = 'a|b|c|d|e';console.log(str.split('|')); //返回["a", "b", "c", "d", "e"]console.log(str.split('|', 3)); //返回["a", "b", "c"]console.log(str.split('')); //返回["a", "|", "b", "|", "c", "|", "d", "|", "e"] 也可以用正则来进行分割 12var str = 'a1b2c3d4e';console.log(str.split(/\d/)); //返回["a", "b", "c", "d", "e"] 7.localeCompare()用本地特定的顺序来比较两个字符串。 1stringObject.localeCompare(target) 说明比较结果的数字。如果 stringObject 小于 target(字符串在字母表中的顺序排在字符串参数之前)，则 localeCompare() 返回小于 0 的数。如果 stringObject 大于 target，则该方法返回大于 0 的数。如果两个字符串相等，或根据本地排序规则没有区别，该方法返回 0 8.fromCharCode()String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串 1234String.fromCharCode() // ""String.fromCharCode(97) // "a"String.fromCharCode(104, 101, 108, 108, 111)// "hello" 上面代码中，String.fromCharCode方法的参数为空，就返回空字符串；否则，返回参数对应的 Unicode 字符串。 5.7 单体内置对象ECMA-262定义内置对象是：由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。例如Object，Array和String，Global和Math。 5.7.1Global 对象事实上，没有全局对象或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性，例如isNaN()、isFinite()、parseInt()以及parseFloat()。除了这些，Global对象还有一些方法。 1.URI编码方法Global对象的encodeURI()和encodeURIComponent()方法可以对URI进行编码，以便发送给浏览器，让浏览器更好地理解。 encodeURI()主要用于整个URI，而encodeURIComponent()主要用于对URI中的某一段进行编码。区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，而encodeURIComponent()则会对它发现的任何非标准字符进行编码。 1234567var uri = "http://www.wrox.com/illegal value.htm#start";//"http://www.wrox.com/illegal%20value.html#start"alert(encodeURI(uri));//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start"alert(encodeURIComponent(uri)); encodeURI()和encodeURIComponent()对应的两个方法分别是decodeURI()和decodeURIComponent()（这两个是解码）。 URI方法encodeURI()、encodeURIComponent()、decodeURI()和decodeURIComponent()用于替代已经被ECMA-262第3版废弃的escape()和unescape()方法。URI方法能够编码所有Unicode字符，而原来的方法只能正确的编码ASCII字符。 2.eval()方法 eval()方法就像一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript字符串。 当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域。 12var msg = "hello world!";eval("alert(msg)"); //"hello world" 12eval("function sayHi() &#123; alert('hi'); &#125;");sayHi(); 在eval()中创建的任何变量或函数都不会提升，因为在解析代码的时候，它们被包含在一个字符串中，它们只在eval()执行的时候创建。 严格模式下，在外部访问不到eval()中创建的任何变量和函数，为eval赋值也会导致错误。 12'use strict';eval = "hi"; //causes error 5.7.2Math对象 Math是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。 Math.abs()：绝对值 Math.ceil()：向上取整 Math.floor()：向下取整 Math.max()：最大值 Math.min()：最小值 Math.pow()：指数运算 Math.sqrt()：平方根 Math.log()：自然对数 Math.exp()：e的指数 Math.round()：四舍五入 Math.random()：随机数 1.Math对象的静态属性，参阮一峰 提供以下一些数学常数。 12345678Math.E：常数e。Math.LN2：2 的自然对数。Math.LN10：10 的自然对数。Math.LOG2E：以 2 为底的e的对数。Math.LOG10E：以 10 为底的e的对数。Math.PI：常数 Pi。Math.SQRT1_2：0.5 的平方根。Math.SQRT2：2 的平方根。 2.min()和max()方法如果参数为空, Math.min返回Infinity, Math.max返回-Infinity。 12Math.max(2, -1, 5) // 5 Math.min(2, -1, 5) // -1 3.舍入方法Math.floor方法小于参数值的最大整数 。 12Math.floor(3.2) // 3Math.floor(-3.2) // -4 Math.ceil方法返回大于参数值的最小整数（天花板值）。 12Math.ceil(3.2) // 4Math.ceil(-3.2) // -3 Math.round方法用于四舍五入。 1Math.round(0.1) // 0 4.random()方法Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 1Math.random() // 0.7151307314634323]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于吃]]></title>
    <url>%2Fnote%2F2018%2Fundefined04%2Fec13cc6b.html</url>
    <content type="text"><![CDATA[1. 有哪些食物为了健康你一定不吃？ 绝对不吃：烟（致癌）、槟榔（致癌） 能不吃就不吃：含糖饮料（肥胖）、含糖量高的食品（肥胖）、酒（致癌）、路边摊（卫生状况糟糕） 偶尔吃：油炸（三高）、烟熏（可能致癌）、烤制（可能致癌）、其它高油高盐高糖或致癌加工食品 酒精作为一类致癌物，没有安全剂量可言，喝多喝少都有害，红酒白酒啤酒果酒药酒都有害，尽量不喝才是正确的 。其正面作用远不如危害大。 饼干，大部分蛋糕，开酥的面包（蝴蝶酥，唱片面包等），奶茶，冰淇淋，饮料，雀巢咖啡和伴侣。 原因: 高糖高油导致发胖。 螺类 ，不熟的肉类。 淘宝自制，美食节上的食物。 适合多吃：燕麦，西红柿。]]></content>
      <categories>
        <category>泛娱乐</category>
      </categories>
      <tags>
        <tag>知乎</tag>
        <tag>吃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网格布局（CSS Grid Layout）]]></title>
    <url>%2Fnote%2F2018%2Fundefined30%2F7e93ee50.html</url>
    <content type="text"><![CDATA[css网格布局引入了二维网格布局系统，可用于布局页面主要的区域布局或小型组件。flex布局：弹性盒子布局主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。 1. 网格容器通过在元素上声明 display：grid 或 display：inline-grid 来创建一个网格容器。一旦我们这样做，这个元素的所有直系子元素将成为网格元素。网格元素显示为蚂蚁线。divtwo无内容，宽高为零不显示。 2. 网格属性 grid-template-columns grid-template-rows grid-auto-rows grid-auto-columns grid-column-start grid-column-end grid-row-start grid-row-end grid-column-gap grid-row-gap 2.1我们通过 grid-template-columns 和 grid-template-rows 属性来定义网格中的行和列。 1grid-template-columns: 100px 200px 200px;/100px repeat(2,200px) 2.2 在隐式网格中用 grid-auto-rows 和 grid-auto-columns 属性来定义一个设置大小尺寸的轨道。即这两个属性只作用于隐式网格。 2.3 跨轨道放置网格元素 grid-column-start grid-column-end grid-row-start grid-row-end 2.4 网格间距 grid-column-gap grid-row-gap 3. fr 单位轨道可以使用任何长度单位进行定义 ，fr单位代表网格容器中可用空间的一等份。 ​ 1grid-template-columns: 50px repeat(2, 1fr);/ 50px 1fr 1fr 1grid-template-columns: 50px repeat(6, 1fr); 4. 隐式和显式网格grid-template-columns 属性定义了自己的列轨道，但是却让网格按所需的内容创建行，这些行会被创建在隐式网格中。显式网格包含了你在 grid-template-columns 和 grid-template-rows 属性中定义的行和列。果你在网格定义之外又放了一些东西，或者因为内容的数量而需要的更多网格轨道的时候，网格将会在隐式网格中创建行和列。按照默认，这些轨道将自动定义尺寸，所以会根据它里面的内容改变尺寸。 上面这句话更加通俗的说就是只有具有 grid-template-columns 和 grid-template-rows同时声明的网格才是显式网格。 4.1 例一1234567&lt;div class=&quot;wrapper&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;Two&lt;/div&gt; &lt;div&gt;Three&lt;/div&gt; &lt;div&gt;Four&lt;/div&gt; &lt;div&gt;Five&lt;/div&gt;&lt;/div&gt; 123.wrapper &#123; display: grid;&#125; 此时为隐式网格 4.2 例二1234.wrapper &#123; display: grid; grid-template-columns: 50px repeat(2, 1fr);&#125; 此时虽定义了列宽，但并未定义行高，行高为自适应，仍未隐式网格。 4.3 例三12345.wrapper &#123; display: grid; grid-template-columns: 50px repeat(2, 1fr); grid-template-rows：60px; &#125; 此时定义了三列一行，所以第一行高为60px，第二行高仍未自适应且为自动创建的隐式网格，尽管它继承了列宽； 第一行为显示网络，有行列共同声明。 4.4 例四123456.wrapper &#123; display: grid; grid-template-columns: 50px repeat(2, 1fr); grid-template-rows：60px; grid-auto-rows：50px; &#125; 为隐式网格定义行高，而显示网格仍未60px，并未受影响。 5. 轨道大小和minmax()grid-auto-rows：minmax(50px,auto) 定义了隐式网格的行高最小为50px，超出50px后高度自适应。 6. 网格线Grid 会为我们创建编号的网格线来让我们来定位每一个网格元素. 例如下面这个三列两行的网格中，就拥有四条纵向的网格线。 7. 网格单元一个网格单元是在一个网格元素中最小的单位， 从概念上来讲其实它和表格的一个单元格很像。 参考链接未完待续。。。。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弹性布局（flex）]]></title>
    <url>%2Fnote%2F2018%2Fundefined28%2F5c7aade3.html</url>
    <content type="text"><![CDATA[声明：本文大部分摘自别处，链接在文末给出。 1. Flex布局Flex 是 Flexible Box 的缩写，意为”弹性布局”。W3C针对布局设计的新标准，相对float和position会更加灵活处理父元素和子元素之间布局关系，让布局更加直观和灵活简单。有效的针对不同屏幕宽度大小的情况下，让元素自动有效合理处理布局结构。 适用范围弹性盒子布局主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。 1.1 Flex布局基本概念 1.1.2 弹性容器(Flex container)通过设置 display 属性的值为 flex 或 inline-flex来定义弹性容器。 就像blockandinline-block作用于描绘对象，对于其子元素当然不会有效果。 1.1.3 弹性项目(Flex item)弹性容器里子元素自动成为弹性项目，并且弹性项目的float、clear和vertical-align属性将失效。 1.1.4 轴(Axis) 主轴（main axis） 交叉轴（cross axis） 这个2个轴决定了容器里的项目整体布局效 1.2 Flex容器属性 flex-direction flex-wrap flex-flow justify-content align-items align-content 1.2.1 flex-direction决定主轴方向，默认情况下，元素都是从左到右地分布在主轴上4个取值： flex-direction: row | row-reverse | column | column-reverse; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 依次如下图： 1.2.2 flex-wrap是否可以换行（默认不换行），以及如果可以换行，如何排列 3个取值 flex-wrap: nowrap | wrap | wrap-reverse; nowrap: 默认不换行 wrap: 可以多行，第一行在上方 wrap-reverse: 可以多行，第一行在下方 1.2.3 flex-flowflex-direction 和 flex-wrap 的简写,默认row nowrap flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; 1.2.4 justify-content属性定义了项目在主轴上的对齐方式。.box { justify-content: flex-start | flex-end | center | space-between | space-around;} 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 1.2.5 align-items决定交叉轴的对齐方式 1234567align-items: flex-start | flex-end | center | baseline | stretch;flex-start: 交叉轴起点对齐flex-end: 交叉轴终点对齐center: 交叉轴居中对齐baseline: 第一行文字的底部对齐stretch: （默认）如果项目木有设置高度或者高度为auto,那么项目拉伸充满整个交叉轴空间 注意：记住justify-content是沿着主轴的，align-items是沿着交叉轴的，而flex-direction是转换主轴的。这对整体移动元素很关键。 1.2.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 详参：align-content更多属性,MDN. 1.3 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 1.3.1 orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 1.3.2 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 该属性可能取6个值，除了auto，其他都与align-items属性完全一致 1align-self: auto | flex-start | flex-end | center | baseline | stretch; 1.3.3 flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 1.3.4 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 1.3.5 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。当width与flex-basis同时存在以后者宽度为准。flex-basis 和 width 不同的地方是，它是和 flex 坐标轴保持一致的，flex-basis是影响主轴上大小。即当flex-direction为默认row时，flex-basis为项目宽度。当flex-direction属性值为column时，flex-basis值为项目高度。 1.3.6 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 参考链接通过动图形象地为你介绍 flexbox 是如何工作的（一）Flex 布局教程：语法篇flex基础布局详解使用 CSS 弹性盒子]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《批判性思维》]]></title>
    <url>%2Fnote%2F2018%2Fundefined27%2F50fabfb3.html</url>
    <content type="text"><![CDATA[批判性思维：思维、沟通、写作、应变、结决问题的根本技巧 (美)保罗，（美）埃尔德著 这个版本的翻译真的令人很不满意，如果可以就不要看这一版。坑 序论 我们就好比学样的猴子，只知道机械的模仿却不明就里。如果你开始用类似于植物学家观察植株的方式来对思维过程加以关注，你将会成为一个非凡杰出的人。你会开始注意到很少有人关注的事情。你会成为一只少有的杰出的猴子，了解模仿动作的含义，知道自己该如何模仿，以及为什么模仿，并明白如何评估和改进模仿的技巧。 只有当你清楚地意识到自己在怎样进行思考，并且努力地去认识这种思考所包含的优势和弱点时，当你建造了“大屏幕”来观看自己的思维过程后，你才逐渐成为思考者。 批判性思维：自我监控和自我改进的思维方式。 我们常说的三思而后行。在进行任何决策和行为前，要对将要发生的进程进行预判。比如要去吃饭，到吃饭的时间了吗，还是想逃避眼前的事情。要吃什么饭，面还是米。吃完饭直接回来吗，还是溜达一圈再回来。 第一章成为公正的思考者高级批判性思维高级批判性思维者致力于做到公正无私。这样就避免了利用自己的技巧来侥胜对方，我们用同样的高标准来衡量所有的思维过程。希望那些支持和反对我们的人所进行的推理都是出色的。对那些我们无情反驳和对自己的推理都用同样的标准来要求。我们要质疑自己的的证据、结论、暗示和观点，一如质疑他人的这些思维要素。 公正思维有何要求公正思维必须力争不偏不倚和毫无偏见的态度来对待和某情景有关的是所有观点，不受个人感受或私利的左右，也不受朋友，团体的感受或利益的影响。 做到公正思维必须同时具备 态度谦逊 勇敢无畏 设身处地 诚实 坚持不懈 笃信推理 意志自由 态度谦逊：吾生也有涯，而知也无涯态度谦逊可以定义为对个体知识局限性的清楚认识，避免一叶障目，管中窥豹。同时也要思考自己的观点、想法的来源是否正确偏颇。 了解肤浅的认识 选择一门自己取得高分的课程，然后思考以下问题 学习这门课的目的是什么？ 这个领域的工作者都在努力达到什么样的目标？ 他们一般会提出什么样的问题？ 他们一般致力于解决什么样的问题？ 他们搜集什么样的数据或者信息？ 他们是怎样以该领域所特有的方式来搜集信息的？ 这领域最基本的观念或者理论是什么？ 对于该领域的学习是怎样改变你对世界的看法的？ 勇敢无畏：勇于挑战信念 “从来如此，便对吗？”__鲁迅 当自己的观点、信念被质疑时，要勇于克服被别人否定的恐惧。 不要害怕犯错误，同时也要勇于质疑。 我不会随意认同任何信念的内容，我只认同自己形成这些信念的过程，紧紧跟随证据和推理引领的方向，摒弃那些不为证据或理性思考所支持的信念。 设身处地：考察对立观点若想做到设身处地，就得准确地重建他人观点和推理过程。当我们以自我为中心进行思考时，就无法理解其他人的想法、感受和情绪。 坚持不懈：排除万难，战胜挫折当一个人在面对脑力劳动的困难与挫折而不放弃时，此人就具备了坚持不懈。如果缺乏坚持不懈，就无法对学科进行透彻思考，进而获得远见卓识。竭力避免头脑的挫折，获得的却是因为无法解决日常生活中的复杂问题而日益滋生的挫败感。 同时我们要避免过于苛求证据，避免对自己的推论和解释过于苛责，避免锱铢必较。一定程度上的自负是必要的。 第二章 思维发展的起初四个阶段成为一个出色的思考者，一般要经过以下阶段 第一个阶段：轻率鲁莽的思考者（我们对自己思维过程中的重大问题一无所知） 第二个阶段：面临挑战的思考者（我们开始意识到自己思维中存在的问题了） 第三个阶段：初出茅庐的思考者（我们尝试着提高自己的思维技巧，但是缺乏有规律的训练） 第四个阶段：实践操练的思考者（我们意识到了有规律训练的必要性） 第五个阶段：技艺高超的思考者（随着训练的深入我们的思维技巧与日俱进） 第六个阶段：思想大师（技艺非凡和富有洞见的思考成为我们的第二本能） 第三个阶段：初出茅庐的思考者在这个阶段，开始着手提升自己的价值观。 有哪些对塑造思想产生了重大影响： 你诞生于某种文明之中（欧洲文明、非洲文明、美洲文明以及亚洲文明） 你在某个时间点诞生（某个世纪的某一年） 你在某地出生（某个国家，某个城市，南方或北方，东方或西方） 你是由具有特定信仰的父母所抚养（关于家庭，人际关系，婚姻，宗教，政治，教育） 。。。。。 如果能改变上面的某种影响，那么信念体系会截然不同。 第三章 理解自我 对待事情要以积极的态度进行思考，态度与行动是相互影响的。好心情会笑，反过来笑也可以带动好心情。 大脑自我催眠说：真好吃。 嗯 嘴巴说：哎，果然好好吃啊。 你说你大脑骗起自己的身体来，会有多可怕的能量。所以，要好好利用。 第四章推论：根据已知正确，或看上去正确的事物，得出其他事物的正确性。 假设：认为理所当然或者预先假定的东西，通常为我们已知且深信不疑，是我们信念体系的一部分。 第五章:思维的衡量标准思维的8大元素：1、目的：我是要干嘛？达到什么目的？2、悬而未决的问题：根据这个目的遇到的最主要问题或者议题是什么？3、信息：为了解决这个问题我需要收集哪些信息、数据、事实或者经验？4、解释和推理：根据掌握的信息进行解释或者推理。5、概念：界定解决问题中出现的理论、定义、规则、原理、模式等概念，统一标准。6、假设：清楚在解释和推理中隐含的假设条件什么？7、结果和意义：通过逻辑得出意义和结果是什么？8、观点：从哪个角度、视角出发来解决问题的？ 推理的要素，为了结论正确，需要确保的得出结论的过程正确。对于每个思维元素都应该综合考虑是否达到了思维的标准。 思维的9大标准 ： 清楚 正确 精确 深度 广度 切题 有逻辑性 有意义 公正 作为一个批判性思维者，我们应该对自己的思想提出如下问题：我的思路清晰吗？正确吗？精确吗？切题吗？是否有逻辑性？我所思考的事情有意义吗？在一定的场合中正当吗？ 清楚 你能解释这一观点吗？ 你能换一种方法表达这个观点吗？ 你能给出图例或例子吗？ 能不能把问题说明白，没有歧义。区分模糊和清楚的观点。 “他是个好人” 这句话就模糊，由于我们不知道这句话发生的场景，就会揣测出不同的意思。 精确 精确意味着给出一些必须的细节，来让别人理解说话人的意思。有时则无需这种细节。比如 冰箱里有没有牛奶，回答 有。已经足够了，一般不用回答出还有多少 “小明超重了” 这句话清楚正确却不精确，我们不知道超重了多少，一斤、两斤 深度 面对吸毒问题应该采取什么措施，答 拒绝毒品。 广度 从不同的角度考虑问题 第六章 正确提问引发出色思维思维不是由答案，而是由问题推动的。问题体现了要完成的任务和存在的疑点，而答案往往是思考的终结。 思维应当能结出果实，否则就一无所用。 三类问题： 事实性问题。 这种问题只要一个正确答案。 比如：水的沸点有多大？ 见仁见智问题。这类问题因人看法不同，以主观性为主 比如：你喜欢留什么样的发型？ 判断性问题。这种问题需要推理，对此问题的回答，不能太主观。可以用思维的标准来进行检验。 如：清楚，深度，广度等。一个复杂的问题往往跨越多个思维领域。（心理学，社会学，经济学，生物学，政治，道德） 比如：死刑应该被取消吗？ 成为苏格拉底式的提问者 苏格拉底式的提问的基本原理： 试着去理解一种见解或看法的根本基础，并在以后的问题中遵循这些基础。（例如：你的信念依据是什么？你能更详细低解释自己的思想，让我更好地理解你的观点吗？） 只有当一种思想和其他思想共同形成一个网络时，它才能完整的存在。因此，应当把所有的主张都当做引发更多思考的连接点，寻找它们之间的联系。就是我们所说发散性思维。（例如：如果你所说属实，那x或y不也如此吗？） 所有的问题都是环环相扣的，思考也是如此。因此，提出问题时，也不要忘记了它们会引发的其他问题。（例如：要回答这个复杂的问题，还需要回答其他相关的问题？） 除了以苏格拉底的方式进行提问，还以从以下几个方面进行提问： 围绕思维的衡量标准提出问题 围绕思维要素提出问题 围绕先验问题发问 我们在处理复杂的问题时，要设计先验问题–即回答复杂问题之前需要解决的问题。 要回答“什么是多元文化主义“要先解决”解决什么是文化“又应该先回答”决定文化归属的因素是什么“ 围绕思维领域提出问题（历史，政治，文化，心理，经济） 第七章 精通思考，掌握知识 每门课程的知识都体现了独特的思维方式。 所有的知识都是由人类思想所创造；他们由思想形成、分析、合成、表达、评价、重建、改造；也是通过思想来学习，理解并应用。如果试图把知识和思想分开，那么将什么也得不到。 第八章 规划你的学习 大学课程的规划 弄懂课程中的基本概念 找出每门课程必须的思维模式 运用学科逻辑进行思考。 为自己规划课程 第九章 评估你的学习自我评价策略自我评价对批判性思维至关重要，所以应该好好规划而不是随便看待。每天都要对自己的学习质量进行评价，经常使用思维的衡量标准来判断。 专业掌握情况的通用描模板顺利修完xx专业的学生会表现出一系列xx思考技能，用以掌握知识。他们在课程结束后的作业清楚、准确、合理。他们掌握了xx的基本术语和辨析，可以解决基本的xx问题。从作业中可以看出，他们可以驾驭自己的xx思想、假设、推论和思考过程。 他们能够清晰准确分析的xx问题，正确陈述xx信息，区分有关信息和无关信息，找出可以的xx假设前提，清楚解释基本xx概念，使用xx术语，能够确认不同的观点，往往会从明确的前提出发去推论，对重要的xx涵义和后果非常敏感。他们表现出优秀的xx思维技巧和解决问题的能力。 上面的xx可以用专业去替换，比如可以替换为历史、哲学、数学…… 在简历里进行自我描述时，可以对上面的模板进行借鉴。 一直以来，我们听惯了大道理，学了太多的屠龙术。比如每天坚持学英语几年之后，你的英语会灰常厉害。然而，对于每条大道理，大多数的我们很少能够贯彻下去。本书也是一本很厉害的屠龙术，读的过程中让我反复意识到自己有多差劲，大道是无尽的。读来还是很有好处的，对于其描述虽不能完全执行，但总还能学的些皮毛，读来总能有些启发。 思考让思想更有力量。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超链接与伪类]]></title>
    <url>%2Fnote%2F2018%2Fundefined15%2F59c34dbb.html</url>
    <content type="text"><![CDATA[在 HTML 4.01 中，&lt;a&gt; 标签可以是超链接或锚。在 HTML5 中，&lt;a&gt; 标签始终是超链接，但是如果未设置 href 属性，则只是超链接的占位符,则不可以使用如下属性：download, hreflang, media, rel, target 以及 type 属性,此时color等无法设置属性值。 a:link /* 未访问的链接 */ a:visited /* 已访问的链接 */ a:hover /* 鼠标移动到链接上 可以用在表格上*/ a:focus /*获得焦点状态 可以用在输入框上*/ a:active /* 选定的链接 激活发生在链接被点击时 可以用在提交按钮上*/ 上面的次序很重要，否则有些样式会不起作用。次序为：lvhfa。简单记法：Lord Vader Hate Furry Animals。 1. 突出显示不同类型的链接1.1如图给链接加个小图标 实现方法： 1.可用img直接vertical-align：top； 在超链接上通过background来实现。 同理，如果想实现在文字的下面加些特殊的下划线，也可通过background把图片定到文字下。 1.2 给链接在focus状态下加个下标线 通过 a { text-decoration: none;} a:focus{ padding-bottom: 22px; border-bottom: 2px solid red } 启示：通过伪类状态的不同属性（link,visited,hover,focus,active）,可以在不同的属性下设置一些不同的样式，比如focus时文字背景颜色变为红色 2 图像翻转不同伪类状态属性时文字的背景图片不同，可以营造一种错觉的的图像翻转，就是把文字的背景颜色变为背景图像。 2.1pixy方法由于这种方法在在第一次加载图像时会有点迟钝，因此我们可以将悬停的图像作为背景应用于父元素，从而预先加载他们。再进一步，可以把多个图像放在一个背景图像的不同位置，因此减少了服务器请求的数量。把所有图像放在同一个位置的方法叫做pixy方法。（pixy是发明者的昵称） 2.2 css精灵多个服务器请求会对站点的性能产生显著的影响，所以在pixy方法的启示下，可以把一个网站的所有图标和，图形等放在一个图像上。这就是css精灵。 然而在个人的实践下，这种方法并不好用，对各个图像的位置要求比较大，为此需要的花费好多时间进行调试。所以使用与否看需求了。 2.3 文字图像同时翻转在这里进行图像翻转的同时，文字是不变的。要想实现文字与背景都改变，需要用到text-indent与position:absloute，然而这两者会产生放一起会产生奇特的化学反应。即当 父元素的text-indent作用于文字时position:absloute里的文字会一起移动，position:absloute的原位仍在，但对其文字失去控制能力。如下： &lt;div id=&quot;hh&quot;&gt; &lt;div id=&quot;ff&quot;&gt;fdsklfj&lt;/div&gt; 我是按钮链接 &lt;/div&gt; #hh{width:500px; text-align: center;background-color: grey;} #ff{ width:100px; position: absolute; top: 0; left: 0; } 当对#hh添加text-indent:100px时,盒子ff的文字会一起移动; 为解决这个问题我们可以使用覆盖的方式。如下两个同级元素，由于盒子hh完全被盒子ff的绝对定位覆盖即盒子ff层次在盒子hh之上，此时位于下面的盒子#hh:hover失效 &lt;div id=&quot;hh&quot;&gt; 我是按钮链接 &lt;/div&gt; &lt;div id=&quot;ff&quot;&gt;fdsklfj&lt;/div&gt; #hh{width:500px; text-align: center;background-color: grey; } #hh:hover{ text-indent: 1000px;} #ff{ width: 500px; position: absolute; top: 8px; left: 8px; } #ff:hover{text-align: center; color:yellow} 对#ff:hover添加background-color:red 3 悬停下拉菜单 &lt;ul id=&quot;one&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;Products&lt;/a&gt; &lt;ul id=&quot;two&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Services&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Contact Us&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Services&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Contact Us&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; #one li { list-style: none; float: left; border:1px solid #486b20;background-color: #8bd400; width: 85px;} #one li a{text-decoration: none;} #two {position: absolute; left: -1000px; padding: 0; } #one li:hover #two{ left: auto; } #two li{ float: none; width: 85px; } 下拉菜单的难点在于#one li:hover #two{ left: auto; },通过父元素的状态来控制子元素。 4.锚锚可以作为内部引用，也可以作为外部链接。 &lt;a href=&quot;#na&quot;&gt;one&lt;/a&gt; &lt;a href=&quot;&quot; id=&quot;jump&quot;&gt;two&lt;/a&gt; ...... &lt;a name=&quot;na&quot;&gt;three&lt;/a&gt; &lt;a href=&quot;#jump&quot;&gt;four&lt;/a&gt; 点击one会跳到three，点击four会跳到two。 name属性在H5中不在支持。 5.backgroundbackground-repeat repeat 默认。背景图像将在垂直方向和水平方向重复。 repeat-x 背景图像将在水平方向重复。 repeat-y 背景图像将在垂直方向重复。 no-repeat 背景图像将仅显示一次。 inherit 规定应该从父元素继承 background-repeat 属性的设置 background-sizecover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。 contain 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域 可用长度百分比（顺序宽高），如果只设置一个值，第二个值auto； 详参http://www.w3school.com.cn/cssref/pr_background-size.asp]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《JavaScript高级程序设计》（1）]]></title>
    <url>%2Fnote%2F2018%2Fundefined13%2F556216f0.html</url>
    <content type="text"><![CDATA[[美] Nicholas C.Zakes 著 李松峰 曹力 译 （第三版） 本文以JS高程为主线， 阮一峰的《 JavaScript标准参考教程》为辅。 第一章 JavaScript简介 第二章 在HTML中使用JavaScript 第三章 基本概念 （语法、关键字、保留字、数据类型，操作符、语句） 第一章 JavaScript简介1.1 JavaScript简史由于网页的大小和复杂性不断增加以及网速的限制。为完成简单的表单验证（是否没有填写某个必填项，是否输入了无效的值）而频繁地与服务器交换数据只会加重用户的负担，为此，1995年当时就职于Netscape公司的Brendan Eich为Netscape Navigator开发了一种名为LiveScript的脚本语言–该语言可同时在浏览器的与服务器中使用（仅在客户端就可以完成简单的验证），为了搭上热炒Java的顺风车，改名为JavaScript。 微软为与Netscape竞争，在自家的IE浏览器里加入了JScript，就有了两个不同的JavaScript版本，为了标准化，由欧洲制造商协会（ECMA，European Computer MAnufacturers Association）牵头来自一些公司程序员共同制定了ECMA-262–定义一种名为ECMAScript(发音为“ek-ma-script”)的新脚本语言标准。 1.2 JavaScript实现一个完整的JavaScript实现应该有以下三个不同的部分组成 核心（ECMAScript）：提供核心语言功能； 文档对象模型（DOM）：提供访问和操作网页内容的方法和接口； 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。 1.2.1 ECMAScript由ECMA-262定义的ECMAScript与浏览器没有依赖关系，web浏览器只是其实现可能的宿主环境之一。主要定义了核心语言功能： 语法 类型 语句 关键字 保留字 变量 操作符 1.2.2 文档对象模型（DOM）文档对象模型（DOM,Document Object Model）是针对XML但经过扩展用于HTML的应用程序接口（API，Application Programmaing Interface）。DOM把整个页面映射为一个多层节点结构，形成dom树开发人员获得页面内容和结构的控制权，借助DOM提供的API，开发人员可以轻松自如地删除，添加，替换和修改任何节点。 第二章 在HTML中使用JavaScript2.1 &lt;script&gt;元素向HTML页面中插入JavaScript的主要方法就是使用&lt;script&gt;元素,在页面中正常情况下按先后顺序依次解析。HTML4.0为&lt;script&gt;定义了下列六个属性 async：可选。表示立即下载脚本，但不妨碍页面中的其他操作。 charset：可选。很少用，忽略。 defer：可选；表示立即下载脚本，但可以延迟到文档完全被解析和显示之后再执行。现实中如果有多个延迟脚本，不一定会按照顺序执行，所以最好只包含一个。 language：已废弃。 src：可选。表示包含要执行代码的外部文件地址。 type：可选。 2.2 嵌入代码与外部文件2.2.1 嵌入代码12345&lt;script type="text/javascript"&gt; function sayHi（）&#123; alert（"Hi!"） &#125;&lt;/script&gt; 不能在嵌入的代码中任何地方出现&lt;/script&gt;,这会让浏览器产生一个错误。可通过转义字符“\”,&lt;\/script&gt;. 2.1.2 嵌入外部文件1&lt;script type="text/javascript" src= "example.js" &gt; &lt;/script&gt; 标签之间不应该包含额外的代码块，会被忽略，只解析外部脚本文件。为减少呈现页面的延迟，通常把JavaScript的引用放在内容之后&lt;/body&gt;之前。 2.3 &lt;noscript&gt;元素当浏览器不支持js时如何让页面平稳地退化，创造一个&lt;noscript&gt;元素，这个标签能够出现在&lt;body&gt;中的任何HTML元素——&lt;script&gt;元素除外。包含在&lt;noscript&gt;元素中的内容在以下情况才会显示出来： 浏览器不支持脚本 浏览器支持脚本，但被禁用。 &lt;noscript&gt; &lt;p&gt;本页面需要支持（启用）JavaScript&lt;/p&gt; &lt;/noscript&gt; 第三章 基本概念3.1 语法ECMAScript的语法大量借鉴了C及其它类C语言（如java和perl）的语法。 3.1.1 区分大小写ECMAScript中的一切（变量，函数名和操作符）都区分大小写。 3.1.2 标识符标识符，就是指变量、函数、属性的名字，或者函数的参数。 书写要求： 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）; 其他字符可以是字母、下划线、美元符号或数字。 标识符中的字母也可以包含扩展的ASCII 或Unicode 字母字符。但不推荐这样做。 按惯例，标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词首字母大写。不能把关键字，保留字，true，false和null用作标识符。 JavaScript有一些保留字，关键字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 否则在严格模式下，可能会抛出错误。 3.1.3 注释使用C风格的注释。单行注释//单行注释，/*块级注释*/。块级注释中，每个行首也可加*号，提高注释的可读性。 此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以&lt;!--和--&gt;也被视为合法的单行注释。 12x = 1; &lt;!-- x = 2;--&gt; x = 3; 上面代码中，只有x = 1会执行，其他的部分都被注释掉了。 需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。 1234567function countdown(n) &#123; while (n --&gt; 0) console.log(n);&#125;countdown(3)// 2// 1// 0 上面代码中，n --&gt; 0实际上会当作n-- &gt; 0，因此输出2、1、0。 3.1.4 严格模式严格模式是为JavaScript定义了一种不同的解析与执行模型。一些不确定的行为将会的到处理，不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： “use strict”; 其实它是一个编译指示，告诉JS引擎切换到严格模式。也可以指定函数在严格模式下执行，在函数内部的上方添加编译指示： 1234function doSomething( ) &#123; &quot;&quot;use strict&quot;; //函数体&#125; 3.1.5 语句ECMAScript中的语句以一个分号结尾；如果省略分号，则由解析器花费时间推测语句的结尾，也有可能会导致压缩错误。 1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。 分号前面可以没有任何内容，JavaScript引擎将其视为空语句。 1;;; 上面的代码就表示3个空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。 3.2 关键字和保留字关键字：用于表示控制语句的开始或结束，或者用于执行特定的操作等。 保留字：虽然还没有任何特定用途，但他们将来有可能被用来关键字。 3.3 变量JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型，有效但不推荐。 每个变量仅仅是一个用来保存值的占位符而已。 变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 1var a = 1; 上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a。以后，引用变量名a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。 变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。 12var a;a = 1; 如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。 123var a = 1;// 基本等同a = 1; 但是，不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量， 用var操作符定义的变量将成为定义该变量作用域的局部变量即如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁，在函数外部不能被访问到。 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。 12x// ReferenceError: x is not defined 上面代码直接使用变量x，系统就报错，告诉你变量x没有声明。 可以在同一条var命令中声明多个变量。 1var a, b; 如果使用var重新声明一个已经存在的变量，是无效的。 123var x = 1;var x;x // 1 上面代码中，变量x声明了两次，第二次声明是无效的。 但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值 3.3.1 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。 12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。 123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 刚在谷歌浏览器控制台测试，上面代码块1，结果是显示undefined， 2结果为1。火狐中代码块1，2结果都为1。是否可以认为，js引擎更智能了？？ 3.4 数据类型JavaScript 的数据类型，共有六种。可分为两类：（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。） 基础类型又叫原始值，复杂类型又叫对象值。（所以为从英文翻译过来对于理解就是麻烦事） 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 对象是最复杂的数据类型，又可以分成三个子类型。 狭义的对象（object） 数组（array） 函数（function） 狭义的对象和数组是两种不同的数据组合方式 函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量 。 3.4.1 typeof 操作符JavaScript 有三种方法，可以用来检测给定变量的数据类型。 typeof运算符 instanceof运算符 Object.prototype.toString方法 数值、字符串、布尔值分别返回number、string、boolean，函数返回function 。null返回object ，对象返回object 。undefined返回undefined 。 undefined返回undefined 。 利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。 12345v// ReferenceError: v is not definedtypeof v// "undefined" 上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined. 这样做没有意义，严格模式下会导致错误。 实际编程中，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === "undefined") &#123; // ...&#125; 对象返回object。 123typeof window // &quot;object&quot;typeof &#123;&#125; // &quot;object&quot;typeof [] // &quot;object&quot; 上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。 12345var o = &#123;&#125;;var a = [];o instanceof Array // false 验证o是不是数组a instanceof Array // true 验证a是不是数组 3.4.2 null 和 undefinedundefined 类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。 声明并未加以初始化与尚未定义即未声明且未初始化的变量是不一样的。 null也是只有一个值的数据类型，这个特殊值时null.从逻辑角度来讲null值表示一个空对象指针。 如果定义的变量准备在将来用于保存对象，就应该明确的让变量保存null值。然而没有必要把变量的值显示的设为undefined。 相等性测试 12alert （null == undefined）// truenull === undefined // false 实际上undefined值派生于null值，引入undefined值是为了正式区分空对象指针与未经初始化的变量。 undefined表示“未定义”，下面是返回undefined的典型场景。 1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined 3.4.3 布尔值(boolen)布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN &quot;&quot;或&#39;&#39;（空字符串） 3.4.4 数值（number）1. 整数和浮点数JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 11 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 120.1 + 0.2 === 0.3// false 计算机内是用二进制进行存储，在浮点数转化为二进制时会发生取舍，所以0.1可能是0.100002。 2. 数值精度根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。 1(-1)^符号位 * 1.xx...xx * 2^指数部分 上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。 精度最多只能到53个二进制位，这意味着，绝对值小于等于2的53次方的整数，即-253到253，都可以精确表示。 1234567891011121314Math.pow(2, 53)// 9007199254740992 Math.pow(2, 53) + 1// 9007199254740992Math.pow(2, 53) + 2// 9007199254740994Math.pow(2, 53) + 3// 9007199254740996Math.pow(2, 53) + 4// 9007199254740996 上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。 123456Math.pow(2, 53)// 9007199254740992// 多出的三个有效数字，将无法保存9007199254740992111// 9007199254740992000 上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的111）都会无法保存，变成0。 3. 数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。 1Math.pow(2, 1024) // Infinity 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 1Math.pow(2, -1075) // 0 下面是一个实际的例子。 1234567var x = 0.5;for(var i = 0; i &lt; 25; i++) &#123; x = x * x;&#125;x // 0 上面代码中，对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。 JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。 12Number.MAX_VALUE // 1.7976931348623157e+308Number.MIN_VALUE // 5e-32 4. 数值的进制使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 十进制：没有前导0的数值。 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。 十六进制：有前缀0x或0X的数值。 二进制：有前缀0b或0B的数值。 默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。 1230xff // 2550o377 // 2550b11 // 3 如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。 1230xzz // 报错0o88 // 报错0b22 // 报错 上面代码中，十六进制出现了字母z、八进制出现数字8、二进制出现数字2，因此报错。 通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。 120888 // 8880777 // 511 前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。 数值也可以采用科学计数法表示，下面是几个科学计数法的例子。 科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。 以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。 （1）小数点前的数字多于21位。 123451234567890123456789012// 1.2345678901234568e+21123456789012345678901// 123456789012345680000 （2）小数点后的零多于5个。 123456// 小数点后紧跟5个以上的零，// 就自动转为科学计数法0.0000003 // 3e-7// 否则，就保持原来的字面形式0.000003 // 0.000003 5. NaN（1）含义 NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），表示一个本来要返回数值的操作数未返回数值的情况。主要出现在将字符串解析成数字出错的场合。 15 - &apos;x&apos; // NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。 另外，一些数学函数的运算结果会出现NaN。 123Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN 0除以0也会得到NaN。 10 / 0 // NaN 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。 1typeof NaN // &apos;number&apos; （2）运算规则 NaN不等于任何值，包括它本身。 1NaN === NaN // false 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。 1[NaN].indexOf(NaN) // -1 NaN在布尔运算时被当作false。 1Boolean(NaN) // false NaN与任何数（包括它自己）的运算，得到的都是NaN。 1234NaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN （3）isNaN() 这个函数只接受一个参数，该参数可以是任何类型，如果能够转化为数值，函数返false。反之任何不能被转化为数值的值都会导致函数返回true。 6. Infinity（1）含义 Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。 1234567// 场景一Math.pow(2, 1024)// Infinity// 场景二0 / 0 // NaN1 / 0 // Infinity 上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回Infinity。第二个场景是0除以0会得到NaN，而非0数值除以0，会返回Infinity。 Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。 1234Infinity === -Infinity // false1 / -0 // -Infinity-1 / -0 // Infinity 上面代码中，非零正数除以-0，会得到-Infinity，负数除以-0，会得到Infinity。 由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，而是返回Infinity，所以单纯的数学运算几乎没有可能抛出错误。 Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。 12Infinity &gt; 1000 // true-Infinity &lt; -1000 // true Infinity与NaN比较，总是返回false。 12345Infinity &gt; NaN // false-Infinity &gt; NaN // falseInfinity &lt; NaN // false-Infinity &lt; NaN // false （2）运算规则 Infinity的四则运算，符合无穷的数学计算规则。 12345 * Infinity // Infinity5 - Infinity // -InfinityInfinity / 5 // Infinity5 / Infinity // 0 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。 1230 * Infinity // NaN0 / Infinity // 0Infinity / 0 // Infinity Infinity加上或乘以Infinity，返回的还是Infinity。 12Infinity + Infinity // InfinityInfinity * Infinity // Infinity Infinity减去或除以Infinity，得到NaN。 12Infinity - Infinity // NaNInfinity / Infinity // NaN Infinity与null计算时，null会转成0，等同于与0的计算。 123null * Infinity // NaNnull / Infinity // 0Infinity / null // Infinity Infinity与undefined计算，返回的都是NaN。 12345undefined + Infinity // NaNundefined - Infinity // NaNundefined * Infinity // NaNundefined / Infinity // NaNInfinity / undefined // NaN 要想确定一个数是不是有穷，可以使用isFinite()函数，如果参数位于最小值和最大值中间会返回true。 7. 数值转换 Number() 可用于任何数据类型 parseInt()和parseFloat()两个函数用于把字符串转化为数值 7.1 使用Number函数，可以将任意类型的值转化成数值。下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。 （1）原始类型值 原始类型值的转换规则如下。 123456789101112131415161718192021// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&apos;324&apos;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&apos;324abc&apos;) // NaN// 空字符串转为0Number(&apos;&apos;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0 Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。 12parseInt(&apos;42 cats&apos;) // 42Number(&apos;42 cats&apos;) // NaN 上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。 另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。 12parseInt(&apos;\t\v\r12.34\n&apos;) // 12Number(&apos;\t\v\r12.34\n&apos;) // 12.34 （2）对象 简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。 123Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5 之所以会这样，是因为Number背后的转换规则比较复杂。 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 第三步，如果toString方法返回的是对象，就报错。 7.2 parseInt()（1）基本用法 parseInt方法用于将字符串转为整数。 1parseInt(&apos;123&apos;) // 123 如果字符串头部有空格，空格会被自动去除。 1parseInt(&apos; 81&apos;) // 81 如果parseInt的参数不是字符串，则会先转为字符串再转换。 123parseInt(1.23) // 1// 等同于parseInt(&apos;1.23&apos;) // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。 12345parseInt(&apos;8a&apos;) // 8parseInt(&apos;12**&apos;) // 12parseInt(&apos;12.34&apos;) // 12parseInt(&apos;15e2&apos;) // 15parseInt(&apos;15px&apos;) // 15 上面代码中，parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 12345parseInt(&apos;abc&apos;) // NaNparseInt(&apos;.3&apos;) // NaNparseInt(&apos;&apos;) // NaNparseInt(&apos;+&apos;) // NaNparseInt(&apos;+1&apos;) // 1 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。 1parseInt(&apos;0x10&apos;) // 16 如果字符串以0开头，将其按照10进制解析。 1parseInt(&apos;011&apos;) // 11 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 1234567parseInt(1000000000000000000000.5) // 1// 等同于parseInt(&apos;1e+21&apos;) // 1parseInt(0.0000008) // 8// 等同于parseInt(&apos;8e-7&apos;) // 8 （2）进制转换 parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。 123parseInt(&apos;1000&apos;) // 1000// 等同于parseInt(&apos;1000&apos;, 10) // 1000 下面是转换指定进制的数的例子。 123parseInt(&apos;1000&apos;, 2) // 8parseInt(&apos;1000&apos;, 6) // 216parseInt(&apos;1000&apos;, 8) // 512 上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。 12345parseInt(&apos;10&apos;, 37) // NaNparseInt(&apos;10&apos;, 1) // NaNparseInt(&apos;10&apos;, 0) // 10parseInt(&apos;10&apos;, null) // 10parseInt(&apos;10&apos;, undefined) // 10 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。 12parseInt(&apos;1546&apos;, 2) // 1parseInt(&apos;546&apos;, 2) // NaN 上面代码中，对于二进制来说，1是有意义的字符，5、4、6都是无意义的字符，所以第一行返回1，第二行返回NaN。 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。 12345678910parseInt(0x11, 36) // 43parseInt(0x11, 2) // 1// 等同于parseInt(String(0x11), 36)parseInt(String(0x11), 2)// 等同于parseInt(&apos;17&apos;, 36)parseInt(&apos;17&apos;, 2) 上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。 这种处理方式，对于八进制的前缀0，尤其需要注意。 1234567parseInt(011, 2) // NaN// 等同于parseInt(String(011), 2)// 等同于parseInt(String(9), 2) 上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt(&#39;011&#39;, 2)，011则是会被当作二进制处理，返回3。 JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。 7.5 parseFloat()parseFloat方法用于将一个字符串转为浮点数。 1parseFloat(&apos;3.14&apos;) // 3.14 如果字符串符合科学计数法，则会进行相应的转换。 12parseFloat(&apos;314e-2&apos;) // 3.14parseFloat(&apos;0.0314E+2&apos;) // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 1parseFloat(&apos;3.14more non-digit characters&apos;) // 3.14 parseFloat方法会自动过滤字符串前导的空格。 1parseFloat(&apos;\t\v\r12.34\n &apos;) // 12.34 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。 123parseFloat([]) // NaNparseFloat(&apos;FF2&apos;) // NaNparseFloat(&apos;&apos;) // NaN 上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。 这些特点使得parseFloat的转换结果不同于Number函数。 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat(&apos;&apos;) // NaNNumber(&apos;&apos;) // 0parseFloat(&apos;123.45#&apos;) // 123.45Number(&apos;123.45#&apos;) // NaN 3.4.5 字符串（String）1.定义字符串就是零个或多个16位Unicode字符排在一起的字符序列，放在单引号或双引号之中。 12&apos;abc&apos;&quot;abc&quot; 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 12&apos;key = &quot;value&quot;&apos;&quot;It&apos;s a long journey&quot; 上面两个都是合法的字符串。 如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。 12345&apos;Did she say \&apos;Hello\&apos;?&apos;// &quot;Did she say &apos;Hello&apos;?&quot;&quot;Did she say \&quot;Hello\&quot;?&quot;// &quot;Did she say &quot;Hello&quot;?&quot; 由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。 字符串默认只能写在一行内，分成多行将会报错。 1234&apos;abc&apos;// SyntaxError: Unexpected token ILLEGAL 上面代码将一个字符串分成三行，JavaScript 就会报错。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234567var longString = 'Long \long \long \string';longString// "Long long long string" 上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 1234var longString = 'Long ' + 'long ' + 'long ' + 'string'; 如果想输出多行字符串，有一种利用多行注释的变通方法。 12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split('\n').slice(1, -1).join('\n')// "line 1// line 2// line 3" 上面的例子中，输出的字符串就是多行 2. 转义反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 需要用反斜杠转义的特殊字符，主要有下面这些。 \0 ：null（\u0000） \b ：后退键（\u0008） \f ：换页符（\u000C） \n ：换行符（\u000A） \r ：回车键（\u000D） \t ：制表符（\u0009） \v ：垂直制表符（\u000B） \&#39; ：单引号（\u0027） \&quot; ：双引号（\u0022） \\ ：反斜杠（\u005C） 上面这些字符前面加上反斜杠，都表示特殊含义。 123console.log(&apos;1\n2&apos;)// 1// 2 上面代码中，\n表示换行，输出的时候就分成了两行。 反斜杠还有三种特殊用法。 （1）\HHH 反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\251表示版权符号。显然，这种方法只能输出256种字符。 （2）\xHH \x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\xA9表示版权符号。这种方法也只能输出256种字符。 （3）\uXXXX \u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\u00A9表示版权符号。 下面是这三种字符特殊写法的例子。 1234567&apos;\251&apos; // &quot;©&quot;&apos;\xA9&apos; // &quot;©&quot;&apos;\u00A9&apos; // &quot;©&quot;&apos;\172&apos; === &apos;z&apos; // true&apos;\x7A&apos; === &apos;z&apos; // true&apos;\u007A&apos; === &apos;z&apos; // true 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。 12&apos;\a&apos;// &quot;a&quot; 上面代码中，a是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。 如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。 12&quot;Prev \\ Next&quot;// &quot;Prev \ Next&quot; 3. 字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 1234567var s = &apos;hello&apos;;s[0] // &quot;h&quot;s[1] // &quot;e&quot;s[4] // &quot;o&quot;// 直接对字符串使用方括号运算符&apos;hello&apos;[1] // &quot;e&quot; 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 123&apos;abc&apos;[3] // undefined&apos;abc&apos;[-1] // undefined&apos;abc&apos;[&apos;x&apos;] // undefined 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 12345678910var s = 'hello';delete s[0];s // "hello"s[1] = 'a';s // "hello"s[5] = '!';s // "hello" 上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。 12var lang = &quot;Java&quot;;lang = lang + &quot;Script&quot; 实现这个操作的过程如下：首先创建一个能容纳10个字符的新字符串然后在这个新字符串中填充&quot;Java&quot;和&quot;Script&quot;，最后一步是销毁原来的&quot;Java&quot;和&quot;Script&quot; 字符串。 5. 转换字符串String函数可以将任意类型的值转化成字符串，转换规则如下。 （1）原始类型值 数值：转为相应的字符串。 字符串：转换后还是原来的值。 布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;。 undefined：转为字符串&quot;undefined&quot;。 null：转为字符串&quot;null&quot;。 12345String(123) // "123"String('abc') // "abc"String(true) // "true"String(undefined) // "undefined"String(null) // "null" （2）对象 String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。 12String(&#123;a: 1&#125;) // &quot;[object Object]&quot;String([1, 2, 3]) // &quot;1,2,3&quot; String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。 先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果valueOf方法返回的是对象，就报错。 下面是一个例子。 123456String(&#123;a: 1&#125;)// &quot;[object Object]&quot;// 等同于String(&#123;a: 1&#125;.toString())// &quot;[object Object]&quot; 上面代码先调用对象的toString方法，发现返回的是字符串[object Object]，就不再调用valueOf方法了。 如果toString法和valueOf方法，返回的都是对象，就会报错。 1234567891011var obj = &#123; valueOf: function () &#123; return &#123;&#125;; &#125;, toString: function () &#123; return &#123;&#125;; &#125;&#125;;String(obj)// TypeError: Cannot convert object to primitive value 下面是通过自定义toString方法，改变返回值的例子。 1234567891011121314151617181920212223String(&#123; toString: function () &#123; return 3; &#125;&#125;)// "3"String(&#123; valueOf: function () &#123; return 2; &#125;&#125;)// "[object Object]"String(&#123; valueOf: function () &#123; return 2; &#125;, toString: function () &#123; return 3; &#125;&#125;)// "3" 上面代码对三个对象使用String函数。第一个对象返回toString方法的值（数值3），第二个对象返回的还是toString方法的值（[object Object]），第三个对象表示toString方法先于valueOf方法执行。 4. length 属性length属性返回字符串的长度，该属性也是无法改变的。 12345678var s = 'hello';s.length // 5s.length = 3;s.length // 5s.length = 7;s.length // 5 上面代码表示字符串的length属性无法改变，但是不会报错。 3.5 操作符操作符是用来操作数据值的。 3.5.1 一元操作符 只能操作一个值的操作符。 1. 递增和递减操作符借鉴C语言，前置性和后置型。（前置自增减，后置自增减） 12var age = 29;++age; 与下面效果相同 12var age = 29;age = age + 1; 自增减操作与执行语句的优先级相等 1234var num1 = 2;var num2 = 20;var num3 = --num1 + num2; // 21 var num4 = num + num2; // 21 第三行等同于： 12var num1 = 2 - 1 ;var num3 = num1 + num2; // 21 本操作符对任何值都适用，将非数值转化为数值。 2. 一元加和减操作符（与加性操作符进行区别） 数值的正负 把非数值转换为数值，与Number函数的作用相同。 1234var s1 = "01";var s2 = "z";s1 = +s1; //值变为数值1s2 = +s2; //值变为NaN 3.5.2 位操作符位运算符用于直接对二进制位进行计算，一共有7个。 js中数值以64位存储，但位操作先将64位转为32位进行操作再将结果转回64位。NaN和Infinity值应用位操作时，被当为0来处理。位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。 二进制或运算符（or）：符号为|，表示若两个二进制位都为0，则结果为0，否则为1。 二进制与运算符（and）：符号为&amp;，两个二进制位都为1，则结果为1，否则为0。 二进制否运算符（not）：符号为~，表示对一个二进制位取反。 异或运算符（xor）：符号为^，二进制位不相同，则结果为1，否则为0。 左移运算符（left shift）：符号为&lt;&lt;， 将数值所有位向左移指定的位数。 右移运算符（right shift）：符号为&gt;&gt;，保留符号位右移。 带符号位的右移运算符（zero filled right shift）：符号为&gt;&gt;&gt;。 对于有符号的整数，前31位表示数值，32位表示数值的正负：0正，1负。这个位置叫符号位。负数同样用二进制码存储，但是使用的是二进制补码。 比如-18的二进制码，先求得18的二进制码，变为反码，反码加1. 按位非（not） ~25 -26 按位与（and） 23 &amp; 3 1 左移 2 &lt;&lt;4 (2:二进制10，移4位100000) 64 按位异（xor） 25 ^ 3 26 3.5.3布尔操作符布尔运算符用于将表达式转为布尔值，一共包含四个运算符。 取反运算符：! 逻辑非 且运算符：&amp;&amp; 逻辑与 或运算符：|| 逻辑或 三元运算符：?: 1. 取反运算符（!）取反运算符是一个感叹号，用于将布尔值变为相反值，即true变成false，false变成true。 12!true // false!false // true 对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。 undefined null false 0 NaN 空字符串（&#39;&#39;） 2. 且运算符（&amp;&amp;）且运算符（&amp;&amp;）往往用于多个表达式的求值。 它的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。 3. 或运算符（||）或运算符（||）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。 4. 三元条件运算符（?:）三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。 3.5.4 乘性操作符三个： 乘法* 除法/ 求模% 乘法如果不是数值，后台会先使用Number（）函数转化为数值。 特殊值： 乘积超过数值范围则返回Infinity或-Infinity 一个是NaN，结果为NaN Infinity*0=NaN Infinity与非零相乘则Infinity或-Infinity Infinity*Infinity=Infinity。 除法 一个是NaN，结果为NaN Infinity / Infinity=NaN 0/0=NaN 3.5.5 加性操作如果其中一个为字符串，则进行拼接。 3.5.6 关系操作符在操作字符串时，比较的是字符串首位字符编码值。 12var result = "23" &lt; "3" //true var result = "Brick" &lt; "alphabet" // true “2”的字符编码50，“3的字符编码”51. B 的编码值66，a是97. javaScript 一共提供了8个比较运算符。 &lt; 小于运算符 &gt; 大于运算符 &lt;= 小于或等于运算符 &gt;= 大于或等于运算符 == 相等运算符 === 严格相等运算符 （不进行转换） != 不相等运算符 !== 严格不相等运算符 3.5.7 逗号操作符逗号操作符多用于声明多个变量；但除此之外还可以用于赋值，用于赋值时总会返回表达式中的去最后一项。 1var num = (5, 1, 4, 0); //num 的值为0。 指数运算符指数运算符（**）完成指数运算，前一个运算子是底数，后一个运算子是指数。 12 ** 4 // 16 赋值运算符赋值运算符（Assignment Operators）用于给变量赋值。 最常见的赋值运算符，当然就是等号（=）。 1234567891011121314151617// 等同于 x = x + yx += y// 等同于 x = x - yx -= y// 等同于 x = x * yx *= y// 等同于 x = x / yx /= y// 等同于 x = x % yx %= y// 等同于 x = x ** yx **= y 3.6 语句3.6.1 条件语句JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。 ifif代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。 if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 12345if (m === 3) &#123; // 满足条件时，执行的语句&#125; else &#123; // 不满足条件时，执行的语句&#125; 对同一个变量进行多次判断时，多个if...else语句可以连写在一起。 123456789if (m === 0) &#123; // ...&#125; else if (m === 1) &#123; // ...&#125; else if (m === 2) &#123; // ...&#125; else &#123; // ...&#125; else代码块总是与离自己最近的那个if语句配对。 123456var m = 1;var n = 2;if (m !== 1)if (n === 2) console.log('hello');else console.log('world'); 上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。 1234567if (m !== 1) &#123; if (n === 2) &#123; console.log('hello'); &#125; else &#123; console.log('world'); &#125;&#125; 如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。 12345678if (m !== 1) &#123; if (n === 2) &#123; console.log('hello'); &#125;&#125; else &#123; console.log('world');&#125;// world switch多个if...else连在一起使用的时候，可以转为使用更方便的switch结构。 12345678910switch (fruit) &#123; case "banana": // ... break; case "apple": // ... break; default: // ...&#125; 上面代码根据变量fruit的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。 需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。 3.6.2 循环语句循环语句用于重复执行某个操作，它有多种形式 while 循环While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。 如果只有一条语句，可以省略大括号，否则就必须加上大括号。 123while (条件) &#123; 语句;&#125; for 循环for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下 123for (初始化表达式; 条件; 递增表达式) &#123; 语句&#125; 初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。 条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。 递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量 省略了for语句表达式的三个部分，结果就导致了一个无限循环。 for-infor-in 语句是一种精准的迭代语句，可以用力枚举对象的属性。 123for(property in expression)&#123; statement&#125; do…while 循环do…while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 123do &#123; 语句&#125; while (条件); 3.7 函数通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。ES中通过function关键字来声明，后跟一组参数及函数体。基本语法如下： 123function functionName (arg0,arg1......argN)&#123; statemnets&#125; 理解参数ES函数不介意传入参数的个数，类型，因为参数在内部使用一个数组表示，无论参数怎样，函数接收的始终是这个数组，而不关心具体参数。在函数体内部可通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数， 没有重载在其他语言中，可以为一个函数编写两个定义，只要定义的签名（接受的参数类型和数量）不同即可。而ES函数没有签名，即其参数是以数组的形式进行表示，所以不可能做到真正意义的重载。 回顾： 额，图片不清楚，不想转换格式了，就酱。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html与css碎点]]></title>
    <url>%2Fnote%2F2018%2Fundefined11%2F528414c2.html</url>
    <content type="text"><![CDATA[1.引入css样式表 行内式（内联式） &lt;标记名 style=&quot;属性1：属性值1； 属性2：属性值2；&quot;&gt; 内容&lt;/标记名&gt; 内嵌式 &lt;style type=&quot;text/css&quot;&gt; 选择器{属性1：属性值1；} &lt;/style&gt;可放在文档的任何地方，浏览器从上至下解析代码 嵌入式&lt;link href =&quot;css文件路径&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; 需放在&lt;head&gt;部分 导入式 在head部分应用style，并在style标记内开头处使用@import “css文件路径”。与链入式功能基本相同，但链入式与页面同时加载，而导入式是页面加载完后，再被加载。import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 2.选择器伪类的a伪类没有行内式。 &lt;a style=&quot; :hover: red;&quot;&gt;&lt;/a&gt; 2.1常见选择器 (1):nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素 (2):nth-of-type(n), p:nth-of-type(2) 选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 (3) div p 选择 &lt;div&gt; 元素内部的所有 &lt;p&gt; 元素。 (4) div&gt;p 选择父元素为 &lt;div&gt; 元素的所有 &lt;p&gt; 元素。 (5)div+p 选择紧接在 &lt;div&gt; 元素之后的所有 &lt;p&gt; 元素。 不要在属性值与单位之间留有空格。假如你使用 “margin-left: 20 px” 而不是 “margin-left: 20px” ，它仅在 IE 6 中有效，但是在 Mozilla/Firefox 或 Netscape 中却无法正常工作。 3.&lt;DOCTYLE&gt;&lt;!DOCTYPE&gt; 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的.DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 4.元素 （1）行内元素有：a b span img input select strong（强调的语气 （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p （3）常见的空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; (4)b与strong，i与em (1)Physical Style Elements – 自然样式标签： b, i, u, s, pre (2)Semantic Style Elements – 语义样式标签： strong, em, ins, del, code (3)title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响； 5浏览器内核 6.html语义化（1）用正确的标签做正确的事情。 （2）html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; （3）即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; （4）搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; （5）使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 7.HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 SGML 是一种很强大但很复杂的标记语言，HTML、XML 就是从中衍生出来的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[float与清除浮动]]></title>
    <url>%2Fnote%2F2018%2Fundefined11%2F5216f308.html</url>
    <content type="text"><![CDATA[float float的设计初衷是为了文字环绕效果，会让父元素高度塌陷。 块级元素之所以会单独占据一行是因为它们前后默认有换行符（假设，为更好理解块级元素），当进行浮动时，会把换行符去掉 在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。因此，对于内联元素，如果设置为浮动，会产生和块级框相同的效果。脱离了标准文档流，但仍在文档流中。文字和行级元素会环绕该元素，块级元素则不受影响。浮动元素的margin（外边距）不会与其他元素的margin合并，可与浮动元素的margin合并。 利用浮动与列表的结合可创建水平菜单 http://www.w3school.com.cn/tiy/t.asp?f=csse_float5 display:block 填充父元素整行（即使设置width小于父元素可填充宽度也会占据整行），高度可调正。 display:inline 宽度高度都不可调整 display: inline-block; 不会占据父元素整行，宽高都可调整 display:none和visible:hidden都能把网页上某个元素隐藏起来，但两者有区别: display:none —不为被隐藏的对象保留其物理空间，即该对象在页面上彻底消失，通俗来说就是看不见也摸不到。 visible:hidden— 使对象在网页上不可见，但该对象在网页上所占的空间没有改变，通俗来说就是看不见但摸得到 参考https://www.cnblogs.com/nicholas_f/archive/2009/03/27/1423207.html 清除浮动通过空标签在容器的结束标签前添加一个空标签，在空标签上直接设置样式“clear:both”。用这种方法来清除浮动，在大多数情况下是有效的，但这不太适合语义化。这取决于一个页面有多少浮动需要清除，这样造成页面上的空标签迅速堆积，而且在页面中没有上下文内容。 当 父 包 含 块 缩 成 一 条 时 ， 用 clear ： both 方 法 清 除 浮 动 无 效 ，它 一 般 用 于 紧 邻 后 面 的 元 素 的 清 除 浮 动。 通过overflow:hidden在具有浮动元素的父容器中设置“overflow”的属性值为“auto”在ie6里会有浮动条所以用hidden。父元素要有宽度，如果不是定宽时，width不可为100%，overflow：hidden会使元素BFC化，div内任何元素无论怎么折腾都是在内部，不会影响div外面的元素，而clearboth，则不会，仍可与外界margin进行纠缠。BFC(Block formatting context ) 块级格式化上下文 BFC触发条件 根元素或其它包含它的元素 浮动 (元素的 float 不是 none) 绝对定位的元素 (元素具有 position 为 absolute 或 fixed) 非块级元素具有 display: inline-block，table-cell, table-caption, flex, inline-flex 块级元素具有overflow ，且值不是 visible 通过伪元素clearfix”技巧是基于在父元素上使用“:before”和“:after”两个伪元素。使用这些伪元素，我们可以在浮动元素的父容器前面和后面创建隐藏元素。（:before 选择器在被选元素的内容前面插入内容。）“:before”伪元素是用来防止子元素顶部的外边距塌陷，使用“display: table”创建一个匿名的“table-cell”元素。这也确保在IE6和IE7下具有一致性。“:after”伪元素是用来防止子元素的底部的外边距塌陷，以及用来清除元素的浮动。 在IE6和7的浏览器中，加上“*zoom”属性来触发父元素的hasLayout的机制。决定了元素怎样渲染内容，以及元素与元素之间的相互影响。 #box:after {clear:both; content:&apos; &apos;; display:table; } #box{ *zoom: 1;} 伪类与伪元素 .:before/:after伪元素是在css2中提出来的。而::before/::after是在css3中的写法，这样从新提出是为了用两个冒号表示伪元素以区分伪类。 伪元素 它们用在css里某个选择器之后，为了增添装饰性内容的，因为这样可以实现语义化，如果用html来添加一些没有实际内容的节点或者辅助式样本的文本，他们是毫无意义的。 创建的伪元素默认是在所依附的元素之上的，我们可以使用z-index:-1;把它放到下面去。伪元素用于创建一些不在文档树中的元素，并为其添加样式。实际上不在文档树中。 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。 详细可参AlloyTeam：http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/ float与清除浮动xmind总结]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏式布局]]></title>
    <url>%2Fnote%2F2018%2Fundefined10%2F85f5447b.html</url>
    <content type="text"><![CDATA[左右两栏宽度固定，中间主体宽高自适应 通过margin1#center{ width:100%; } #center #c-inner { margin: 0 210px; float: left; } #left{ width: 200px; background-color: orange; margin-left: -100%; float: left; } #right{ width: 200px; background-color: purple; margin-left: -200px; float: left; } 注意： 盒子的顺序center-left-right center的width：100%不可少，否则当文字较少时，便无法撑起盒子#c-inner的横排空间。 通过margin2#left{ width: 200px; background-color: orange; float: left; } #center{ width:100%; float: left; margin:0 -210px 0 -210px; } #center #c-inner { margin: 0 210px; } #right{ width: 200px; background-color: purple; float: left; } 注意： 盒子顺序：left-center-right 盒子默认继承父元素的宽（是整个盒子模型等于父元素的宽，即当padding，margin增加时会挤压内容区），，若指明继承为width：100%。则，盒子的内容区为父元素的宽，也就是说，内容区的宽固定了，在增加padding，只会增大盒子模型而内容区不变，此时，padding的增加是从左向右即padding会造成盒子增大，内容区移动。 box-sizing 其属性值有两个。 content-box | border-box content-box默认值，标准盒子模型。宽高计算包含盒子的border和padding。 border-box宽高只包括内容区。 通过绝对定位#left{ width: 200px; position: absolute; top: 0; left: 0; } #c-inner { margin: 0 210px; } #right{ width: 200px; position: absolute; top: 0; right: 0; } 注意： 父元素高度取决于中间部分的高度，当两侧高度大于中间高度时，则出现高度塌陷，除非指定父元素的高度，当两侧高度小于中间部分时，可以使用。（且塌陷的父元素，无法利用清除浮动撑起来。因为这是定位，不是浮动，无法清除） 通过padding在margin1的基础上，去掉#c-inner的margin，在三个盒子的父元素加padding，left和right通过相对定位，移动至padding空白处。 通过flex布局参考http://www.cnblogs.com/ljchow/archive/2010/07/27/1785632.html http://ife.baidu.com/note/detail/id/666 彩蛋：position]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素的居中]]></title>
    <url>%2Fnote%2F2018%2Fundefined09%2F8fedc92a.html</url>
    <content type="text"><![CDATA[水平垂直居中方法一：.box { width: 400px; height: 200px; background-color: #ccc; margin: auto; position: absolute; left:0; top:0; bottom:0; right:0; } 方法二：引入transform.box { width: 400px; height: 200px; background-color: #ccc; margin: auto; position: absolute; /* 这里要明白绝对定位的50%相对父元素，下面translate50%是盒子box的50% */ left:50%; top:50%; transform: translate(-200px, -100px ) /* 宽高的1/2，另外可用transform: translate(-50%, -50%)替换，效果是一样的*/ transform 通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数。 通过 rotate() 方法旋转，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。 通过 scale() 方法缩放，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数：值 scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。 通过 skew() 方法倾斜，元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数：值 skew(30deg,20deg) 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。 matrix() 方法把所有 2D 转换方法组合在一起。matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 transform: skew(30deg,20deg); skewX(angle) skewY(angle) transform-origin 属性允许您改变被转换元素的位置 2D 转换元素能够改变元素 x 和 y 轴。3D 转换元素还能改变其 Z 轴。 方法三：与方法二相比用margin取代transform.box { width: 400px; height: 200px; background-color: #ccc; position: absolute; left:50%; top:50%; margin-left:-200px; /*这里的-200px不能用-50%所替代*/ margin-top:-100px; } 方法四：弹性布局Flex以下放在所要居中的div父元素中，父元素必须有高度 divpare { height: 800px; display: flex; justify-content: center; align-items: center; } 水平居中参照水平垂直居中： margin：0 auto； left:50%; margin-left:-width/2;或者 transform: translateX(-width·/2) 更多方法请参照https://www.w3cplus.com/css/vertically-center-content-with-css 彩蛋：框模型]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《影响力》]]></title>
    <url>%2Fnote%2F2018%2Fundefined06%2Fb85ac64d.html</url>
    <content type="text"><![CDATA[《影响力》【美】 罗伯特.西奥迪尼 著 陈叙 译 中国人民大学出版社 首先这本书还是挺实用的，讲了生活中常见的坑以及应该如何避开别人挖的坑。这本书被营销领域吹得挺厉害的，对此书的评价在结尾处聊。 太多字的思维导图不是很适合阅读，所以全图就不传了 第一章影响力的武器固定性为模式：黄鼠狼是火鸡的天敌。每当它们靠近时火鸡妈妈就会发出愤怒的叫声，对它们又啄又抓，即使用绳子拉着黄鼠狼标本去接近火鸡妈妈，也会立刻遭到他们猛烈地攻击。然而在同样的黄鼠狼标本内放入一个能发出“吱吱声”的小录音机，火鸡妈妈不仅会接受它正在靠近，而且还会把它拢在自己身下。一旦把收音机关上，黄鼠狼标本马上又会遭到凶猛的攻击。它会虐待甚至杀死自己的亲生孩子，也仅仅因为它没能发出这种叫声。这种盲目机械的，有规律的行为模式被称为“固定性为模式”。 1.1 有效请求帮助—–人性惯性当我们请别人帮忙时，如果能讲出一个理由，我们得到别人帮助的可能性会更大 对不起，我有五页纸要复印，能不能让我先复印呢？因为我要复印几页纸。 93% 对不起，我有五页纸要复印，能不能让我先复印啊？因为我有急事。 成功率94%。 对不起，我有五页纸要复印，能不能让我先复印呢？ 60% “因为”一词触发了下意识顺从反应，人性惯性 1.2 低廉的的绿松石提升价格反而销售一空—–“价高=质优” 人生生活经验1.3 对比原理—–人自身的存在缺陷 看过貌美的明星后会觉得相貌平平的异性更丑 一只手放进凉水，一只手放进热手。然后一起放进常温的水里，两只手的的感觉是一凉一热 推销商品时，先推销贵的，之后再推销便宜的，让人有实惠的感觉。（买车，再推销花哨的装饰） 买房时，销售会先带你看几套又破又贵的房子，然后其它普通的房子显得更加有吸引力 这个对比前后的感觉差异是人自身的存在缺陷 生活中注意以上三个方面被人挖的坑，解决方法暂无。可以尝试下反人性，比如不贪小便宜，做个nice的人。当然谙熟人性，是一种能力，能力本身是没有对错的。由于生活节奏比较快，没有精力与能力对每件事亲自认识和分析，我们仍需要一些不假思索的下意识反应。 第二章互惠2.1 人类社会从互惠原理中获得了重要的竞争优势，因此我们每个人都知道，遵循这个原理就会得到社会认可，否则就会得到人们的嘲弄。拥有如此巨大社会认同，难免会被人加以利用 先送你一朵花，然后让你买东西 让你免费试吃，然后你感觉不好意思，就买了些东西。 海尔售后维修人员服务态度超好，行为超规范，会让人感觉到受了那么一丝丝恩惠，想再买一台海尔或者对人宣传海尔真是好。 2.2 让步 精髓就是鲁迅说的中国人爱折中。说借我一百元，被拒。接着那借我五十元。。在使用的过程中要注意第一步提出的要求不能太过分，要在情理之中，否则效果会适得其反。 让你买一百元的电影票，拒绝。（人已拒绝常会想补偿的心理）接着对提出请求你买无缘的巧克力，遂买。被跳坑。 互惠简单说就是吃人家嘴软，拿人家手短，人情往来。解决办法：最好就是不接受，但是不现实，可能会误伤些好心。为此首先要明白一种行为或恩惠是情理还是销售手段。对于情理当然需要另一个人情来回报，否侧就把恩惠与事情独立分开看，该拒绝就拒绝，不要被人用道德捆绑。最后现实生活肯定要复杂的多的多，祝好各位。 第三章承诺和一致3.1 一致性原理。一旦我们做出某个决定，某个承诺，或选择了某个立场，就会面对来自个人和外部的压力迫使我们的言行与它保持一致。在大多数情况下，保持一致都是一种最具适应性、最受尊重的行为。和互惠一样，个人观点被主流看法所挟持，进而所形成的一种巨大人性惯性。 言行一致的心理惯性 赌马者一旦下注，就对自己买的那匹马信心大增 选择了一个渣男，还安慰自己男票可好了。 东西放在一个地方，被人拿走时，20有4个出来制止。当告诉旁人帮帮照看下时，20有19个人出来制止。 家长答应孩子去买最近最火的玩具，商家故意缺货，在玩具店暂时买了其他玩具作为替代。等到玩具销售季节过去，最火的玩具开始供货，由于家长已答应孩子买那种玩具，进而保持营销的连贯性 思维一致 有时让我们逃避思考的不是思考过程的艰辛，而是思考得出的严重后果。这种压力加上机械性的保持一致，它能为我们提供一个暂时躲避烦恼的堡垒，从而让理性失效。 比如：你抓住了悬崖旁边的一根被老鼠咬过的藤绳，幻想它怎样都不会断 3.2承诺的惯性问：你好吗。答：好啊。问：买个彩票好吗？惯性回答：好啊。 先来小请求（诱敌上钩，操纵一个人的自我形象），再来大请求。 请在：支持美化环境的请愿书上签字。。给你一个良好的市民形象。。之后说要里一个安全驾驶的大牌子。（内心想：我是一个良好市民，应当同意） 3.3如何让承诺更有效力3.3.1书面承诺 物质证据，也可用来说服他人。 减少退货率：让购买人自己签署购买合同。 各大公司发起的征文比赛，用来吹捧自家产品。 进而大众逐渐相信自己所想来的产品优点， 履行一个承诺所要付出的努力越多，对许诺者的影响力越大。（人们更珍惜来之不易的东西） 许多大公司的面试难度非常大，当面试成功者一般更不愿离职，对团体的认同感更大。（内心os：能面试进来的都是精英） 3.3.2内心主动的选择 A对一些小朋友说：“你不能玩某个玩具B，玩它是不对的。如果你敢玩，我就会打你”。结果当时没人敢玩，过了几个星期后，A离开了学校，让小朋友自愿选择玩具时，77%的人拿了玩具B。 A又对另一批小朋友说：“玩玩玩具B是不对的”。几个星期后，大多数人都没人拿那个玩具。（想想怎么教育孩子，劝说孩子说让孩子觉察到的外部压力越少越好，不容易） 买车时，刚开始给个诱饵，说车的价钱比外面便宜四五百。首先让你喜欢在这买车，后来找个借口把诱饵拿掉。（但我们已被自己说服） 3.4 避免被坑 感受自己胃及身体做出的反应，听从内心。把诱饵，被赋予的形象拿掉后，自己会怎样做 第四章社会认同4.1 社会认同原理的本质：我们进行是非判断的标准之一就是看别人怎么想的，尤其是当我们决定什么是正确的行为的时候。精髓：只有大约5%的人是原创者，而其他95%的人都是模仿者。我们从众，进而成为盲流。 配音笑声：来大家一起尬笑啊。 酒吧侍者会在托盘上放上几张钞票假装是前面的顾客留下的。 帮助有恐惧症的人摆脱恐惧心理：小男孩怕狗，每天花二十分钟观看一个小男孩高兴地与狗玩耍的情景。4天后，67%的儿童愿意与狗玩耍。观看电影片段也有同样的效果。 2012是世界末日预言失败。加入当这个预言是某个宗教预言时，当预言失败时，一般宗教会解散，也有宗教通过疯狂接受教众，为其信仰建立一个认同体系（认同某种观念的人越多，这种观念就越正确）。 4.2 社会认同原理的影响力在不确定性与相似性情况下威力巨大 4.2.1 不确定性。当我们对自己缺乏信心时，当形势不是很明朗时，当不确定性占上风时，我们有可能并参照别人的行为。 当一名受害者在痛苦中苦苦挣扎着需要帮助时，众多的旁观者却没有一个伸出援手。 首先我们都喜欢在众人面前表现的泰然自若，老成持重。其次，当旁人众多时，每个人的责任感都在下降，认为“其他人会帮忙，其他人已经这样做了”。所以当你前面的人，无视的路过一名受害者时，你大概率会跟着无视。混乱，人口稠密，认识率低这样的城市环境，扩大了这种不确定性，显得城市感情疏离。在农村，基本都相互认识，判断都比较明确。更有效的呼救，让别人明确自己的情况，可直接喊help等，更进一步，对着一个人，盯着他，指着他，直接对他提出明确的请求。如果对着大众呼救，每个人都以别人会帮忙的，反而降低成功率。 当领导者教徒去自杀时，自身大多会参考其它教众的做法，所以有时出大家一起殉道吧。 4.2.2相似性 年轻人自杀报道增多时，会有更多年轻人自杀事故。当大学生自杀报道增多时，同理。同时有一些自杀者，由于一些原因会让自杀看起来更不像自杀。比如马航事件，就有人怀疑是智慧老练的机长，想自杀，然后拉了一堆人陪葬。当然我本然更愿意相信它飞往了异度空间，不久就会飞回来。 第五章 喜好5.1 原理：人们总是愿意答应自己认识和喜爱的人提出的请求。在销售某种商品时说，某某（你认识的人）已经买过了。或者说某某推荐我来的。所以类似，买东西时有人说你能推荐你认识的你认为会喜欢这款商品的人吗？不能，这是在消耗社会关系。 5.2 增加被喜好的因素5.2.1 外表的吸引力颜值即正义，对于长得好看的人人们自然联想到美好的品质。 5.2.2 相似性。 我们喜欢那些与我们相似的人，不管他们是在观点上，个性上，穿着喜好兴趣上，背景上，还是生活方式上与我们相似。 销售人员会模仿客户的姿势、语气以及说话风格。 以及平时所说的一见钟情，知己啦，除了长得好看以外。也许我们看到了更多的相似性。 5.2.3 称赞 拍马屁，人类的天性。要迎合的有技巧。 5.2.4 接触与合作 人们倾向于喜欢熟悉的东西。 在一处选举中，被选举人把自己的名字改为了常见的名字。 在写电子邮件时注意把握对方的语言用词习惯。 有人希望种族融合，黑人和白人一起上学。但是由于他们的接触带有学习上的竞争性，结果反而更加讨厌。通过增加一些“合作学习”来解决。对于有共同方向与目标或者有共同利益的的群体，更容易互生好感。 5.2.5 关联人们不喜欢坏消息，所以连带着憎恨带来坏消息的人。 讨厌一个人，进而讨厌一群人。 厂家总是希望自己的商品与美好的事物联系在一起。什么，我的商品请明星代言，我的商品有有文化内涵，我的商品纯天然啦。 销售人员有时请客户吃大餐的一个原因是客户会把对大餐的喜爱转到销售人员身上。 当我们喜欢的球队胜利时，我们会标榜我们是粉丝。当失败时，大都沉默。同时，我们也会标榜我们读过什么书，喜欢什么人，和谁谁很厉害我认识。意图把美好的品质转移到自己身上。 5.3 解决办法：交易是交易，感情是感情。当我们在短时间内，对一个人的好感反常的好时，要特别注意。第六章 权威李开复曾经说道，好多学生来信要求他给他们指点人生的发展道路。过于迷信权威，也在一定程度解释了好多无法想象的行为，也许都只是服从了一个权威的命令 典型的权威标志 头衔 一些医生明显的开错药方，护士有能力分辨时，却依然选择沉默服从； 衣着：警服等行业服装 外部标志：定制西装，名车…… 等红灯时，前面时豪车会比较耐心。一般的车会忍不住按喇叭。 第七章 短缺爱一样东西的方法就是意识到你可能会失去它 喜好，购买，抉择时不因外在条件与环境怎样。要关注本质。假如未来人们拉的粑粑越来越少，有些人会不会去买？ 个人评价感觉就是一本心理学应用。对心理研究的态度，和对技术以及隐私权的的态度挺像的，就是工具本身没有利弊，在于用的人。 本书的总结可以说：人是社会人，为了维护形象会有固定的行为模式，进而被别有用心的人挖坑。 即使没有看过这本书，我想对于有一定社会经验的人，对这些套路也都很熟悉。有些人，可能一字不识，但他们仍对这社会，这亘古的人性有通透的认识。听些不识字的阿姨拉家常，感觉我只是看了些名词，而本质以及应用远不及叔叔阿姨。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bgcolor与background-color]]></title>
    <url>%2Fnote%2F2018%2Fundefined24%2F2107d71c.html</url>
    <content type="text"><![CDATA[归属不同bgcolor 属于 html标签，更确切的说属于body标签。因为当作用于其他大多数标签时不起作用。但当用于table标签时有作用，至于什么原理，还请聪明的你告诉我。而background-color属于css标签。当然css是大趋势，都用css是最好的。 &lt;html&gt; &lt;body bgcolor=&apos;blue&apos;&gt; &lt;h1 style=&apos;background-color:purple&apos; &gt;春天在哪里&lt;/h1&gt; &lt;h2 bgcolor=&apos;purple&apos;&gt;春天在哪里&lt;/h2&gt; &lt;table bgcolor=&apos;red&apos;&gt; &lt;tr&gt; &lt;td&gt;春天在哪里&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 运行以上代码可看出h2并未变成紫色。 注意 属性值务必用英文状态下的字符 。比如&#39;red&#39;，否则目标不会显示红色，而会突变为其他色。 html 的势力范围很明显要比body的势力范围大。（html是页面所到之处，body是内容主体所到之处）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
</search>
