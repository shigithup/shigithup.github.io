<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[html与css碎点]]></title>
    <url>%2Fnote%2F2018%2Fundefined11%2F528414c2.html</url>
    <content type="text"><![CDATA[1.引入css样式表 行内式（内联式） &lt;标记名 style=&quot;属性1：属性值1； 属性2：属性值2；&quot;&gt; 内容&lt;/标记名&gt; 内嵌式 &lt;style type=&quot;text/css&quot;&gt; 选择器{属性1：属性值1；} &lt;/style&gt;可放在文档的任何地方，浏览器从上至下解析代码 嵌入式&lt;link href =&quot;css文件路径&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; 需放在&lt;head&gt;部分 导入式 在head部分应用style，并在style标记内开头处使用@import “css文件路径”。与链入式功能基本相同，但链入式与页面同时加载，而导入式是页面加载完后，再被加载。import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 2.选择器 2.1常见选择器 (1):nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 `&lt;p&gt;` 元素 (2):nth-of-type(n), p:nth-of-type(2) 选择属于其父元素第二个 `&lt;p&gt;` 元素的每个 `&lt;p&gt;` 元素。 (3) div p 选择 `&lt;div&gt;` 元素内部的所有 `&lt;p&gt;` 元素。 (4) div&gt;p 选择父元素为 `&lt;div&gt;` 元素的所有 `&lt;p&gt;` 元素。 (5)div+p 选择紧接在 `&lt;div&gt;` 元素之后的所有 `&lt;p&gt;` 元素。 3不要在属性值与单位之间留有空格。假如你使用 “margin-left: 20 px” 而不是 “margin-left: 20px” ，它仅在 IE 6 中有效，但是在 Mozilla/Firefox 或 Netscape 中却无法正常工作。 4&lt;!DOCTYPE&gt; 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的.DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 5元素 （1）行内元素有：a b span img input select strong（强调的语气） （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p （3）常见的空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; (4)b与strong，i与em (1)Physical Style Elements -- 自然样式标签： b, i, u, s, pre (2)Semantic Style Elements -- 语义样式标签： strong, em, ins, del, code (3)title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响； 6浏览器内核 7.html语义化 （1）用正确的标签做正确的事情。 （2）html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; （3）即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; （4）搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; （5）使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 8.HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 SGML 是一种很强大但很复杂的标记语言，HTML、XML 就是从中衍生出来的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[float与清除浮动]]></title>
    <url>%2Fnote%2F2018%2Fundefined11%2F5216f308.html</url>
    <content type="text"><![CDATA[float float的设计初衷是为了文字环绕效果，会让父元素高度塌陷。 块级元素之所以会单独占据一行是因为它们前后默认有换行符（假设，为更好理解块级元素），当进行浮动时，会把换行符去掉 在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。因此，对于内联元素，如果设置为浮动，会产生和块级框相同的效果。脱离了标准文档流，但仍在文档流中。文字和行级元素会环绕该元素，块级元素则不受影响。浮动元素的margin（外边距）不会与其他元素的margin合并，可与浮动元素的margin合并。 利用浮动与列表的结合可创建水平菜单 http://www.w3school.com.cn/tiy/t.asp?f=csse_float5 display:block 填充父元素整行（即使设置width小于父元素可填充宽度也会占据整行），高度可调正。 display:inline 宽度高度都不可调整 display: inline-block; 不会占据父元素整行，宽高都可调整 清除浮动通过空标签在容器的结束标签前添加一个空标签，在空标签上直接设置样式“clear:both”。用这种方法来清除浮动，在大多数情况下是有效的，但这不太适合语义化。这取决于一个页面有多少浮动需要清除，这样造成页面上的空标签迅速堆积，而且在页面中没有上下文内容。 当 父 包 含 块 缩 成 一 条 时 ， 用 clear ： both 方 法 清 除 浮 动 无 效 ，它 一 般 用 于 紧 邻 后 面 的 元 素 的 清 除 浮 动。 通过overflow:hidden在具有浮动元素的父容器中设置“overflow”的属性值为“auto”在ie6里会有浮动条所以用hidden。父元素要有宽度，如果不是定宽时，width不可为100%，overflow：hidden会使元素BFC化，div内任何元素无论怎么折腾都是在内部，不会影响div外面的元素，而clearboth，则不会，仍可与外界margin进行纠缠。BFC(Block formatting context ) 块级格式化上下文 BFC触发条件 根元素或其它包含它的元素 浮动 (元素的 float 不是 none) 绝对定位的元素 (元素具有 position 为 absolute 或 fixed) 非块级元素具有 display: inline-block，table-cell, table-caption, flex, inline-flex 块级元素具有overflow ，且值不是 visible 通过伪元素clearfix”技巧是基于在父元素上使用“:before”和“:after”两个伪元素。使用这些伪元素，我们可以在浮动元素的父容器前面和后面创建隐藏元素。（:before 选择器在被选元素的内容前面插入内容。）“:before”伪元素是用来防止子元素顶部的外边距塌陷，使用“display: table”创建一个匿名的“table-cell”元素。这也确保在IE6和IE7下具有一致性。“:after”伪元素是用来防止子元素的底部的外边距塌陷，以及用来清除元素的浮动。 在IE6和7的浏览器中，加上“*zoom”属性来触发父元素的hasLayout的机制。决定了元素怎样渲染内容，以及元素与元素之间的相互影响。 #box:after {clear:both; content:&apos; &apos;; display:table; } #box{ *zoom: 1;} 伪类与伪元素 .:before/:after伪元素是在css2中提出来的。而::before/::after是在css3中的写法，这样从新提出是为了用两个冒号表示伪元素以区分伪类。 伪元素 它们用在css里某个选择器之后，为了增添装饰性内容的，因为这样可以实现语义化，如果用html来添加一些没有实际内容的节点或者辅助式样本的文本，他们是毫无意义的。 创建的伪元素默认是在所依附的元素之上的，我们可以使用z-index:-1;把它放到下面去。伪元素用于创建一些不在文档树中的元素，并为其添加样式。实际上不在文档树中。 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。 详细可参AlloyTeam：http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/ float与清除浮动xmind总结]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏式布局]]></title>
    <url>%2Fnote%2F2018%2Fundefined10%2F85f5447b.html</url>
    <content type="text"><![CDATA[左右两栏宽度固定，中间主体宽高自适应 通过margin1#center{ width:100%; } #center #c-inner { margin: 0 210px; float: left; } #left{ width: 200px; background-color: orange; margin-left: -100%; float: left; } #right{ width: 200px; background-color: purple; margin-left: -200px; float: left; } 注意： 盒子的顺序center-left-right center的width：100%不可少，否则当文字较少时，便无法撑起盒子#c-inner的横排空间。 通过margin2#left{ width: 200px; background-color: orange; float: left; } #center{ width:100%; float: left; margin:0 -210px 0 -210px; } #center #c-inner { margin: 0 210px; } #right{ width: 200px; background-color: purple; float: left; } 注意： 盒子顺序：left-center-right 盒子默认继承父元素的宽（是整个盒子模型等于父元素的宽，即当padding，margin增加时会挤压内容区），，若指明继承为width：100%。则，盒子的内容区为父元素的宽，也就是说，内容区的宽固定了，在增加padding，只会增大盒子模型而内容区不变，此时，padding的增加是从左向右即padding会造成盒子增大，内容区移动。 通过绝对定位#left{ width: 200px; position: absolute; top: 0; left: 0; } #c-inner { margin: 0 210px; } #right{ width: 200px; position: absolute; top: 0; right: 0; } 注意： 父元素高度取决于中间部分的高度，当两侧高度大于中间高度时，则出现高度塌陷，除非指定父元素的高度，当两侧高度小于中间部分时，可以使用。（且塌陷的父元素，无法利用清除浮动撑起来。因为这是定位，不是浮动，无法清除） 通过padding在margin1的基础上，去掉#c-inner的margin，在三个盒子的父元素加padding，left和right通过相对定位，移动至padding空白处。 通过flex布局参考http://www.cnblogs.com/ljchow/archive/2010/07/27/1785632.html http://ife.baidu.com/note/detail/id/666 彩蛋：position]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素的居中]]></title>
    <url>%2Fnote%2F2018%2Fundefined09%2F8fedc92a.html</url>
    <content type="text"><![CDATA[水平垂直居中方法一：.box { width: 400px; height: 200px; background-color: #ccc; margin: auto; position: absolute; left:0; top:0; bottom:0; right:0; } 方法二：引入transform.box { width: 400px; height: 200px; background-color: #ccc; margin: auto; position: absolute; /* 这里要明白绝对定位的50%相对父元素，下面translate50%是盒子box的50% */ left:50%; top:50%; transform: translate(-200px, -100px ) /* 宽高的1/2，另外可用transform: translate(-50%, -50%)替换，效果是一样的*/ 方法三：与方法二相比用margin取代transform.box { width: 400px; height: 200px; background-color: #ccc; position: absolute; left:50%; top:50%; margin-left:-200px; /*这里的-200px不能用-50%所替代*/ margin-top:-100px; } 方法四：弹性布局Flex以下放在所要居中的div父元素中，父元素必须有高度 divpare { height: 800px; display: flex; justify-content: center; align-items: center; } 水平居中参照水平垂直居中： margin：0 auto； left:50%; margin-left:-width/2;或者 transform: translateX(-width·/2) 更多方法请参照https://www.w3cplus.com/css/vertically-center-content-with-css 彩蛋：框模型]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bgcolor与background-color]]></title>
    <url>%2Fnote%2F2018%2Fundefined24%2F2107d71c.html</url>
    <content type="text"><![CDATA[归属不同bgcolor 属于 html标签，更确切的说属于body标签。因为当作用于其他大多数标签时不起作用。但当用于table标签时有作用，至于什么原理，还请聪明的你告诉我。而background-color属于css标签。当然css是大趋势，都用css是最好的。 &lt;html&gt; &lt;body bgcolor=&apos;blue&apos;&gt; &lt;h1 style=&apos;background-color:purple&apos; &gt;春天在哪里&lt;/h1&gt; &lt;h2 bgcolor=&apos;purple&apos;&gt;春天在哪里&lt;/h2&gt; &lt;table bgcolor=&apos;red&apos;&gt; &lt;tr&gt; &lt;td&gt;春天在哪里&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 运行以上代码可看出h2并未变成紫色。 注意 属性值务必用英文状态下的字符 。比如&#39;red&#39;，否则目标不会显示红色，而会突变为其他色。 html 的势力范围很明显要比body的势力范围大。（html是页面所到之处，body是内容主体所到之处）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
</search>
