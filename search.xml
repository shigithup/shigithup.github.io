<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读《JavaScript高级程序设计》（2）]]></title>
    <url>%2Fnote%2F2018%2Fundefined07%2F9b59a5f6.html</url>
    <content type="text"><![CDATA[[美] Nicholas C.Zakes 著 李松峰 曹力 译 （第三版） 本文以JS高程为主线， 阮一峰的《 JavaScript标准参考教程》为辅。 第四章 变量、作用域和内存问题 第五章 引用类型 第四章 变量、作用域和内存问题本章内容： 理解基本类型和引用类型的值 理解执行环境 理解垃圾收集 4.1 基本类型和引用类型的值基本类型的访问是按值访问的，就是说你可以操作保存在变量中的实际的值。我们不能给基本类型添加属性和方法。 基本类型的值是不可变的： 比如一个字符串： 1var name = 'jozo'; name.toUpperCase(); // 输出 'JOZO' console.log(name); // 输出 'jozo' 会发现原始的name并未发生改变，而是调用了toUpperCase()方法后返回的是一个新的字符串。 4.1.1 复制变量值复制基本类型的值，会在对象变量上创建一个新值，然后把该值复制到为新变量分配的位置上。例： 12var num1 = 5;var num2 = num1; 其过程如下： 复制前的变量值 num1 5（Number类型） 复制后的变量对象 num2 5（Number类型） num1 5（Number类型） 这两个变量可以独立操作而不受任何影响。 复制引用类型的值，会把对象变量的值复制一份，然后把该值放到 到为新变量分配的位置上。例子： 1234var obj1 = new Object();var obj2 = obj1;obj2.name = "我有名字了";console.log(obj1.name); // 我有名字了 由上面例子，我们声明了一个引用数据类型变量obj1，并把它赋值给了另外一个引用数据类型变量obj2。当我们obj2添加了一个name属性并赋值”我有名字了”。obj1同样拥有了和obj2一样的name属性。说明这两个引用数据类型变量指向同一个堆内存对象。obj1赋值给obj2，实际只是把这个堆内存对象在栈内存的引用地址复制了一份给了obj2，但它们本质上共同指向了同一个堆内存对象。 下面我们来演示这个引用数据类型赋值过程： 自然，给obj2添加name属性，实际上是给堆内存中的对象添加了name属性，obj2和obj1在栈内存中保存的只是堆内存对象的引用地址，虽然也是拷贝了一份，但指向的对象却是同一个。故而改变obj2引起了obj1的改变。 这一段引自本链接 4.1.2 传递参数访问变量有按值和按引用两种方式（如同变量的基本类型值的复制和引用类型的值的复制），而参数只按值传递。 其实可以这么理解，只有按值传递。只不过基本类型传递是变量本身实在的值，而引用类型传递是也是变量的值，只不过这里的值是引用地址。 4.2 执行环境及作用域执行环境：定义了变量和函数有权访问的其他数据，决定了他们各自的行为。 JavaScript中的运行环境大概包括三种情况：（1）全局环境：JavaScript代码运行起来会首先进入该环境（2）函数环境：当函数被调用执行时，会进入当前函数中执行代码（3）eval 全局执行环境是最外层的一个执行环境。在web浏览器中全局执行环境被认为是window对象。每个函数都有自己的执行环境。内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境的任何变量和函数；这是因为某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数也会被销毁。这也解释了局部变量不能在变量对象被外访问到的原因。 作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。当代码在一个环境中执行时，都会创建一个作用域链。 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。 4.2.1 延长作用域链：虽然执行环境只有两种——全局作用域和局部作用域，但是还是可以通过某种方式来延长作用域链。因为有些语句可以在作用域链的顶部增加一个临时的变量对象。有两种情况会发生这种现象：1、try-catch语句的catch块；2、with语句； 4.2.2 没有块级作用域在其他类c语言中由花括号封闭的代码块都有自己的作用域，即js中执行环境。 任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。比如： 1234if （rtrue）&#123; var color = "blue";&#125;alert color; 在js中color在外部仍可以访问到，而在有块级作用域的语言中，则访问不到。只有函数后的的代码块才是执行环境。 4.3 垃圾收集内存生命周期 不管什么程序语言，内存生命周期基本是一致的： 分配你所需要的内存 使用分配到的内存（读、写） 不需要时将其释放\归还 垃圾回收的机制原理：找出不再使用的变量，然后释放掉其占用的内存。垃圾回收器会按照固定的时间或预定的的时间间隔周期性的执行。 来看下局部变量的生命周期。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，一旦函数结束，局部变量就没有存在必要了，可以释放它们占用的内存。但并不是所有的变量都那么容易判断是否还有存在的必要。 垃圾回收器必须知道哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来回收。用于标记无用变量的策略有很多，常见的有两种方式： 1. 标记清除垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量的标记和被环境中的变量引用的变量的标记，此后，如果变量再被标记则表示此变量准备被删除。 简单来说：垃圾收集器中有俩次判断变量是否要被收集。如果这俩次没逃脱掉，那就肯定要被收集的。一是变量未被引用，二是已经执行过finalize方法。。。也就是俩次标记，具体可以查下Jvm垃圾收集算法。参考自 2. 引用计数引用计数的含义是跟踪记录每个值被引用的次数。 注意是值被引用的计数，释放的是值所占的内存。 当创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1，在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1，需要释放一个对象时，就将该对象的引用计数减1，直至对象的引用计数为0，对象的内存会被立刻释放。 这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 示例 12345678910111213141516var o = &#123; a: &#123; b:2 &#125;&#125;; // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o// 很显然，没有一个可以被垃圾收集var o2 = o; // o2变量是第二个对“这个对象”的引用o = 1; // 现在，“这个对象”的原始引用o被o2替换了，即现在“这个对象”只被o2一个引用。var oa = o2.a; // 引用“这个对象”的a属性// 现在，“这个对象”有两个引用了，一个是o2，一个是oao2 = "yo"; // 最初的对象现在已经是零引用了 // 他可以被垃圾回收了 // 然而它的属性a的对象还在被oa引用，所以还不能回收oa = null; // a属性的那个对象现在也是零引用了 // 它可以被垃圾回收了 该算法有个限制：无法处理循环引用。 两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收 12345678function f()&#123; var o = &#123;&#125;; var o2 = &#123;&#125;; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o return "azerty";&#125;f(); 解除引用；一旦数据不再有用，通过将其值设置为null来释放其引用。 局部变量就是在离开执行环境时自动被解除引用。解除引用不意味释放内存，而是让值脱离执行环境，以便垃圾收集器运行时将其收回。 4.4 堆内存与栈内存在JS中，每一个数据都需要一个内存空间。内存空间又被分为两种，栈内存(stock)与堆内存 栈内存 堆内存 存储基础数据类型 存储引用数据类型 按值访问 按引用访问 存储的值大小固定 存储的值大小不定，可动态调整 由系统自动分配内存空间 由程序员通过代码进行分配 主要用来执行程序 主 要用来存放对象 空间小，运行效率高 空间大，但是运行效率相对较低 先进后出，后进先出 无序存储，可根据引用直接获取 第五章 引用类型引用类型的值（对象）是引用类型的一个实例。引用类型是一种数据结构，用于将数据和功能组织在一起。它也被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。 上面这句话应该意味着 引用类型是类在js中进行了修正以更符合js的要求一个变种。 面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 新对象是使用new操作符后跟一个构造函数来创建的，构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。例： 1var person = new Object(); 这行代码创建了Object引用类型的一个新实例，然后把该实例保存在了变量person中。使用的构造函数是Object，它只为新对象定义了默认的属性进和方法。 对象：对象是类的一个实例 ，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 下图中男孩女孩为类，而具体的每个人为该类的对象： 参考链接：Java 对象和类 5.1 Object 类型对象就是一组“键值对”（key-value，键名和键值）的集合，是一种无序的复合数据集合。 对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键值），所以加不加引号都可以。但是如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。如果属性的值还是一个对象，就形成了链式引用。 创建Object实例的方法有两种。第一种是使用new操作符后跟Object构造函数，如下所示： 123var person = new Object（）；person.name = "xiangming";person.age = 29; 另一种方法是使用对象字面量表示法。 12345678910111213var person = &#123; person.name ： "xiangming"; 5 ： true； person.age ： 29； //最后一个属性后面，加逗号可能会在旧版本浏览器，如ie7等中导致错误。 //数值属性值会自动转换为字符串。&#125;；var person = &#123;&#125;；person.name = "xiangming";person.age = 29; // 这两个例子是等价的。 这里的左花括号表示对象字面量的开始，if（）{}这里的则表示一个语句块的开始。因此也解释了函数作用域的一个疑问，即在在if后面的{}定义的局部变量为什么在外部仍可以访问到，也因此if后的{}不是一个执行环境。 访问对象属性一般都是用点表示法，在js中也可以用方括号表示法。在使用方括号时要将访问的属性以字符串的形式放在方括号里。例： 12alert(person["name"]); //xiaomingalert(person.name); 方括号方法的优点是可以通过访问变量来访问属性，例： 12var propertyName = "name";alert(personn[propertyName]); 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字保留字，有些不能用点表示法来访问，可以使用方括号表示法。 for…in 循环for…in循环用来遍历一个对象的全部属性。 for…in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。它不仅遍历对象自身的属性，还遍历继承的属性。举例来说，对象都继承了toString属性，但是for…in循环不会遍历到这个属性。 123456var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for…in循环遍历到，因为它默认是“不可遍历”的。 如果继承的属性是可遍历的，那么就会被for…in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for…in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 1234567var person = &#123; name: &apos;老张&apos; &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name 5.2 Array 类型数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。任何类型的数据，都可以放入数组。 如果数组的元素还是数组，就形成了多维数组。 123var a = [[1, 2], [3, 4]];a[0][1] // 2a[1][1] // 4 本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。 数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。通过数字索引可以增加和替换数据项。 12345var arr = ['a', 'b', 'c'];alert(arr.toString());Object.keys(arr)// ["0", "1", "2"]alert = (arr.length); //3 arr[5] = `e`;//arr = ['a', 'b', 'c',,,e];第四项和第五项为undefined。 上面代码中，Object.keys方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。 JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。 创建数组的方式也有两种：第一种使用Array构造函数，如下： 12var colors = new Array();//new操作符可省略 1234var colors = new Array(20);//length值为20的数组 var colors = new Array("Greg");//如果传递的是非数值类型的参数，会创建包含那个值的数组。 第二种方法使用字面量表示法 12var colors = ["red","blue",]// 创建两项或三项的数组（不同的版本的浏览器解解析有bug）第三项是undefined，所小心逗号 length 属性数组的length属性，返回数组的成员数量。 1['a', 'b', 'c'].length // 3 JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说length属性的最大值就是 4294967295。 只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1。 12345var a = [];a['p'] = 'abc';a.length // 0a[2.1] = 'abc';a.length // 0 上面代码将数组的键分别设为字符串和小数，结果都不影响length属性。因为，length属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以length属性保持为0。 5.2.1 检测数组参考3.4.1typeof 操作符。 确定某个对象是不是数组 123if (value instanceof Array)&#123; //对数组执行某些操作&#125; instance of 操作符的问题在于，它假定只有一个全局执行环境。如果网页包含多个框架，实际上就是存在多个不同的全局执行环境，从而存在多个不同版本的Array构造函数。如果一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架原生创建的的数组分别具有各自不同的构造函数。 为结决这个问题，ES5新增了Array.isArray()方法， 123if (Array.isArray(value))&#123; //对数组执行某些操作&#125; 5.2.2 转换方法所有的对象都具有toLocaleString()、toString()和valueOf()方法。其中调用valueOf()返回的还是数组本身，而调用数组的toLocaleString()方法会返回数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。 跳出数组的视角来看这几个定义，其实要分清这几个性价比实在不高，先放着： valueOf() 方法返回一个String对象的原始值（primitive value）。 String 全局对象是一个用于字符串或一个字符序列的构造函数。String 对象用于处理文本（字符串）。 toString() 方法返回一个表示该对象的字符串。 toString()与String()的区别就在于String()还能转换null和undefined值，可以说是toString()的增强版。 toLocaleString() 方法返回一个该对象的字符串表示。此方法被用于派生对象为了特定语言环境的目的（locale-specific purposes）而重载使用。 什么是对象，尴尬，有说js里所有的事物都是对象：字符串、数值、数组、函数… 此外，JavaScript 允许自定义对象。 所有事物都是对象JavaScript 提供多个内建对象。（心里mmp） String()方法在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。String()函数遵循下列转换规则： 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果；如果值是null，则返回”null”；如果值是undefined，则返回”undefined”。参靠3.4.5-5 123var arr = ['a', 'b', 'c'];alert(arr.toString());//a,b,calert(arr.valueOf())//["a", "b", "c"] 另外，toLocalString()方法经常也会返回与toString()和valueOf()方法相同的值，但也不总是如此。当调用数组的toLocaleString()方法时，它也会创建一个数组的以逗号分割的字符串。而与前两个方法唯一的不同指出在于，这因此i是为了取得每一项的值，调用的是每一项的toLocaleString()方法，而不是toString()方法。请看下面这个例子： 1234567891011121314151617181920var person1 = &#123; toLocaleString: function () &#123; return "Nikolaos"; &#125;, toString: function () &#123; return "Nicholas"; &#125;&#125;var person2 = &#123; toLocaleString: function () &#123; return "Grigorios"; &#125;, toString: function () &#123; return "Greg"; &#125;&#125;;var people = [person1, person2];alert(people); //Nicholas,Gregalert(people.toString()); //Nicholas,Gregalert(people.toLocaleString()); //Nikolaos,Grigorios join() 方法只接收一个参数，即用作分隔符的字符串。 1234var colors =['red','green','blue'];alert(colors);//red,green,bluealert(colors.join(',')); //red,green,bluealert(colors.join('||')); //red||green||blue 5.2.3 栈方法ES数组也提供了一种让数组行为类似于其他数据结构的方法。 栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构。只在栈的顶部增添和移除。 push（）方法可以接收任意数量的参数，把它们逐个添加到数组的末尾，返回修改后的数组的长度。 pop（）方法从数组末尾移除最后一项，减少数组的length的值，返回移除的项。 123456var colors = Array();var count = colors.push('red','green');alert(count);//2alert(colors);// red,greenvar item = colors.pop();alert(item); // green 5.2.4 队列方法队列FIFO（先进先出）。在末端添加项，前端移除项。 shift 移除数组第一个项，并返回该项。 unshift在数组前端添加任意个项，返回数组新长度。 12345var colors = ['red','green'];alert(colors.shift()); //redvar item = colors.unshift('yellow','blue');alert(item); //4alert(colors);//yellow,blue,red,green 5.2.5 重排序方法reverse()方法会反转数组项的顺序。（仅仅是翻转而已，并不按大小） sort()方法按升序排列数组项。（比较字符串大小，不是数值大小） 为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以 确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 默认这个返回值，是按升序排列的，把1改为返回一个大于0的值，3返回一个小于0的值，就可按降序排列。 如下所示。 123var values = [0, 1, 5, 10, 15];values.sort();alert(values); //0,1,10,15,5 以下就是一个简单的比较函数： 123456789101112function compare(value1, value2) &#123;if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); //0,1,5,10,15 对于数值类型或者valueOf（）方法会返回数值类型的对象类型，可用一个更简单的比较函数。 12345function compare(value1, value2) &#123; return value2 - value1&#125;var values = [0, 1, 5, 10, 15];values.sort(compare); 5.2.6 操作方法concat()concat() 方法用于连接两个或多个数组。 该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 语法 1arrayObject.concat(arrayX,arrayX,......,arrayX) arrayX 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个，如果没有参数那么仅是复制了原函数。 如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。 12var a = [1,2,3];document.write(a.concat(4,5));//1,2,3,4,5 push()和concat()方法都可以将传的参数添加到数组的后面，只不过push()是在原数组上操作（改变的是原数组），concat()不会改变原数组，创建原数组的副本，并且把传的参数添加到新数组后面。 push()传递的参数是数组时，将整个数组传给原数组末尾，如示例中得到的结果[“a”, “b”, Array[2], Array[3]] 1234var arr = ['a','b'];console.log(arr); // ["a", "b"]arr.push(['c','d'],[1,2,3]);console.log(arr); // ["a", "b", Array[2], Array[3]] slice()slice()方法它也能基于当前数组创建一个新数组，而且对原数组也并不会有任何影响。slice()接受一个或两个参数，即要返回项的起始和结束位置（但不包括结束位置的项）。当只给slice()传递一个参数时，该方法返回从该参数指定位置开始到当前数组末尾的所有项。如下面示例： 当传递的参数是负值,用数组长度加上该负值。结束位置小于或等于开始位置，将返回一个空数组。 slice()方法和concat()方法类似，会在原数组上构建一个新数组，并不会影响原数组。 参考自，w3cplus。 splice()可删除、插入、替换。splice()方法还会影响原数组 在splice()方法中指定两个参数，第一个参数是指定开始删除数组项位置，第二个数是指删除数组项的个数。 splice(0,2)会删除数组中前两项。 指定三个参数，第一个参数为插入的起始位置，第二个参数为0(要删除的数组项数量，因为删除数量是为0，所以不做删除)，第三个参数是要插入的数组项。（数组项可任意多） 123456789101112var colors = ['red','green','blue'];var removed = colors.splice(0,1);alert(colors); //green,bluealert(removed);//redremoved = colors.splice(1,0,'yellow','orange');alert(colors);//grenn,yellow,orange,bluealert(removed);返回一个空数组，因为删除项为0；removed = colors.splice(1,1,'red','purple');alert(colors);//grenn,red,purple,orange,bluealert(removed); 5.2.7 位置方法ES5为数组实例添加了两个位置方法：indexOf()和lastIndexi().这两个方法都可以接收两个参数：要查找的项和（可选）表示查找位置起点的索引。indexOf()从数组的开头（位置0）开始，lastIndexi()从数组的末尾开始。 12var colors = ['red','green','blue'];alert(colors.indexOf('green'));// 1 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1.在比较查找的第一项与数组中的每一项时，要使用全等操作符，要严格相等。 5.2.8 迭代方法五个迭代方法 都接受两个参数：要在每一项上运行的函数 和 运行该函数的作用域（可选）。传入这些方法中的函数会接收三个参数：数组项的值，该项在数组中的位置和数组对象本身。 ES5为数组定义了五个迭代方法： forEach()：对数组中每一项运行给定函数。该函数没有返回值。 every(): 对数组中的每一项运行给定函数。如果函数对每一项都返回 true，则返回 true。 some(): 对数组中每一项运行给定函数。如果函数对 任一项返回 true，则返回 true filter(): 对数组中的每一项运行给定函数。返回该函数会返回 true 的项组成的数组。 map(): 对数组中每一项运行给定函数。返回每次函数调用的结果组成的函数。 1234567891011121314151617181920212223242526var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; // item:当前遍历项，index:当前项索引，array:数组对象本身 var everyResult = numbers.every(function (item, index, array) &#123; return item &gt; 2; &#125;); alert(everyResult);//false var someResult = numbers.some(function (item, index, array) &#123; return item &gt; 2; &#125;); alert(someResult);//true var filterResult = numbers.filter(function (item, index, array) &#123; return item &gt; 2; &#125;); alert(filterResult);//[3,4,5,4,3] var mapResult = numbers.map(function (item, index, array) &#123; return item * 2; &#125;); alert(mapResult);//[2,4,6,8,10,8,6,4,2] //forEach 本质上和for循环没有区别 var forEachResult=numbers.forEach(function(item,index,array)&#123; //执行某些操作 比如 alert(item) &#125;); 5.2.9 归并算法ECMAScript 5 新增两个归并数组的方法：reduce() 和 reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。使用reduce()还是reduceRight()，主要取决于要从哪头开始遍历，除此之外，它们完全相同。前者从数组的第一项开始，后者从从最后一项开始 。reduce()方法接受两个参数 ：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。 我们先说一说第一个参数。这个参数（函数）接收 4 个参数：前一个值，当前值，项的索引和数组对象。 来个例子🌰： 12345678910// 使用 reduce() 方法可以执行求数组里所有值之和的操作var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array) &#123; console.log(prev); // 共执行四次，依次输出 1， 3， 6， 10 console.log(cur); // 共执行四次，依次输出 2， 3， 4， 5 console.log(index); // 共执行四次，依次输出 1, 2, 3, 4 console.log(array); // 共执行四次，每次都输出原数组 [1,2,3,4,5] return prev + cur;&#125;)console.log(sum); // 15 第一次执行回调函数，prev 是 1（数组的第一项） ，cur 是 2（数组的第二项），index 是 1（注意并没从 0 开始）。第二次，prev 是 3 （1 加 2 的结果），cur 是 3 （数组的第三项），index 是 2。 这个过程会持续到把数组中的每一项都访问一遍，最后返回结果（一共执行四次，得到 1 + 2 + 3 + 4 + 5 = 15）。 5.3 Date 类型静态方法（Date.方法()而不是通过变量名.方法）Date对象是 JavaScript 原生的时间库。它以1970年1月1日00:00:00(UTC)作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。 要创建一个日期对象，使用new操作符和Date构造函数即可，如下 12345var now = new Date();now; //Mon May 14 2018 08:28:34 GMT+0800 (中国标准时间)var now = new Date(100000);now;// Thu Jan 01 1970 08:01:40 GMT+0800 (中国标准时间) 在调用构造函数而不传递参数的情况下，新创建的对象自动获取当前时间,如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数(即从UTC时间1970年一月一日午夜起至该日期经过的毫秒数)。 为了简化这一过程，ES提供了两个方法：Date.parse()和Date.UTC() 1. Date.parse()Date.parse()方法接收一个表示日期的字符串数，然后返回相应的毫秒数，如果接收的字符串不能被解析，则返回NaN，但是由于浏览器不同，不一定返回NaN。 日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区。但是，其他格式也可以被解析。 由于 parse() 是 Date 的一个静态方法 , 所以应该使用Date.parse() 来调用，而不是作为 Date 的实例方法。 1234var now = new Date(Date.parse('2014-03-07')); //Fri Mar 07 2014 08:00:00 GMT+0800 (中国标准时间)var now = new Date(Date.parse('2014-03-07'));与 var now = new Date('2014-03-07');now;是等价的。Date构造函数会在后台调用Date.parse()。 2. Date.UTC()接受和构造函数最长形式的参数相同的参数（从2到7），并返回从 1970-01-01 00:00:00 UTC 开始所经过的毫秒数。 参数分别为年份、月份（0-11）、日（1-31）、小时（0-23）、分钟、秒以及毫秒数。前两个参数必须，月，默认天数1，其它默认为0 。 3. Date.now()Date.now() 方法返回自1970年1月1日 00:00:00 UTC到当前时间的毫秒数。 因为 now() 是Date的一个静态函数，所以必须以 Date.now() 的形式来使用。 总： 1234new Date();new Date(value);new Date(dateString);new Date(year, month [, day [, hours [, minutes [, seconds [, milliseconds]]]]]); 实例方法Date的实例对象，有几十个自己的方法，除了valueOf和toString，可以分为以下三类。 to类：从Date对象返回一个字符串，表示指定的时间。get类：获取Date对象的日期和时间。set类：设置Date对象的日期和时间。 valueOf方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法和Date.now()。 方法 描述 Date() 返回当日的日期和时间。 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getFullYear() 从 Date 对象以四位数字返回年份。 getYear() 请使用 getFullYear() 方法代替。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。 getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。 getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。 getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。 getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。 getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。 parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。 setMonth() 设置 Date 对象中月份 (0 ~ 11)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setYear() 请使用 setFullYear() 方法代替。 setHours() 设置 Date 对象中的小时 (0 ~ 23)。 setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setTime() 以毫秒设置 Date 对象。 setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。 setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。 setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。 setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。 setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。 setUTCSeconds() 根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。 setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。 toSource() 返回该对象的源代码。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toDateString() 把 Date 对象的日期部分转换为字符串。 toGMTString() 请使用 toUTCString() 方法代替。 toUTCString() 根据世界时，把 Date 对象转换为字符串。 toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串。 toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 UTC() 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 valueOf() 返回 Date 对象的原始值。 set: 12345var d = new Date ('January 6, 2013');d // Sun Jan 06 2013 00:00:00 GMT+0800 (CST)d.setDate(9) // 1357660800000 返回的是毫秒数d // Wed Jan 09 2013 00:00:00 GMT+0800 (CST) 返回设置后的日期显示 to: 12var d = new Date(); d.toUTCString() //"Mon, 14 May 2018 02:05:17 GMT" get: 12var d = new Date()d.getDate()//14 当前日期（5.14） GMT与UTC两个时区 5.4 RegEXp 类型字面量知识点补充参考链接 字面量是由语法表达式定义的常量；或，通过由一定字词组成的语词表达式定义的常量。 数组字面量(Array literals) 布尔字面量(Boolean literals) 浮点数字面量(Floating-point literals) 整数(Intergers) 对象字面量(Object literals) RegExp literals 字符串字面量(String literals) 数组字面值是一个封闭在方括号对([])中的包含有零个或多个表达式的列表，其中每个表达式代表数组的一个元素。 1var a=[3]; 布尔类型有两种字面量：true和false。 整数和浮点数他们数值本身就是其字面量。 对象字面值是封闭在花括号对({})中的一个对象的零个或多个”属性名-值”对的（元素）列表。 一个正则表达式是字符被斜线（译注：正斜杠“/”）围成的表达式。 。 1var re = /ab+c/; 字符串字面量是由双引号（”）对或单引号（’）括起来的零个或多个字符 ​ 补充完毕 使用下面类似Perl的语法，就可以创建一个正则表达式。 1var expression = / pattern/flags; 其中模式部分是正则表达式，每一个正则表达式都可带有一个或多个标志（flags），用以表明正则表达式的行为。 如果指定，标志可以具有以下值的任意组合： g 全局搜索。也就是匹配目标字符串中所有可能的匹配项，而不是只进行第一次匹配。 i 不区分大小写搜索。 m 多行搜索。 y 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。 u Unicode; 将模式视为Unicode序列点的序列 RegExp 构造函数创建了一个正则表达式对象，用于将文本与一个模式匹配。 新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。 1var regex = /xyz/; 另一种是使用RegExp构造函数。 1var regex = new RegExp('xyz'); 123var regex = new RegExp('xyz', 'i');// 等价于var regex = /xyz/i; 两种方法的不同之处在于：字面量，在加载脚本后，正则表达式字面值提供正则表达式的编译（又引擎编译）。当正则表达式保持不变时，使用此方法可获得更好的性能。 使用构造函数提供正则表达式的运行时编译。使用构造函数，当你知道正则表达式模式将会改变，或者你不知道模式，并从另一个来源，如用户输入。 方括号方括号用于查找某个范围内的字符： 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 [^adgk] 查找给定集合外的任何字符。 (red\ blue\ green) 查找任何指定的选项。 元字符元字符（Metacharacter）是拥有特殊含义的字符： 元字符 描述 . 查找单个字符，除了换行和行结束符。 \w 查找单词字符。 \W 查找非单词字符。 \d 查找数字。 \D 查找非数字字符。 \s 查找空白字符。 \S 查找非空白字符。 \b 匹配单词边界。 \B 匹配非单词边界。 \0 查找 NUL 字符。 \n 查找换行符。 \f 查找换页符。 \r 查找回车符。 \t 查找制表符。 \v 查找垂直制表符。 \xxx 查找以八进制数 xxx 规定的字符。 \xdd 查找以十六进制数 dd 规定的字符。 \uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。 n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 初步熟悉正则 5.4.1 RegExp 实例属性 ignoreCase：返回一个布尔值，表示是否设置了i标志。 global：返回一个布尔值，表示是否设置了g标志。 RegExp.prototype.multiline：返回一个布尔值，表示是否设置了m标志。以上三个属性仅为修饰。 lastIndex：返回一个数值，表示下一次开始搜索的位置，起始为0，该属性可读写。 source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。 然而并没多大用处，因为这些信息全部包含在模式声明中， 1234567var r = /abc/igm;r.ignoreCase // truer.global // truer.multiline // truer.lastIndex // 0r.source // "abc" 5.4.2 实例方法exec（）该方法是专为捕获数组而设立的。exec()接受一个参数，即要应用模式的字符串，然后返回第一个包含匹配项信息的数组，如果没有找到匹配，则返回 null。返回的数组虽然是Array实例。但包含两个额外属性：index和input。其中index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串，在数组中，第一项是整个模式匹配的字符串，其他项是与模式中的捕获匹配的字符串（如果没有捕获组，则该数组只包含一项）。 12345678910var text = "mom and dad and baby";var pattern = /mom( and dad( and baby)?)?/gi; var matches = pattern.exec(text);matches；//["mom and dad and baby", " and dad and baby", " and baby", index: 0, input: "mom and dad and baby", groups: undefined]alert(matches.index); //0alert(matches.input); //"mom and dad and baby"alert(matches[0]); //"mom and dad and baby"alert(matches[1]); //" and dad and baby"alert(matches[2]); //" and baby" 需要注意的是，使用 exec() 方法，即使在正则表达式中设置了全局模式（g 标志），它也只会返回字符串中的第一个匹配项。区别在于，不设置全局模式的情况下，在同一个字符串上调用多次 exec() 将始终返回第一个匹配项的信息。而设置了全局模式后，在同一个字符串上调用多次 exec() 方法将会在之前查找完的位置继续向下查找新的匹配项。例如： 1234567891011121314151617181920212223242526var text = "cat, bat, sat, fat"; var pattern1 = /.at/; //'.'匹配除换行符之外的任何单个字符。 var matches = pattern1.exec(text); matches; //["cat", index: 0, input: "cat, bat, sat, fat", groups: undefined]alert(matches.index); //0alert(matches[0]); //catalert(pattern1.lastIndex); //0 matches = pattern1.exec(text); alert(matches.index); //0alert(matches[0]); //catalert(pattern1.lastIndex); //0 var pattern2 = /.at/g; var matches = pattern2.exec(text); alert(matches.index); //0alert(matches[0]); //catalert(pattern2.lastIndex); //0 matches = pattern2.exec(text); alert(matches.index);//5 "cat, ",bat在字符串的起始位index是6，而输出是5，所以index输出的应是匹配项起始位的前一位，而依次规则第一位的index应该是-1，实际是0，依次此规则对于第一位不适合。alert(matches[0]); //batalert(pattern2.lastIndex); //8 test()它接受一个字符串参数，在模式与该参数匹配的情况下返回true；否则返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容时，使用这个非常方便，因此test方法经常被用在if语句中， 123456var text = "000-00-0000"; var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/; if (pattern.test(text))&#123; alert("The pattern was matched.");&#125; 支持正则表达式的 String 对象的方法方法 描述search 检索与正则表达式相匹配的值。match 找到一个或多个正则表达式的匹配。replace 替换与正则表达式匹配的子串。split 把字符串分割为字符串数组。 5.4.3 RegExp 构造函数属性 input (简写为$_) 最近一次要匹配的字符串。 lastMatch(简写$&amp;) 最近一次的匹配项 lastParen(简写$+) 最近一次匹配的捕获组。 leftContext(简写$`) input字符串中lastMatch之前的文本 rightContext(简写$’) input字符串中lastMatch之后的文本 multiline(简写$*) 布尔值，表示是否所有表达式都使用多行模式。 12345678910var text ="you are in haorooms 博客，看文章呢";var pattern =/(.)aorooms/g;if(pattern.test(text))&#123; console.log(RegExp.$_); //you are in haorooms 博客，看文章呢 console.log(RegExp["$`"]);//you are in console.log(RegExp["$'"]);//博客，看文章呢 console.log(RegExp["$&amp;"]);//haorooms console.log(RegExp["$+"]);//h console.log(RegExp["$*"]);//false&#125; 除了上面几个属性之外还有 （RegExp.$1,RegExp.$2,RegExp.$3,RegExp.$4,RegExp.$5,RegExp.$6,RegExp.$7,RegExp.$8,RegExp.$9）,一共有9个。用来存储匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。其实，说简单的，就是可以获得（）括号内匹配的字符串。 1234567var text ="you are in haorooms 博客，看文章呢";var pattern =/(.)ao(..)om(.)/g;if(pattern.test(text))&#123; console.log(RegExp.$1);//h console.log(RegExp.$2);//ro console.log(RegExp.$3);//s &#125; 5.5 Function 类型Function（函数）类型实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具备属性和方法，由于函数是对象，因此函数名实际上也是一个指向函数对象的指针。参考4.1章节。没有函数重载的概念。 函数定义： 通过函数声明 123function sum (num1 ,numb2)&#123; return num1 + num2;&#125; 通过函数表达式 123var sum = function (num1 ,numb2)&#123; return num1 + num2;&#125;; 两者区别： 解析器在向执行环境中加载数据时，解析器会先读取函数声明，并使其在执行任何代码之前可用（可以访问）；对于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。函数提升，参考3.3.1变量提升。例： 1234alert (sum (10，10));function sum (num1 ,numb2)&#123; return num1 + num2;&#125; 上面代码可以正常运行，js引擎会把函数声明提升到顶部。而对于通过函数表达式定义的函数则会抛出错误。 5.5.1 作为值的函数因为ECMAScriopt中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不久可以像传递参数一样把一个函数传递个另一个函数，而且可以将一个函数作为另一个函数的结果返回。 1234567891011121314151617function callSomeFunction(someFunction, someArgument) &#123; return someFunction(someArgument);&#125;function ad10(num) &#123; return num + 10;&#125;var result1 =callSomeFunction(add10,10);alert(result1); //20function getGreeting(name) &#123; return "Hello, " + name;&#125;var result2 = callSomeFunction(getGreeting, "Icey");alert(result2); //"Hello Icey" 要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。 从函数中返回另一个函数的应用： 12345678910111213function createComparisonFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 按照某个对象的属性进行排序。 123456var data = [&#123;name:"Icey", age:25&#125;, &#123;name:"Root", age:24&#125;];data.sort(createComparisonFunction("name"));alert(data[0].name); //"Icey"data.sort(createComparisonFunction("age"));alert(data[0].name); //"Root" sort()方法参考。5.2.5重排序方法。 5.5.2 函数内部属性(arguments和this)在函数内部，有两个特殊的对象：arguments和this。其中，arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。请看下面这个非常经典的阶乘函数。 1234567function factorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * factorial(num-1); &#125;&#125; 定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。 1234567function factorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * arguments.callee(num-1); &#125;&#125; 在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如： 1234567var trueFactorial = factorial;factorial = function()&#123; return 0;&#125;; alert(trueFactorial(5)); //120alert(factorial(5)); //0 在此，变量trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回0的函数赋值给factorial变量。如果像原来的factorial()那样不使用arguments.callee，调用trueFactorial()就会返回0。可是，在解除了函数体内的代码与函数名的耦合状态之后，trueFactorial()仍然能够正常地计算阶乘，至于factorial()，它现在只是一个返回0的函数。函数内部的另一个特殊对象是this，其行为与java和C#中的this大致类似。换句话说，this引用的是函数执行的环境对象——或者也可以说是this值(当在网页的全局作用域中调用函数时，this对象引用的就是window)。来看下面的例子。 12345678910window.color = "red";var o = &#123;color : "blue"&#125;; function sayColor()&#123; alert(this.color);&#125;sayColor(); // redo.sayColor = sayColor; o.sayColor(); // blue 上面这个函数sayColor()是在全局作用域中定义的，this对象引用了window对象。由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。当在全局作用域中调用sayColor()时，this引用的是全局对象window，换句话说，对this.color求值会转换成对window.color求值，于是结果就返回了”red”。而当把这个函数赋给对象o并调用o.sayColor()时，this引用的是对象o，因此对this.color求值会转换成对o.color求值，结果就返回了”blue”。 请读者一定要牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的sayColor()函数与o.sayColor()指向的仍然是同一个函数。 5.5.3 函数属性和方法每个函数都包含两个属性：length 和 prototype length:当前函数希望接受的命名参数的个数 prototype：是保存他们所有实例方法的真正所在 1234567891011121314function sayName(name) &#123; alert(name); &#125; function sum(num1, num2) &#123; return num1 + num2; &#125; function sayHi() &#123; lert("hi"); &#125; alert(sayName.length);//1 参数个数一个 alert(sum.length);//2 参数个数2个 alert(sayHi.length);//0 没有参数 每个函数都包含两个非继承而来的方法：apply() 和 call() 这两个方法都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值 首先 apply() 接受两个参数：一个是函数运行的作用域，另一个参数数组（可以是数组实例也可以是 arguments 对象） 12345678910111213function sum(num1, num2) &#123; return num1 + num2; &#125; function callSum1(num1, num2) &#123; return sum.apply(this, arguments);//传入arguments对象 &#125; function callSum2(num1, num2) &#123; return sum.apply(this, [num1, num2]); &#125; alert(callSum1(10, 10));//20 alert(callSum2(10, 10));//20 其次，call 方法第一个参数没有变化，变化的是其余的参数都是传递参数，传递给函数的参数需要逐个列举出来 12345678function sum(num1, num2) &#123; return num1 + num2; &#125; function callSum(num1, num2) &#123; return sum.call(this, num1, num2); &#125; alert(callSum(10, 10)); //20 至于使用哪个方法更方便，完全取决于你的意愿。如果没有参数，用哪个都一样。 但是，apply 和 call 方法的出现绝对不是只是为了怎样去传递参数。 它们真正的用武之地在于扩充函数赖以运行的作用域。 123456789101112window.color = "red"; var o = &#123;color: "blue"&#125;; function sayColor() &#123; alert(this.color); &#125; sayColor();//red sayColor.call(this);//red sayColor.call(window);//red ayColor.call(o);//blue 使用 apply 和 call 来扩充作用域的最大的好处就是不需要与方法有任何的耦合关系。 ECMAScript5 还定义了一个方法：bind()。这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind 函数的值 12345678910window.color = "red";var o = &#123;color: "blue"&#125;; function sayColor() &#123; alert(this.color); &#125; var bindFun = sayColor.bind(o); bindFun();//blue 5.6 基本包装类型为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型：Boolean、Number 和String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值得时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。如下例子： 12var s1="some text"; var s2=s1.substring(2); 这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值，而下一行代码调用了 s1的 substring() 方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要·从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。 创建 String 类型的一个实例； 在实例上调用指定的方法； 销毁这个实例 123var s1 = new String('test'); var s2 = s1.substring(2);s1 = null; 上面三个步骤也分别使用于Boolean和Number类型对应的布尔值和数字值。 引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能再运行时为基本类型值添加属性和方法。如下面例子： 123var s1="some text" s1.color="red"; alert(s1.color);//undefined 当然，可以显示的地调用 Boolean、Number 和 String 来创建基本包装类型的对象。不过，应该在绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本包装类型还是引用基本包装类型的值。对基本包装类型的实例调用 typeof 会返回 “object”，而且所有基本包装类型的对象都会被转换为布尔值 true。 Object 构造函数也会像工厂方法一样，根据传入值得类型返回相应基本包装类型的实例。例如： 12var obj=new Object("some text"); alert(obj instanceof String);//true 把字符串传给 Object 构造函数，就会创建 String 的实例；而传入数值参数会得到Number 的实例，传入布尔值参数就会得到 Boolean 的实例。 要注意的是，使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。例如： 12345var value="25"; var number=Number(value); //转型函数 alert(typeof number); //"number" var obj=new Number(value); //构造函数 alert(typeof obj); //"object" 在这个例子中，变量 number 中保存的是基本类型的值 25，而变量 obj 中保存的是Number 的实例。 5.6.1,5.6.2,5.6.3这三小节，请参考位W3c。ECMAScript 引用类型 5.6.1 Boolean 类型Boolean 对象将覆盖 Object 对象的 ValueOf() 方法，返回原始值，即 true 和 false。ToString() 方法也会被覆盖，返回字符串 “true” 或 “false” 5.6.2 Number 类型Number是与数字对应的引用类型。要创建Number对象，可以在调用Number构造函数时，向其中传递相应的数值。例： 1var numberObject = new Number (10); 与Boolean类型一样，Number类型也重写了valueOf(),toLocaleString()和toString()方法。重写后valueOf()返回对象表示的基本类型的值。另外两个方法返回字符串形式的数值。 补充：toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式，例： 12 toFixed() 方法toFixed() 方法返回的是具有指定位数小数的数字的字符串表示。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toFixed(2)); //输出 "68.00" 在这里，toFixed() 方法的参数是 2，说明应该显示两位小数。该方法返回 “68.00”，空的字符串位由 0 来补充。对于处理货币的应用程序，该方法非常有用。toFixed() 方法能表示具有 0 到 20 位小数的数字，超过这个范围的值会引发错误。 toExponential() 方法与格式化数字相关的另一个方法是 toExponential()，它返回的是用科学计数法表示的数字的字符串形式。 与 toFixed() 方法相似，toExponential() 方法也有一个参数，指定要输出的小数的位数。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toExponential(1)); //输出 "6.8e+1" 这段代码的结果是 “6.8e+1”，前面解释过，它表示 6.8x101。问题是，如果不知道要用哪种形式（预定形式或指数形式）表示数字怎么办？可以用 toPrecision() 方法。 toPrecision() 方法toPrecision() 方法根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。例如， 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(1)); //输出 "7e+1" 这段代码的任务是用一位数字表示数字 68，结果为 “7e+1”，以另外的形式表示即 70。的确，toPrecision() 方法会对数进行舍入。不过，如果用 2 位数字表示 68，就容易多了： 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(2)); //输出 "68" 当然，输出的是 “68”，因为这正是该数的准确表示。不过，如果指定的位数多于需要的位数又如何呢？ 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(3)); //输出 "68.0" 在这种情况下，toPrecision(3) 等价于 toFixed(1)，输出的是 “68.0”。 toFixed()、toExponential() 和 toPrecision() 方法都会进行舍入操作，以便用正确的小数位数正确地表示一个数 5.6.3 String 类型String 类型是字符串的对象包装类型。创建如下： 1var oStringObject = new String("hello world"); String 对象的 valueOf() 方法和 toString() 方法都会返回 String 类型的原始值。 length 属性 String 对象具有属性 length，它是字符串中的字符个数： 12var oStringObject = new String("hello world");alert(oStringObject.length); //输出 "11" 1.字符方法两个方法 charAt() 和 charCodeAt() 访问的是字符串中的单个字符。这两个方法都有一个参数，即要操作的字符的位置。 charAt() 方法返回的是包含指定位置处的字符的字符串： 12var oStringObject = new String("hello world");alert(oStringObject.charAt(1)); //输出 "e" 如果想得到的不是字符，而是字符代码，那么可以调用 charCodeAt() 方法： 12var oStringObject = new String("hello world");alert(oStringObject.charCodeAt(1)); //输出 "101" 2.字符串操作方法参考javascript中字符串常用操作总结 concat() 方法 用于把一个或多个字符串连接到 String 对象的原始值上。 1234var oStringObject = new String("hello "); var sResult = oStringObject.concat("world"); alert(sResult); //输出 "hello world" alert(oStringObject); //输出 "hello " 较常见的是用加号（+）连接字符串 1234var oStringObject = new String(&quot;hello &quot;); var sResult = oStringObject + &quot;world&quot;; alert(sResult); //输出 &quot;hello world&quot; alert(oStringObject); //输出 &quot;hello &quot; substring()1stringObject.substring(start,end) substring()是最常用到的字符串截取方法，它可以接收两个参数(参数不能为负值)，分别是要截取的开始位置和结束位置，它将返回一个新的字符串，其内容是从start处到end-1处的所有字符。若结束参数(end)省略，则表示从start位置一直截取到最后。 1234var str = 'abcdefg';console.log(str.substring(1, 4)); //返回bcdconsole.log(str.substring(1)); //返回bcdefgconsole.log(str.substring(-1)); //返回abcdefg，传入负值时会视为0 slice()1stringObject.slice(start,end) slice()方法与substring()方法非常类似，它传入的两个参数也分别对应着开始位置和结束位置。而区别在于，slice()中的参数可以为负值，如果参数是负数，则将负值与字符串长度相加。 12345var str = 'abcdefg';console.log(str.slice(1, 4)); //返回bcdconsole.log(str.slice(-3, -1)); //返回efconsole.log(str.slice(1, -1)); //返回bcdefconsole.log(str.slice(-1, -3)); //返回空字符串，若传入的参数有问题，则返回空 substr() stringObject.substr(start,length) substr()方法可在字符串中抽取从start下标开始的指定数目的字符。其返回值为一个字符串，包含从 stringObject的start（包括start所指的字符）处开始的length个字符。如果没有指定 length，那么返回的字符串包含从start到stringObject的结尾的字符。另外如果start为负数，第一个参数加上字符串的长度，第二个负值转换为0. 1234var str = 'abcdefg';console.log(str.substr(1, 3)) //返回bcdconsole.log(str.substr(2)) //返回cdefgconsole.log(str.substr(-2, 4)) //返回fg，目标长度较大的话，以实际截取的长度为准 3.字符串位置的方法indexOf()与lastIndexOf()参考5.2.7 位置方法。 在使用第二个参数的情况下，可以通过循环调用这两个方法来找到所有匹配的子字符串，例： 123456789var stringValue = 'lorem ipsum dolor sit amet, consectetur adipisicing elit ';var positions = new Array ();var pos = stringValue.index('e');while (pos &gt; -1)&#123; position.push (pos); pos = stringValue.index ('e', pos+1);&#125;alert (positions);//'3，24，32，35，52' 4.trim() 方法从字符串中移除前导空格、尾随空格和行终止符。 rim() 方法并不影响原字符串本身，它返回的是一个新的字符串。 1234 stringObj.trim()var orig = ' foo ';console.log(orig.trim()); // 'foo' 5.字符串大小写转换方法 toLowerCase() toLocaleLowerCase() toUpperCase() toLocaleUpperCase() 12var oStringObject = new String("Hello World");alert(oStringObject.toLocaleUpperCase()); //输出 "HELLO WORLD" 6.字符串的模式匹配方法match()12stringObject.match(substr)stringObject.match(regexp) match()方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 如果参数中传入的是子字符串或是没有进行全局匹配的正则表达式，那么match()方法会从开始位置执行一次匹配，如果没有匹配到结果，则返回null。否则则会返回一个数组，该数组的第0个元素存放的是匹配文本，除此之外，返回的数组还含有两个对象属性index和input，分别表示匹配文本的起始字符索引和stringObject 的引用(即原字符串)。 1234var str = '1a2b3c4d5e';console.log(str.match('h')); //返回nullconsole.log(str.match('b')); //返回["b", index: 3, input: "1a2b3c4d5e"]console.log(str.match(/b/)); //返回["b", index: 3, input: "1a2b3c4d5e"] 如果参数传入的是具有全局匹配的正则表达式，那么match()从开始位置进行多次匹配，直到最后。如果没有匹配到结果，则返回null。否则则会返回一个数组，数组中存放所有符合要求的子字符串，并且没有index和input属性。 123var str = '1a2b3c4d5e';console.log(str.match(/h/g)); //返回nullconsole.log(str.match(/\d/g)); //返回["1", "2", "3", "4", "5"] search ()stringObject.search(substr) stringObject.search(regexp) search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。它会返回第一个匹配的子字符串的起始位置，如果没有匹配的，则返回-1。 1234var str = 'abcDEF';console.log(str.search('c')); //返回2console.log(str.search('d')); //返回-1console.log(str.search(/d/i)); //返回3 replace()stringObject.replace(regexp/substr,replacement) replace()方法用来进行字符串替换操作，它可以接收两个参数，前者为被替换的子字符串（可以是正则），后者为用来替换的文本。 如果第一个参数传入的是子字符串或是没有进行全局匹配的正则表达式，那么replace()方法将只进行一次替换（即替换最前面的），返回经过一次替换后的结果字符串。 123var str = 'abcdeabcde';console.log(str.replace('a', 'A'));console.log(str.replace(/a/, 'A')); 如果第一个参数传入的全局匹配的正则表达式，那么replace()将会对符合条件的子字符串进行多次替换，最后返回经过多次替换的结果字符串。 123var str = 'abcdeabcdeABCDE';console.log(str.replace(/a/g, 'A')); //返回AbcdeAbcdeABCDEconsole.log(str.replace(/a/gi, '$返回')); //返回$bcde$bcde$BCDE replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。 字符 替换文本 $1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 直接量符号。 1234var str = 'www.denpe.com';var searchStr = 'denpe';var result = str.replace(searchStr, "$$ - $` - $&amp; - $'");console.log(result); // www.$ - www. - denpe - .com.com 从上面例子可看到 denpe 被替换成了 $ - www. - denpe - .com。 参数search 表示$ 匹配子串左边内容 匹配到的子串 匹配子串右边内容 变量名 $$ $` $&amp; $’ 代表的值 $ www. denpe .com JavaScript String.prototype.replace() 方法详解 split()stringObject.split(separator,howmany) split()方法用于把一个字符串分割成字符串数组。第一个参数separator表示分割位置(参考符)，第二个参数howmany表示返回数组的允许最大长度(一般情况下不设置)。 1234var str = 'a|b|c|d|e';console.log(str.split('|')); //返回["a", "b", "c", "d", "e"]console.log(str.split('|', 3)); //返回["a", "b", "c"]console.log(str.split('')); //返回["a", "|", "b", "|", "c", "|", "d", "|", "e"] 也可以用正则来进行分割 12var str = 'a1b2c3d4e';console.log(str.split(/\d/)); //返回["a", "b", "c", "d", "e"] 7.localeCompare()用本地特定的顺序来比较两个字符串。 1stringObject.localeCompare(target) 说明比较结果的数字。如果 stringObject 小于 target(字符串在字母表中的顺序排在字符串参数之前)，则 localeCompare() 返回小于 0 的数。如果 stringObject 大于 target，则该方法返回大于 0 的数。如果两个字符串相等，或根据本地排序规则没有区别，该方法返回 0 8.fromCharCode()String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串 1234String.fromCharCode() // ""String.fromCharCode(97) // "a"String.fromCharCode(104, 101, 108, 108, 111)// "hello" 上面代码中，String.fromCharCode方法的参数为空，就返回空字符串；否则，返回参数对应的 Unicode 字符串。 5.7 单体内置对象ECMA-262定义内置对象是：由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。例如Object，Array和String，Global和Math。 5.7.1Global 对象事实上，没有全局对象或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性，例如isNaN()、isFinite()、parseInt()以及parseFloat()。除了这些，Global对象还有一些方法。 1.URI编码方法Global对象的encodeURI()和encodeURIComponent()方法可以对URI进行编码，以便发送给浏览器，让浏览器更好地理解。 encodeURI()主要用于整个URI，而encodeURIComponent()主要用于对URI中的某一段进行编码。区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，而encodeURIComponent()则会对它发现的任何非标准字符进行编码。 1234567var uri = "http://www.wrox.com/illegal value.htm#start";//"http://www.wrox.com/illegal%20value.html#start"alert(encodeURI(uri));//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start"alert(encodeURIComponent(uri)); encodeURI()和encodeURIComponent()对应的两个方法分别是decodeURI()和decodeURIComponent()（这两个是解码）。 URI方法encodeURI()、encodeURIComponent()、decodeURI()和decodeURIComponent()用于替代已经被ECMA-262第3版废弃的escape()和unescape()方法。URI方法能够编码所有Unicode字符，而原来的方法只能正确的编码ASCII字符。 2.eval()方法 eval()方法就像一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript字符串。 当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域。 12var msg = "hello world!";eval("alert(msg)"); //"hello world" 12eval("function sayHi() &#123; alert('hi'); &#125;");sayHi(); 在eval()中创建的任何变量或函数都不会提升，因为在解析代码的时候，它们被包含在一个字符串中，它们只在eval()执行的时候创建。 严格模式下，在外部访问不到eval()中创建的任何变量和函数，为eval赋值也会导致错误。 12'use strict';eval = "hi"; //causes error 5.7.2Math对象 Math是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。 Math.abs()：绝对值 Math.ceil()：向上取整 Math.floor()：向下取整 Math.max()：最大值 Math.min()：最小值 Math.pow()：指数运算 Math.sqrt()：平方根 Math.log()：自然对数 Math.exp()：e的指数 Math.round()：四舍五入 Math.random()：随机数 1.Math对象的静态属性，参阮一峰 提供以下一些数学常数。 12345678Math.E：常数e。Math.LN2：2 的自然对数。Math.LN10：10 的自然对数。Math.LOG2E：以 2 为底的e的对数。Math.LOG10E：以 10 为底的e的对数。Math.PI：常数 Pi。Math.SQRT1_2：0.5 的平方根。Math.SQRT2：2 的平方根。 2.min()和max()方法如果参数为空, Math.min返回Infinity, Math.max返回-Infinity。 12Math.max(2, -1, 5) // 5 Math.min(2, -1, 5) // -1 3.舍入方法Math.floor方法小于参数值的最大整数 。 12Math.floor(3.2) // 3Math.floor(-3.2) // -4 Math.ceil方法返回大于参数值的最小整数（天花板值）。 12Math.ceil(3.2) // 4Math.ceil(-3.2) // -3 Math.round方法用于四舍五入。 1Math.round(0.1) // 0 4.random()方法Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 1Math.random() // 0.7151307314634323]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于吃]]></title>
    <url>%2Fnote%2F2018%2Fundefined04%2Fec13cc6b.html</url>
    <content type="text"><![CDATA[1. 有哪些食物为了健康你一定不吃？ 绝对不吃：烟（致癌）、槟榔（致癌） 能不吃就不吃：含糖饮料（肥胖）、含糖量高的食品（肥胖）、酒（致癌）、路边摊（卫生状况糟糕） 偶尔吃：油炸（三高）、烟熏（可能致癌）、烤制（可能致癌）、其它高油高盐高糖或致癌加工食品 酒精作为一类致癌物，没有安全剂量可言，喝多喝少都有害，红酒白酒啤酒果酒药酒都有害，尽量不喝才是正确的 。其正面作用远不如危害大。 饼干，大部分蛋糕，开酥的面包（蝴蝶酥，唱片面包等），奶茶，冰淇淋，饮料，雀巢咖啡和伴侣。 原因: 高糖高油导致发胖。 螺类 ，不熟的肉类。 淘宝自制，美食节上的食物。 适合多吃：燕麦，西红柿。]]></content>
      <categories>
        <category>泛娱乐</category>
      </categories>
      <tags>
        <tag>知乎</tag>
        <tag>吃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网格布局（CSS Grid Layout）]]></title>
    <url>%2Fnote%2F2018%2Fundefined30%2F7e93ee50.html</url>
    <content type="text"><![CDATA[css网格布局引入了二维网格布局系统，可用于布局页面主要的区域布局或小型组件。flex布局：弹性盒子布局主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。 1. 网格容器通过在元素上声明 display：grid 或 display：inline-grid 来创建一个网格容器。一旦我们这样做，这个元素的所有直系子元素将成为网格元素。网格元素显示为蚂蚁线。divtwo无内容，宽高为零不显示。 2. 网格属性 grid-template-columns grid-template-rows grid-auto-rows grid-auto-columns grid-column-start grid-column-end grid-row-start grid-row-end grid-column-gap grid-row-gap 2.1我们通过 grid-template-columns 和 grid-template-rows 属性来定义网格中的行和列。 1grid-template-columns: 100px 200px 200px;/100px repeat(2,200px) 2.2 在隐式网格中用 grid-auto-rows 和 grid-auto-columns 属性来定义一个设置大小尺寸的轨道。即这两个属性只作用于隐式网格。 2.3 跨轨道放置网格元素 grid-column-start grid-column-end grid-row-start grid-row-end 2.4 网格间距 grid-column-gap grid-row-gap 3. fr 单位轨道可以使用任何长度单位进行定义 ，fr单位代表网格容器中可用空间的一等份。 ​ 1grid-template-columns: 50px repeat(2, 1fr);/ 50px 1fr 1fr 1grid-template-columns: 50px repeat(6, 1fr); 4. 隐式和显式网格grid-template-columns 属性定义了自己的列轨道，但是却让网格按所需的内容创建行，这些行会被创建在隐式网格中。显式网格包含了你在 grid-template-columns 和 grid-template-rows 属性中定义的行和列。果你在网格定义之外又放了一些东西，或者因为内容的数量而需要的更多网格轨道的时候，网格将会在隐式网格中创建行和列。按照默认，这些轨道将自动定义尺寸，所以会根据它里面的内容改变尺寸。 上面这句话更加通俗的说就是只有具有 grid-template-columns 和 grid-template-rows同时声明的网格才是显式网格。 4.1 例一1234567&lt;div class=&quot;wrapper&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;Two&lt;/div&gt; &lt;div&gt;Three&lt;/div&gt; &lt;div&gt;Four&lt;/div&gt; &lt;div&gt;Five&lt;/div&gt;&lt;/div&gt; 123.wrapper &#123; display: grid;&#125; 此时为隐式网格 4.2 例二1234.wrapper &#123; display: grid; grid-template-columns: 50px repeat(2, 1fr);&#125; 此时虽定义了列宽，但并未定义行高，行高为自适应，仍未隐式网格。 4.3 例三12345.wrapper &#123; display: grid; grid-template-columns: 50px repeat(2, 1fr); grid-template-rows：60px; &#125; 此时定义了三列一行，所以第一行高为60px，第二行高仍未自适应且为自动创建的隐式网格，尽管它继承了列宽； 第一行为显示网络，有行列共同声明。 4.4 例四123456.wrapper &#123; display: grid; grid-template-columns: 50px repeat(2, 1fr); grid-template-rows：60px; grid-auto-rows：50px; &#125; 为隐式网格定义行高，而显示网格仍未60px，并未受影响。 5. 轨道大小和minmax()grid-auto-rows：minmax(50px,auto) 定义了隐式网格的行高最小为50px，超出50px后高度自适应。 6. 网格线Grid 会为我们创建编号的网格线来让我们来定位每一个网格元素. 例如下面这个三列两行的网格中，就拥有四条纵向的网格线。 7. 网格单元一个网格单元是在一个网格元素中最小的单位， 从概念上来讲其实它和表格的一个单元格很像。 参考链接未完待续。。。。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弹性布局（flex）]]></title>
    <url>%2Fnote%2F2018%2Fundefined28%2F5c7aade3.html</url>
    <content type="text"><![CDATA[声明：本文大部分摘自别处，链接在文末给出。 1. Flex布局Flex 是 Flexible Box 的缩写，意为”弹性布局”。W3C针对布局设计的新标准，相对float和position会更加灵活处理父元素和子元素之间布局关系，让布局更加直观和灵活简单。有效的针对不同屏幕宽度大小的情况下，让元素自动有效合理处理布局结构。 适用范围弹性盒子布局主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。 1.1 Flex布局基本概念 1.1.2 弹性容器(Flex container)通过设置 display 属性的值为 flex 或 inline-flex来定义弹性容器。 就像blockandinline-block作用于描绘对象，对于其子元素当然不会有效果。 1.1.3 弹性项目(Flex item)弹性容器里子元素自动成为弹性项目，并且弹性项目的float、clear和vertical-align属性将失效。 1.1.4 轴(Axis) 主轴（main axis） 交叉轴（cross axis） 这个2个轴决定了容器里的项目整体布局效 1.2 Flex容器属性 flex-direction flex-wrap flex-flow justify-content align-items align-content 1.2.1 flex-direction决定主轴方向，默认情况下，元素都是从左到右地分布在主轴上4个取值： flex-direction: row | row-reverse | column | column-reverse; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 依次如下图： 1.2.2 flex-wrap是否可以换行（默认不换行），以及如果可以换行，如何排列 3个取值 flex-wrap: nowrap | wrap | wrap-reverse; nowrap: 默认不换行 wrap: 可以多行，第一行在上方 wrap-reverse: 可以多行，第一行在下方 1.2.3 flex-flowflex-direction 和 flex-wrap 的简写,默认row nowrap flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; 1.2.4 justify-content属性定义了项目在主轴上的对齐方式。.box { justify-content: flex-start | flex-end | center | space-between | space-around;} 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 1.2.5 align-items决定交叉轴的对齐方式 1234567align-items: flex-start | flex-end | center | baseline | stretch;flex-start: 交叉轴起点对齐flex-end: 交叉轴终点对齐center: 交叉轴居中对齐baseline: 第一行文字的底部对齐stretch: （默认）如果项目木有设置高度或者高度为auto,那么项目拉伸充满整个交叉轴空间 注意：记住justify-content是沿着主轴的，align-items是沿着交叉轴的，而flex-direction是转换主轴的。这对整体移动元素很关键。 1.2.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 详参：align-content更多属性,MDN. 1.3 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 1.3.1 orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 1.3.2 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 该属性可能取6个值，除了auto，其他都与align-items属性完全一致 1align-self: auto | flex-start | flex-end | center | baseline | stretch; 1.3.3 flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 1.3.4 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 1.3.5 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。当width与flex-basis同时存在以后者宽度为准。flex-basis 和 width 不同的地方是，它是和 flex 坐标轴保持一致的，flex-basis是影响主轴上大小。即当flex-direction为默认row时，flex-basis为项目宽度。当flex-direction属性值为column时，flex-basis值为项目高度。 1.3.6 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 参考链接通过动图形象地为你介绍 flexbox 是如何工作的（一）Flex 布局教程：语法篇flex基础布局详解使用 CSS 弹性盒子]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《批判性思维》]]></title>
    <url>%2Fnote%2F2018%2Fundefined27%2F50fabfb3.html</url>
    <content type="text"><![CDATA[批判性思维：思维、沟通、写作、应变、结决问题的根本技巧 (美)保罗，（美）埃尔德著 这个版本的翻译真的令人很不满意，如果可以就不要看这一版。坑 序论 我们就好比学样的猴子，只知道机械的模仿却不明就里。如果你开始用类似于植物学家观察植株的方式来对思维过程加以关注，你将会成为一个非凡杰出的人。你会开始注意到很少有人关注的事情。你会成为一只少有的杰出的猴子，了解模仿动作的含义，知道自己该如何模仿，以及为什么模仿，并明白如何评估和改进模仿的技巧。 只有当你清楚地意识到自己在怎样进行思考，并且努力地去认识这种思考所包含的优势和弱点时，当你建造了“大屏幕”来观看自己的思维过程后，你才逐渐成为思考者。 批判性思维：自我监控和自我改进的思维方式。 我们常说的三思而后行。在进行任何决策和行为前，要对将要发生的进程进行预判。比如要去吃饭，到吃饭的时间了吗，还是想逃避眼前的事情。要吃什么饭，面还是米。吃完饭直接回来吗，还是溜达一圈再回来。 第一章成为公正的思考者高级批判性思维高级批判性思维者致力于做到公正无私。这样就避免了利用自己的技巧来侥胜对方，我们用同样的高标准来衡量所有的思维过程。希望那些支持和反对我们的人所进行的推理都是出色的。对那些我们无情反驳和对自己的推理都用同样的标准来要求。我们要质疑自己的的证据、结论、暗示和观点，一如质疑他人的这些思维要素。 公正思维有何要求公正思维必须力争不偏不倚和毫无偏见的态度来对待和某情景有关的是所有观点，不受个人感受或私利的左右，也不受朋友，团体的感受或利益的影响。 做到公正思维必须同时具备 态度谦逊 勇敢无畏 设身处地 诚实 坚持不懈 笃信推理 意志自由 态度谦逊：吾生也有涯，而知也无涯态度谦逊可以定义为对个体知识局限性的清楚认识，避免一叶障目，管中窥豹。同时也要思考自己的观点、想法的来源是否正确偏颇。 了解肤浅的认识 选择一门自己取得高分的课程，然后思考以下问题 学习这门课的目的是什么？ 这个领域的工作者都在努力达到什么样的目标？ 他们一般会提出什么样的问题？ 他们一般致力于解决什么样的问题？ 他们搜集什么样的数据或者信息？ 他们是怎样以该领域所特有的方式来搜集信息的？ 这领域最基本的观念或者理论是什么？ 对于该领域的学习是怎样改变你对世界的看法的？ 勇敢无畏：勇于挑战信念 “从来如此，便对吗？”__鲁迅 当自己的观点、信念被质疑时，要勇于克服被别人否定的恐惧。 不要害怕犯错误，同时也要勇于质疑。 我不会随意认同任何信念的内容，我只认同自己形成这些信念的过程，紧紧跟随证据和推理引领的方向，摒弃那些不为证据或理性思考所支持的信念。 设身处地：考察对立观点若想做到设身处地，就得准确地重建他人观点和推理过程。当我们以自我为中心进行思考时，就无法理解其他人的想法、感受和情绪。 坚持不懈：排除万难，战胜挫折当一个人在面对脑力劳动的困难与挫折而不放弃时，此人就具备了坚持不懈。如果缺乏坚持不懈，就无法对学科进行透彻思考，进而获得远见卓识。竭力避免头脑的挫折，获得的却是因为无法解决日常生活中的复杂问题而日益滋生的挫败感。 同时我们要避免过于苛求证据，避免对自己的推论和解释过于苛责，避免锱铢必较。一定程度上的自负是必要的。 第二章 思维发展的起初四个阶段成为一个出色的思考者，一般要经过以下阶段 第一个阶段：轻率鲁莽的思考者（我们对自己思维过程中的重大问题一无所知） 第二个阶段：面临挑战的思考者（我们开始意识到自己思维中存在的问题了） 第三个阶段：初出茅庐的思考者（我们尝试着提高自己的思维技巧，但是缺乏有规律的训练） 第四个阶段：实践操练的思考者（我们意识到了有规律训练的必要性） 第五个阶段：技艺高超的思考者（随着训练的深入我们的思维技巧与日俱进） 第六个阶段：思想大师（技艺非凡和富有洞见的思考成为我们的第二本能） 第三个阶段：初出茅庐的思考者在这个阶段，开始着手提升自己的价值观。 有哪些对塑造思想产生了重大影响： 你诞生于某种文明之中（欧洲文明、非洲文明、美洲文明以及亚洲文明） 你在某个时间点诞生（某个世纪的某一年） 你在某地出生（某个国家，某个城市，南方或北方，东方或西方） 你是由具有特定信仰的父母所抚养（关于家庭，人际关系，婚姻，宗教，政治，教育） 。。。。。 如果能改变上面的某种影响，那么信念体系会截然不同。 第三章 理解自我 对待事情要以积极的态度进行思考，态度与行动是相互影响的。好心情会笑，反过来笑也可以带动好心情。 大脑自我催眠说：真好吃。 嗯 嘴巴说：哎，果然好好吃啊。 你说你大脑骗起自己的身体来，会有多可怕的能量。所以，要好好利用。 第四章推论：根据已知正确，或看上去正确的事物，得出其他事物的正确性。 假设：认为理所当然或者预先假定的东西，通常为我们已知且深信不疑，是我们信念体系的一部分。 第五章:思维的衡量标准思维的8大元素：1、目的：我是要干嘛？达到什么目的？2、悬而未决的问题：根据这个目的遇到的最主要问题或者议题是什么？3、信息：为了解决这个问题我需要收集哪些信息、数据、事实或者经验？4、解释和推理：根据掌握的信息进行解释或者推理。5、概念：界定解决问题中出现的理论、定义、规则、原理、模式等概念，统一标准。6、假设：清楚在解释和推理中隐含的假设条件什么？7、结果和意义：通过逻辑得出意义和结果是什么？8、观点：从哪个角度、视角出发来解决问题的？ 推理的要素，为了结论正确，需要确保的得出结论的过程正确。对于每个思维元素都应该综合考虑是否达到了思维的标准。 思维的9大标准 ： 清楚 正确 精确 深度 广度 切题 有逻辑性 有意义 公正 作为一个批判性思维者，我们应该对自己的思想提出如下问题：我的思路清晰吗？正确吗？精确吗？切题吗？是否有逻辑性？我所思考的事情有意义吗？在一定的场合中正当吗？ 清楚 你能解释这一观点吗？ 你能换一种方法表达这个观点吗？ 你能给出图例或例子吗？ 能不能把问题说明白，没有歧义。区分模糊和清楚的观点。 “他是个好人” 这句话就模糊，由于我们不知道这句话发生的场景，就会揣测出不同的意思。 精确 精确意味着给出一些必须的细节，来让别人理解说话人的意思。有时则无需这种细节。比如 冰箱里有没有牛奶，回答 有。已经足够了，一般不用回答出还有多少 “小明超重了” 这句话清楚正确却不精确，我们不知道超重了多少，一斤、两斤 深度 面对吸毒问题应该采取什么措施，答 拒绝毒品。 广度 从不同的角度考虑问题 第六章 正确提问引发出色思维思维不是由答案，而是由问题推动的。问题体现了要完成的任务和存在的疑点，而答案往往是思考的终结。 思维应当能结出果实，否则就一无所用。 三类问题： 事实性问题。 这种问题只要一个正确答案。 比如：水的沸点有多大？ 见仁见智问题。这类问题因人看法不同，以主观性为主 比如：你喜欢留什么样的发型？ 判断性问题。这种问题需要推理，对此问题的回答，不能太主观。可以用思维的标准来进行检验。 如：清楚，深度，广度等。一个复杂的问题往往跨越多个思维领域。（心理学，社会学，经济学，生物学，政治，道德） 比如：死刑应该被取消吗？ 成为苏格拉底式的提问者 苏格拉底式的提问的基本原理： 试着去理解一种见解或看法的根本基础，并在以后的问题中遵循这些基础。（例如：你的信念依据是什么？你能更详细低解释自己的思想，让我更好地理解你的观点吗？） 只有当一种思想和其他思想共同形成一个网络时，它才能完整的存在。因此，应当把所有的主张都当做引发更多思考的连接点，寻找它们之间的联系。就是我们所说发散性思维。（例如：如果你所说属实，那x或y不也如此吗？） 所有的问题都是环环相扣的，思考也是如此。因此，提出问题时，也不要忘记了它们会引发的其他问题。（例如：要回答这个复杂的问题，还需要回答其他相关的问题？） 除了以苏格拉底的方式进行提问，还以从以下几个方面进行提问： 围绕思维的衡量标准提出问题 围绕思维要素提出问题 围绕先验问题发问 我们在处理复杂的问题时，要设计先验问题–即回答复杂问题之前需要解决的问题。 要回答“什么是多元文化主义“要先解决”解决什么是文化“又应该先回答”决定文化归属的因素是什么“ 围绕思维领域提出问题（历史，政治，文化，心理，经济） 第七章 精通思考，掌握知识 每门课程的知识都体现了独特的思维方式。 所有的知识都是由人类思想所创造；他们由思想形成、分析、合成、表达、评价、重建、改造；也是通过思想来学习，理解并应用。如果试图把知识和思想分开，那么将什么也得不到。 第八章 规划你的学习 大学课程的规划 弄懂课程中的基本概念 找出每门课程必须的思维模式 运用学科逻辑进行思考。 为自己规划课程 第九章 评估你的学习自我评价策略自我评价对批判性思维至关重要，所以应该好好规划而不是随便看待。每天都要对自己的学习质量进行评价，经常使用思维的衡量标准来判断。 专业掌握情况的通用描模板顺利修完xx专业的学生会表现出一系列xx思考技能，用以掌握知识。他们在课程结束后的作业清楚、准确、合理。他们掌握了xx的基本术语和辨析，可以解决基本的xx问题。从作业中可以看出，他们可以驾驭自己的xx思想、假设、推论和思考过程。 他们能够清晰准确的xx问题，正确陈述xx信息，区分有关信息和无关信息，找出可以的xx假设前提，清楚解释基本xx概念，使用xx术语，能够确认不同的观点，往往会从明确的前提出发去推论，对重要的xx涵义和后果非常敏感。他们表现出优秀的xx思维技巧和解决问题的能力。 上面的xx可以用专业去替换，比如可以替换为历史、哲学、数学…… 在简历里进行自我描述时，可以对上面的模板进行借鉴。 一直以来，我们听惯了大道理，学了太多的屠龙术。比如每天坚持学英语几年之后，你的英语会灰常厉害。然而，对于每条大道理，大多数的我们很少能够贯彻下去。本书也是一本很厉害的屠龙术，读的过程中让我反复意识到自己有多差劲，大道是无尽的。读来还是很有好处的，对于其描述虽不能完全执行，但总还能学的些皮毛，读来总能有些启发。 思考让思想更有力量。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超链接与伪类]]></title>
    <url>%2Fnote%2F2018%2Fundefined15%2F59c34dbb.html</url>
    <content type="text"><![CDATA[在 HTML 4.01 中，&lt;a&gt; 标签可以是超链接或锚。在 HTML5 中，&lt;a&gt; 标签始终是超链接，但是如果未设置 href 属性，则只是超链接的占位符,则不可以使用如下属性：download, hreflang, media, rel, target 以及 type 属性,此时color等无法设置属性值。 a:link /* 未访问的链接 */ a:visited /* 已访问的链接 */ a:hover /* 鼠标移动到链接上 可以用在表格上*/ a:focus /*获得焦点状态 可以用在输入框上*/ a:active /* 选定的链接 激活发生在链接被点击时 可以用在提交按钮上*/ 上面的次序很重要，否则有些样式会不起作用。次序为：lvhfa。简单记法：Lord Vader Hate Furry Animals。 1. 突出显示不同类型的链接1.1如图给链接加个小图标 实现方法： 1.可用img直接vertical-align：top； 在超链接上通过background来实现。 同理，如果想实现在文字的下面加些特殊的下划线，也可通过background把图片定到文字下。 1.2 给链接在focus状态下加个下标线 通过 a { text-decoration: none;} a:focus{ padding-bottom: 22px; border-bottom: 2px solid red } 启示：通过伪类状态的不同属性（link,visited,hover,focus,active）,可以在不同的属性下设置一些不同的样式，比如focus时文字背景颜色变为红色 2 图像翻转不同伪类状态属性时文字的背景图片不同，可以营造一种错觉的的图像翻转，就是把文字的背景颜色变为背景图像。 2.1pixy方法由于这种方法在在第一次加载图像时会有点迟钝，因此我们可以将悬停的图像作为背景应用于父元素，从而预先加载他们。再进一步，可以把多个图像放在一个背景图像的不同位置，因此减少了服务器请求的数量。把所有图像放在同一个位置的方法叫做pixy方法。（pixy是发明者的昵称） 2.2 css精灵多个服务器请求会对站点的性能产生显著的影响，所以在pixy方法的启示下，可以把一个网站的所有图标和，图形等放在一个图像上。这就是css精灵。 然而在个人的实践下，这种方法并不好用，对各个图像的位置要求比较大，为此需要的花费好多时间进行调试。所以使用与否看需求了。 2.3 文字图像同时翻转在这里进行图像翻转的同时，文字是不变的。要想实现文字与背景都改变，需要用到text-indent与position:absloute，然而这两者会产生放一起会产生奇特的化学反应。即当 父元素的text-indent作用于文字时position:absloute里的文字会一起移动，position:absloute的原位仍在，但对其文字失去控制能力。如下： &lt;div id=&quot;hh&quot;&gt; &lt;div id=&quot;ff&quot;&gt;fdsklfj&lt;/div&gt; 我是按钮链接 &lt;/div&gt; #hh{width:500px; text-align: center;background-color: grey;} #ff{ width:100px; position: absolute; top: 0; left: 0; } 当对#hh添加text-indent:100px时,盒子ff的文字会一起移动; 为解决这个问题我们可以使用覆盖的方式。如下两个同级元素，由于盒子hh完全被盒子ff的绝对定位覆盖即盒子ff层次在盒子hh之上，此时位于下面的盒子#hh:hover失效 &lt;div id=&quot;hh&quot;&gt; 我是按钮链接 &lt;/div&gt; &lt;div id=&quot;ff&quot;&gt;fdsklfj&lt;/div&gt; #hh{width:500px; text-align: center;background-color: grey; } #hh:hover{ text-indent: 1000px;} #ff{ width: 500px; position: absolute; top: 8px; left: 8px; } #ff:hover{text-align: center; color:yellow} 对#ff:hover添加background-color:red 3 悬停下拉菜单 &lt;ul id=&quot;one&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;Products&lt;/a&gt; &lt;ul id=&quot;two&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Services&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Contact Us&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Services&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Contact Us&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; #one li { list-style: none; float: left; border:1px solid #486b20;background-color: #8bd400; width: 85px;} #one li a{text-decoration: none;} #two {position: absolute; left: -1000px; padding: 0; } #one li:hover #two{ left: auto; } #two li{ float: none; width: 85px; } 下拉菜单的难点在于#one li:hover #two{ left: auto; },通过父元素的状态来控制子元素。 4.锚锚可以作为内部引用，也可以作为外部链接。 &lt;a href=&quot;#na&quot;&gt;one&lt;/a&gt; &lt;a href=&quot;&quot; id=&quot;jump&quot;&gt;two&lt;/a&gt; ...... &lt;a name=&quot;na&quot;&gt;three&lt;/a&gt; &lt;a href=&quot;#jump&quot;&gt;four&lt;/a&gt; 点击one会跳到three，点击four会跳到two。 name属性在H5中不在支持。 5.backgroundbackground-repeat repeat 默认。背景图像将在垂直方向和水平方向重复。 repeat-x 背景图像将在水平方向重复。 repeat-y 背景图像将在垂直方向重复。 no-repeat 背景图像将仅显示一次。 inherit 规定应该从父元素继承 background-repeat 属性的设置 background-sizecover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。 contain 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域 可用长度百分比（顺序宽高），如果只设置一个值，第二个值auto； 详参http://www.w3school.com.cn/cssref/pr_background-size.asp]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《JavaScript高级程序设计》（1）]]></title>
    <url>%2Fnote%2F2018%2Fundefined13%2F556216f0.html</url>
    <content type="text"><![CDATA[[美] Nicholas C.Zakes 著 李松峰 曹力 译 （第三版） 本文以JS高程为主线， 阮一峰的《 JavaScript标准参考教程》为辅。 第一章 JavaScript简介 第二章 在HTML中使用JavaScript 第三章 基本概念 （语法、关键字、保留字、数据类型，操作符、语句） 第一章 JavaScript简介1.1 JavaScript简史由于网页的大小和复杂性不断增加以及网速的限制。为完成简单的表单验证（是否没有填写某个必填项，是否输入了无效的值）而频繁地与服务器交换数据只会加重用户的负担，为此，1995年当时就职于Netscape公司的Brendan Eich为Netscape Navigator开发了一种名为LiveScript的脚本语言–该语言可同时在浏览器的与服务器中使用（仅在客户端就可以完成简单的验证），为了搭上热炒Java的顺风车，改名为JavaScript。 微软为与Netscape竞争，在自家的IE浏览器里加入了JScript，就有了两个不同的JavaScript版本，为了标准化，由欧洲制造商协会（ECMA，European Computer MAnufacturers Association）牵头来自一些公司程序员共同制定了ECMA-262–定义一种名为ECMAScript(发音为“ek-ma-script”)的新脚本语言标准。 1.2 JavaScript实现一个完整的JavaScript实现应该有以下三个不同的部分组成 核心（ECMAScript）：提供核心语言功能； 文档对象模型（DOM）：提供访问和操作网页内容的方法和接口； 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。 1.2.1 ECMAScript由ECMA-262定义的ECMAScript与浏览器没有依赖关系，web浏览器只是其实现可能的宿主环境之一。主要定义了核心语言功能： 语法 类型 语句 关键字 保留字 变量 操作符 1.2.2 文档对象模型（DOM）文档对象模型（DOM,Document Object Model）是针对XML但经过扩展用于HTML的应用程序接口（API，Application Programmaing Interface）。DOM把整个页面映射为一个多层节点结构，形成dom树开发人员获得页面内容和结构的控制权，借助DOM提供的API，开发人员可以轻松自如地删除，添加，替换和修改任何节点。 第二章 在HTML中使用JavaScript2.1 &lt;script&gt;元素向HTML页面中插入JavaScript的主要方法就是使用&lt;script&gt;元素,在页面中正常情况下按先后顺序依次解析。HTML4.0为&lt;script&gt;定义了下列六个属性 async：可选。表示立即下载脚本，但不妨碍页面中的其他操作。 charset：可选。很少用，忽略。 defer：可选；表示立即下载脚本，但可以延迟到文档完全被解析和显示之后再执行。现实中如果有多个延迟脚本，不一定会按照顺序执行，所以最好只包含一个。 language：已废弃。 src：可选。表示包含要执行代码的外部文件地址。 type：可选。 2.2 嵌入代码与外部文件2.2.1 嵌入代码12345&lt;script type="text/javascript"&gt; function sayHi（）&#123; alert（"Hi!"） &#125;&lt;/script&gt; 不能在嵌入的代码中任何地方出现&lt;/script&gt;,这会让浏览器产生一个错误。可通过转义字符“\”,&lt;\/script&gt;. 2.1.2 嵌入外部文件1&lt;script type="text/javascript" src= "example.js" &gt; &lt;/script&gt; 标签之间不应该包含额外的代码块，会被忽略，只解析外部脚本文件。为减少呈现页面的延迟，通常把JavaScript的引用放在内容之后&lt;/body&gt;之前。 2.3 &lt;noscript&gt;元素当浏览器不支持js时如何让页面平稳地退化，创造一个&lt;noscript&gt;元素，这个标签能够出现在&lt;body&gt;中的任何HTML元素——&lt;script&gt;元素除外。包含在&lt;noscript&gt;元素中的内容在以下情况才会显示出来： 浏览器不支持脚本 浏览器支持脚本，但被禁用。 &lt;noscript&gt; &lt;p&gt;本页面需要支持（启用）JavaScript&lt;/p&gt; &lt;/noscript&gt; 第三章 基本概念3.1 语法ECMAScript的语法大量借鉴了C及其它类C语言（如java和perl）的语法。 3.1.1 区分大小写ECMAScript中的一切（变量，函数名和操作符）都区分大小写。 3.1.2 标识符标识符，就是指变量、函数、属性的名字，或者函数的参数。 书写要求： 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）; 其他字符可以是字母、下划线、美元符号或数字。 标识符中的字母也可以包含扩展的ASCII 或Unicode 字母字符。但不推荐这样做。 按惯例，标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词首字母大写。不能把关键字，保留字，true，false和null用作标识符。 JavaScript有一些保留字，关键字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 否则在严格模式下，可能会抛出错误。 3.1.3 注释使用C风格的注释。单行注释//单行注释，/*块级注释*/。块级注释中，每个行首也可加*号，提高注释的可读性。 此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以&lt;!--和--&gt;也被视为合法的单行注释。 12x = 1; &lt;!-- x = 2;--&gt; x = 3; 上面代码中，只有x = 1会执行，其他的部分都被注释掉了。 需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。 1234567function countdown(n) &#123; while (n --&gt; 0) console.log(n);&#125;countdown(3)// 2// 1// 0 上面代码中，n --&gt; 0实际上会当作n-- &gt; 0，因此输出2、1、0。 3.1.4 严格模式严格模式是为JavaScript定义了一种不同的解析与执行模型。一些不确定的行为将会的到处理，不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： “use strict”; 其实它是一个编译指示，告诉JS引擎切换到严格模式。也可以指定函数在严格模式下执行，在函数内部的上方添加编译指示： 1234function doSomething( ) &#123; &quot;&quot;use strict&quot;; //函数体&#125; 3.1.5 语句ECMAScript中的语句以一个分号结尾；如果省略分号，则由解析器花费时间推测语句的结尾，也有可能会导致压缩错误。 1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。 分号前面可以没有任何内容，JavaScript引擎将其视为空语句。 1;;; 上面的代码就表示3个空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。 3.2 关键字和保留字关键字：用于表示控制语句的开始或结束，或者用于执行特定的操作等。 保留字：虽然还没有任何特定用途，但他们将来有可能被用来关键字。 3.3 变量JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型，有效但不推荐。 每个变量仅仅是一个用来保存值的占位符而已。 变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 1var a = 1; 上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a。以后，引用变量名a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。 变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。 12var a;a = 1; 如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。 123var a = 1;// 基本等同a = 1; 但是，不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量， 用var操作符定义的变量将成为定义该变量作用域的局部变量即如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁，在函数外部不能被访问到。 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。 12x// ReferenceError: x is not defined 上面代码直接使用变量x，系统就报错，告诉你变量x没有声明。 可以在同一条var命令中声明多个变量。 1var a, b; 如果使用var重新声明一个已经存在的变量，是无效的。 123var x = 1;var x;x // 1 上面代码中，变量x声明了两次，第二次声明是无效的。 但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值 3.3.1 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。 12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。 123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 刚在谷歌浏览器控制台测试，上面代码块1，结果是显示undefined， 2结果为1。火狐中代码块1，2结果都为1。是否可以认为，js引擎更智能了？？ 3.4 数据类型JavaScript 的数据类型，共有六种。可分为两类：（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。） 基础类型又叫原始值，复杂类型又叫对象值。（所以为从英文翻译过来对于理解就是麻烦事） 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 对象是最复杂的数据类型，又可以分成三个子类型。 狭义的对象（object） 数组（array） 函数（function） 狭义的对象和数组是两种不同的数据组合方式 函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量 。 3.4.1 typeof 操作符JavaScript 有三种方法，可以用来检测给定变量的数据类型。 typeof运算符 instanceof运算符 Object.prototype.toString方法 数值、字符串、布尔值分别返回number、string、boolean，函数返回function 。null返回object ，对象返回object 。undefined返回undefined 。 undefined返回undefined 。 利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。 12345v// ReferenceError: v is not definedtypeof v// "undefined" 上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined. 这样做没有意义，严格模式下会导致错误。 实际编程中，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === "undefined") &#123; // ...&#125; 对象返回object。 123typeof window // &quot;object&quot;typeof &#123;&#125; // &quot;object&quot;typeof [] // &quot;object&quot; 上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。 12345var o = &#123;&#125;;var a = [];o instanceof Array // falsea instanceof Array // true 3.4.2 null 和 undefinedundefined 类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。 声明并未加以初始化与尚未定义即未声明且未初始化的变量是不一样的。 null也是只有一个值的数据类型，这个特殊值时null.从逻辑角度来讲null值表示一个空对象指针。 如果定义的变量准备在将来用于保存对象，就应该明确的让变量保存null值。然而没有必要把变量的值显示的设为undefined。 相等性测试 12alert （null == undefined）// truenull === undefined // false 实际上undefined值派生于null值，引入undefined值是为了正式区分空对象指针与未经初始化的变量。 undefined表示“未定义”，下面是返回undefined的典型场景。 1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined 3.4.3 布尔值(boolen)布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN &quot;&quot;或&#39;&#39;（空字符串） 3.4.4 数值（number）1. 整数和浮点数JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 11 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 120.1 + 0.2 === 0.3// false 计算机内是用二进制进行存储，在浮点数转化为二进制时会发生取舍，所以0.1可能是0.100002。 2. 数值精度根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。 1(-1)^符号位 * 1.xx...xx * 2^指数部分 上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。 精度最多只能到53个二进制位，这意味着，绝对值小于等于2的53次方的整数，即-253到253，都可以精确表示。 1234567891011121314Math.pow(2, 53)// 9007199254740992 Math.pow(2, 53) + 1// 9007199254740992Math.pow(2, 53) + 2// 9007199254740994Math.pow(2, 53) + 3// 9007199254740996Math.pow(2, 53) + 4// 9007199254740996 上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。 123456Math.pow(2, 53)// 9007199254740992// 多出的三个有效数字，将无法保存9007199254740992111// 9007199254740992000 上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的111）都会无法保存，变成0。 3. 数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。 1Math.pow(2, 1024) // Infinity 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 1Math.pow(2, -1075) // 0 下面是一个实际的例子。 1234567var x = 0.5;for(var i = 0; i &lt; 25; i++) &#123; x = x * x;&#125;x // 0 上面代码中，对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。 JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。 12Number.MAX_VALUE // 1.7976931348623157e+308Number.MIN_VALUE // 5e-32 4. 数值的进制使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 十进制：没有前导0的数值。 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。 十六进制：有前缀0x或0X的数值。 二进制：有前缀0b或0B的数值。 默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。 1230xff // 2550o377 // 2550b11 // 3 如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。 1230xzz // 报错0o88 // 报错0b22 // 报错 上面代码中，十六进制出现了字母z、八进制出现数字8、二进制出现数字2，因此报错。 通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。 120888 // 8880777 // 511 前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。 数值也可以采用科学计数法表示，下面是几个科学计数法的例子。 科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。 以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。 （1）小数点前的数字多于21位。 123451234567890123456789012// 1.2345678901234568e+21123456789012345678901// 123456789012345680000 （2）小数点后的零多于5个。 123456// 小数点后紧跟5个以上的零，// 就自动转为科学计数法0.0000003 // 3e-7// 否则，就保持原来的字面形式0.000003 // 0.000003 5. NaN（1）含义 NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），表示一个本来要返回数值的操作数未返回数值的情况。主要出现在将字符串解析成数字出错的场合。 15 - &apos;x&apos; // NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。 另外，一些数学函数的运算结果会出现NaN。 123Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN 0除以0也会得到NaN。 10 / 0 // NaN 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。 1typeof NaN // &apos;number&apos; （2）运算规则 NaN不等于任何值，包括它本身。 1NaN === NaN // false 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。 1[NaN].indexOf(NaN) // -1 NaN在布尔运算时被当作false。 1Boolean(NaN) // false NaN与任何数（包括它自己）的运算，得到的都是NaN。 1234NaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN （3）isNaN() 这个函数只接受一个参数，该参数可以是任何类型，如果能够转化为数值，函数返false。反之任何不能被转化为数值的值都会导致函数返回true。 6. Infinity（1）含义 Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。 1234567// 场景一Math.pow(2, 1024)// Infinity// 场景二0 / 0 // NaN1 / 0 // Infinity 上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回Infinity。第二个场景是0除以0会得到NaN，而非0数值除以0，会返回Infinity。 Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。 1234Infinity === -Infinity // false1 / -0 // -Infinity-1 / -0 // Infinity 上面代码中，非零正数除以-0，会得到-Infinity，负数除以-0，会得到Infinity。 由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，而是返回Infinity，所以单纯的数学运算几乎没有可能抛出错误。 Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。 12Infinity &gt; 1000 // true-Infinity &lt; -1000 // true Infinity与NaN比较，总是返回false。 12345Infinity &gt; NaN // false-Infinity &gt; NaN // falseInfinity &lt; NaN // false-Infinity &lt; NaN // false （2）运算规则 Infinity的四则运算，符合无穷的数学计算规则。 12345 * Infinity // Infinity5 - Infinity // -InfinityInfinity / 5 // Infinity5 / Infinity // 0 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。 1230 * Infinity // NaN0 / Infinity // 0Infinity / 0 // Infinity Infinity加上或乘以Infinity，返回的还是Infinity。 12Infinity + Infinity // InfinityInfinity * Infinity // Infinity Infinity减去或除以Infinity，得到NaN。 12Infinity - Infinity // NaNInfinity / Infinity // NaN Infinity与null计算时，null会转成0，等同于与0的计算。 123null * Infinity // NaNnull / Infinity // 0Infinity / null // Infinity Infinity与undefined计算，返回的都是NaN。 12345undefined + Infinity // NaNundefined - Infinity // NaNundefined * Infinity // NaNundefined / Infinity // NaNInfinity / undefined // NaN 要想确定一个数是不是有穷，可以使用isFinite()函数，如果参数位于最小值和最大值中间会返回true。 7. 数值转换 Number() 可用于任何数据类型 parseInt()和parseFloat()两个函数用于把字符串转化为数值 7.1 使用Number函数，可以将任意类型的值转化成数值。下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。 （1）原始类型值 原始类型值的转换规则如下。 123456789101112131415161718192021// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&apos;324&apos;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&apos;324abc&apos;) // NaN// 空字符串转为0Number(&apos;&apos;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0 Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。 12parseInt(&apos;42 cats&apos;) // 42Number(&apos;42 cats&apos;) // NaN 上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。 另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。 12parseInt(&apos;\t\v\r12.34\n&apos;) // 12Number(&apos;\t\v\r12.34\n&apos;) // 12.34 （2）对象 简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。 123Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5 之所以会这样，是因为Number背后的转换规则比较复杂。 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 第三步，如果toString方法返回的是对象，就报错。 7.2 parseInt()（1）基本用法 parseInt方法用于将字符串转为整数。 1parseInt(&apos;123&apos;) // 123 如果字符串头部有空格，空格会被自动去除。 1parseInt(&apos; 81&apos;) // 81 如果parseInt的参数不是字符串，则会先转为字符串再转换。 123parseInt(1.23) // 1// 等同于parseInt(&apos;1.23&apos;) // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。 12345parseInt(&apos;8a&apos;) // 8parseInt(&apos;12**&apos;) // 12parseInt(&apos;12.34&apos;) // 12parseInt(&apos;15e2&apos;) // 15parseInt(&apos;15px&apos;) // 15 上面代码中，parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 12345parseInt(&apos;abc&apos;) // NaNparseInt(&apos;.3&apos;) // NaNparseInt(&apos;&apos;) // NaNparseInt(&apos;+&apos;) // NaNparseInt(&apos;+1&apos;) // 1 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。 1parseInt(&apos;0x10&apos;) // 16 如果字符串以0开头，将其按照10进制解析。 1parseInt(&apos;011&apos;) // 11 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 1234567parseInt(1000000000000000000000.5) // 1// 等同于parseInt(&apos;1e+21&apos;) // 1parseInt(0.0000008) // 8// 等同于parseInt(&apos;8e-7&apos;) // 8 （2）进制转换 parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。 123parseInt(&apos;1000&apos;) // 1000// 等同于parseInt(&apos;1000&apos;, 10) // 1000 下面是转换指定进制的数的例子。 123parseInt(&apos;1000&apos;, 2) // 8parseInt(&apos;1000&apos;, 6) // 216parseInt(&apos;1000&apos;, 8) // 512 上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。 12345parseInt(&apos;10&apos;, 37) // NaNparseInt(&apos;10&apos;, 1) // NaNparseInt(&apos;10&apos;, 0) // 10parseInt(&apos;10&apos;, null) // 10parseInt(&apos;10&apos;, undefined) // 10 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。 12parseInt(&apos;1546&apos;, 2) // 1parseInt(&apos;546&apos;, 2) // NaN 上面代码中，对于二进制来说，1是有意义的字符，5、4、6都是无意义的字符，所以第一行返回1，第二行返回NaN。 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。 12345678910parseInt(0x11, 36) // 43parseInt(0x11, 2) // 1// 等同于parseInt(String(0x11), 36)parseInt(String(0x11), 2)// 等同于parseInt(&apos;17&apos;, 36)parseInt(&apos;17&apos;, 2) 上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。 这种处理方式，对于八进制的前缀0，尤其需要注意。 1234567parseInt(011, 2) // NaN// 等同于parseInt(String(011), 2)// 等同于parseInt(String(9), 2) 上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt(&#39;011&#39;, 2)，011则是会被当作二进制处理，返回3。 JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。 7.5 parseFloat()parseFloat方法用于将一个字符串转为浮点数。 1parseFloat(&apos;3.14&apos;) // 3.14 如果字符串符合科学计数法，则会进行相应的转换。 12parseFloat(&apos;314e-2&apos;) // 3.14parseFloat(&apos;0.0314E+2&apos;) // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 1parseFloat(&apos;3.14more non-digit characters&apos;) // 3.14 parseFloat方法会自动过滤字符串前导的空格。 1parseFloat(&apos;\t\v\r12.34\n &apos;) // 12.34 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。 123parseFloat([]) // NaNparseFloat(&apos;FF2&apos;) // NaNparseFloat(&apos;&apos;) // NaN 上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。 这些特点使得parseFloat的转换结果不同于Number函数。 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat(&apos;&apos;) // NaNNumber(&apos;&apos;) // 0parseFloat(&apos;123.45#&apos;) // 123.45Number(&apos;123.45#&apos;) // NaN 3.4.5 字符串（String）1.定义字符串就是零个或多个16位Unicode字符排在一起的字符序列，放在单引号或双引号之中。 12&apos;abc&apos;&quot;abc&quot; 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 12&apos;key = &quot;value&quot;&apos;&quot;It&apos;s a long journey&quot; 上面两个都是合法的字符串。 如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。 12345&apos;Did she say \&apos;Hello\&apos;?&apos;// &quot;Did she say &apos;Hello&apos;?&quot;&quot;Did she say \&quot;Hello\&quot;?&quot;// &quot;Did she say &quot;Hello&quot;?&quot; 由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。 字符串默认只能写在一行内，分成多行将会报错。 1234&apos;abc&apos;// SyntaxError: Unexpected token ILLEGAL 上面代码将一个字符串分成三行，JavaScript 就会报错。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234567var longString = 'Long \long \long \string';longString// "Long long long string" 上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 1234var longString = 'Long ' + 'long ' + 'long ' + 'string'; 如果想输出多行字符串，有一种利用多行注释的变通方法。 12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split('\n').slice(1, -1).join('\n')// "line 1// line 2// line 3" 上面的例子中，输出的字符串就是多行 2. 转义反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 需要用反斜杠转义的特殊字符，主要有下面这些。 \0 ：null（\u0000） \b ：后退键（\u0008） \f ：换页符（\u000C） \n ：换行符（\u000A） \r ：回车键（\u000D） \t ：制表符（\u0009） \v ：垂直制表符（\u000B） \&#39; ：单引号（\u0027） \&quot; ：双引号（\u0022） \\ ：反斜杠（\u005C） 上面这些字符前面加上反斜杠，都表示特殊含义。 123console.log(&apos;1\n2&apos;)// 1// 2 上面代码中，\n表示换行，输出的时候就分成了两行。 反斜杠还有三种特殊用法。 （1）\HHH 反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\251表示版权符号。显然，这种方法只能输出256种字符。 （2）\xHH \x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\xA9表示版权符号。这种方法也只能输出256种字符。 （3）\uXXXX \u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\u00A9表示版权符号。 下面是这三种字符特殊写法的例子。 1234567&apos;\251&apos; // &quot;©&quot;&apos;\xA9&apos; // &quot;©&quot;&apos;\u00A9&apos; // &quot;©&quot;&apos;\172&apos; === &apos;z&apos; // true&apos;\x7A&apos; === &apos;z&apos; // true&apos;\u007A&apos; === &apos;z&apos; // true 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。 12&apos;\a&apos;// &quot;a&quot; 上面代码中，a是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。 如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。 12&quot;Prev \\ Next&quot;// &quot;Prev \ Next&quot; 3. 字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 1234567var s = &apos;hello&apos;;s[0] // &quot;h&quot;s[1] // &quot;e&quot;s[4] // &quot;o&quot;// 直接对字符串使用方括号运算符&apos;hello&apos;[1] // &quot;e&quot; 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 123&apos;abc&apos;[3] // undefined&apos;abc&apos;[-1] // undefined&apos;abc&apos;[&apos;x&apos;] // undefined 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 12345678910var s = 'hello';delete s[0];s // "hello"s[1] = 'a';s // "hello"s[5] = '!';s // "hello" 上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。 12var lang = &quot;Java&quot;;lang = lang + &quot;Script&quot; 实现这个操作的过程如下：首先创建一个能容纳10个字符的新字符串然后在这个新字符串中填充&quot;Java&quot;和&quot;Script&quot;，最后一步是销毁原来的&quot;Java&quot;和&quot;Script&quot; 字符串。 5. 转换字符串String函数可以将任意类型的值转化成字符串，转换规则如下。 （1）原始类型值 数值：转为相应的字符串。 字符串：转换后还是原来的值。 布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;。 undefined：转为字符串&quot;undefined&quot;。 null：转为字符串&quot;null&quot;。 12345String(123) // "123"String('abc') // "abc"String(true) // "true"String(undefined) // "undefined"String(null) // "null" （2）对象 String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。 12String(&#123;a: 1&#125;) // &quot;[object Object]&quot;String([1, 2, 3]) // &quot;1,2,3&quot; String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。 先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果valueOf方法返回的是对象，就报错。 下面是一个例子。 123456String(&#123;a: 1&#125;)// &quot;[object Object]&quot;// 等同于String(&#123;a: 1&#125;.toString())// &quot;[object Object]&quot; 上面代码先调用对象的toString方法，发现返回的是字符串[object Object]，就不再调用valueOf方法了。 如果toString法和valueOf方法，返回的都是对象，就会报错。 1234567891011var obj = &#123; valueOf: function () &#123; return &#123;&#125;; &#125;, toString: function () &#123; return &#123;&#125;; &#125;&#125;;String(obj)// TypeError: Cannot convert object to primitive value 下面是通过自定义toString方法，改变返回值的例子。 1234567891011121314151617181920212223String(&#123; toString: function () &#123; return 3; &#125;&#125;)// "3"String(&#123; valueOf: function () &#123; return 2; &#125;&#125;)// "[object Object]"String(&#123; valueOf: function () &#123; return 2; &#125;, toString: function () &#123; return 3; &#125;&#125;)// "3" 上面代码对三个对象使用String函数。第一个对象返回toString方法的值（数值3），第二个对象返回的还是toString方法的值（[object Object]），第三个对象表示toString方法先于valueOf方法执行。 4. length 属性length属性返回字符串的长度，该属性也是无法改变的。 12345678var s = 'hello';s.length // 5s.length = 3;s.length // 5s.length = 7;s.length // 5 上面代码表示字符串的length属性无法改变，但是不会报错。 3.5 操作符操作符是用来操作数据值的。 3.5.1 一元操作符 只能操作一个值的操作符。 1. 递增和递减操作符借鉴C语言，前置性和后置型。（前置自增减，后置自增减） 12var age = 29;++age; 与下面效果相同 12var age = 29;age = age + 1; 自增减操作与执行语句的优先级相等 1234var num1 = 2;var num2 = 20;var num3 = --num1 + num2; // 21 var num4 = num + num2; // 21 第三行等同于： 12var num1 = 2 - 1 ;var num3 = num1 + num2; // 21 本操作符对任何值都适用，将非数值转化为数值。 2. 一元加和减操作符（与加性操作符进行区别） 数值的正负 把非数值转换为数值，与Number函数的作用相同。 1234var s1 = "01";var s2 = "z";s1 = +s1; //值变为数值1s2 = +s2; //值变为NaN 3.5.2 位操作符位运算符用于直接对二进制位进行计算，一共有7个。 js中数值以64位存储，但位操作先将64位转为32位进行操作再将结果转回64位。NaN和Infinity值应用位操作时，被当为0来处理。位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。 二进制或运算符（or）：符号为|，表示若两个二进制位都为0，则结果为0，否则为1。 二进制与运算符（and）：符号为&amp;，两个二进制位都为1，则结果为1，否则为0。 二进制否运算符（not）：符号为~，表示对一个二进制位取反。 异或运算符（xor）：符号为^，二进制位不相同，则结果为1，否则为0。 左移运算符（left shift）：符号为&lt;&lt;， 将数值所有位向左移指定的位数。 右移运算符（right shift）：符号为&gt;&gt;，保留符号位右移。 带符号位的右移运算符（zero filled right shift）：符号为&gt;&gt;&gt;。 对于有符号的整数，前31位表示数值，32位表示数值的正负：0正，1负。这个位置叫符号位。负数同样用二进制码存储，但是使用的是二进制补码。 比如-18的二进制码，先求得18的二进制码，变为反码，反码加1. 按位非（not） ~25 -26 按位与（and） 23 &amp; 3 1 左移 2 &lt;&lt;4 (2:二进制10，移4位100000) 64 按位异（xor） 25 ^ 3 26 3.5.3布尔操作符布尔运算符用于将表达式转为布尔值，一共包含四个运算符。 取反运算符：! 逻辑非 且运算符：&amp;&amp; 逻辑与 或运算符：|| 逻辑或 三元运算符：?: 1. 取反运算符（!）取反运算符是一个感叹号，用于将布尔值变为相反值，即true变成false，false变成true。 12!true // false!false // true 对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。 undefined null false 0 NaN 空字符串（&#39;&#39;） 2. 且运算符（&amp;&amp;）且运算符（&amp;&amp;）往往用于多个表达式的求值。 它的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。 3. 或运算符（||）或运算符（||）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。 4. 三元条件运算符（?:）三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。 3.5.4 乘性操作符三个： 乘法* 除法/ 求模% 乘法如果不是数值，后台会先使用Number（）函数转化为数值。 特殊值： 乘积超过数值范围则返回Infinity或-Infinity 一个是NaN，结果为NaN Infinity*0=NaN Infinity与非零相乘则Infinity或-Infinity Infinity*Infinity=Infinity。 除法 一个是NaN，结果为NaN Infinity / Infinity=NaN 0/0=NaN 3.5.5 加性操作如果其中一个为字符串，则进行拼接。 3.5.6 关系操作符在操作字符串时，比较的是字符串首位字符编码值。 12var result = "23" &lt; "3" //true var result = "Brick" &lt; "alphabet" // true “2”的字符编码50，“3的字符编码”51. B 的编码值66，a是97. javaScript 一共提供了8个比较运算符。 &lt; 小于运算符 &gt; 大于运算符 &lt;= 小于或等于运算符 &gt;= 大于或等于运算符 == 相等运算符 === 严格相等运算符 （不进行转换） != 不相等运算符 !== 严格不相等运算符 3.5.7 逗号操作符逗号操作符多用于声明多个变量；但除此之外还可以用于赋值，用于赋值时总会返回表达式中的去最后一项。 1var num = (5, 1, 4, 0); //num 的值为0。 指数运算符指数运算符（**）完成指数运算，前一个运算子是底数，后一个运算子是指数。 12 ** 4 // 16 赋值运算符赋值运算符（Assignment Operators）用于给变量赋值。 最常见的赋值运算符，当然就是等号（=）。 1234567891011121314151617// 等同于 x = x + yx += y// 等同于 x = x - yx -= y// 等同于 x = x * yx *= y// 等同于 x = x / yx /= y// 等同于 x = x % yx %= y// 等同于 x = x ** yx **= y 3.6 语句3.6.1 条件语句JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。 ifif代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。 if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 12345if (m === 3) &#123; // 满足条件时，执行的语句&#125; else &#123; // 不满足条件时，执行的语句&#125; 对同一个变量进行多次判断时，多个if...else语句可以连写在一起。 123456789if (m === 0) &#123; // ...&#125; else if (m === 1) &#123; // ...&#125; else if (m === 2) &#123; // ...&#125; else &#123; // ...&#125; else代码块总是与离自己最近的那个if语句配对。 123456var m = 1;var n = 2;if (m !== 1)if (n === 2) console.log('hello');else console.log('world'); 上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。 1234567if (m !== 1) &#123; if (n === 2) &#123; console.log('hello'); &#125; else &#123; console.log('world'); &#125;&#125; 如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。 12345678if (m !== 1) &#123; if (n === 2) &#123; console.log('hello'); &#125;&#125; else &#123; console.log('world');&#125;// world switch多个if...else连在一起使用的时候，可以转为使用更方便的switch结构。 12345678910switch (fruit) &#123; case "banana": // ... break; case "apple": // ... break; default: // ...&#125; 上面代码根据变量fruit的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。 需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。 3.6.2 循环语句循环语句用于重复执行某个操作，它有多种形式 while 循环While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。 如果只有一条语句，可以省略大括号，否则就必须加上大括号。 123while (条件) &#123; 语句;&#125; for 循环for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下 123for (初始化表达式; 条件; 递增表达式) &#123; 语句&#125; 初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。 条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。 递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量 省略了for语句表达式的三个部分，结果就导致了一个无限循环。 for-infor-in 语句是一种精准的迭代语句，可以用力枚举对象的属性。 123for(property in expression)&#123; statement&#125; do…while 循环do…while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 123do &#123; 语句&#125; while (条件); 3.7 函数通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。ES中通过function关键字来声明，后跟一组参数及函数体。基本语法如下： 123function functionName (arg0,arg1......argN)&#123; statemnets&#125; 理解参数ES函数不介意传入参数的个数，类型，因为参数在内部使用一个数组表示，无论参数怎样，函数接收的始终是这个数组，而不关心具体参数。在函数体内部可通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数， 没有重载在其他语言中，可以为一个函数编写两个定义，只要定义的签名（接受的参数类型和数量）不同即可。而ES函数没有签名，即其参数是以数组的形式进行表示，所以不可能做到真正意义的重载。 回顾： 额，图片不清楚，不想转换格式了，就酱。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html与css碎点]]></title>
    <url>%2Fnote%2F2018%2Fundefined11%2F528414c2.html</url>
    <content type="text"><![CDATA[1.引入css样式表 行内式（内联式） &lt;标记名 style=&quot;属性1：属性值1； 属性2：属性值2；&quot;&gt; 内容&lt;/标记名&gt; 内嵌式 &lt;style type=&quot;text/css&quot;&gt; 选择器{属性1：属性值1；} &lt;/style&gt;可放在文档的任何地方，浏览器从上至下解析代码 嵌入式&lt;link href =&quot;css文件路径&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; 需放在&lt;head&gt;部分 导入式 在head部分应用style，并在style标记内开头处使用@import “css文件路径”。与链入式功能基本相同，但链入式与页面同时加载，而导入式是页面加载完后，再被加载。import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 2.选择器伪类的a伪类没有行内式。 &lt;a style=&quot; :hover: red;&quot;&gt;&lt;/a&gt; 2.1常见选择器 (1):nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素 (2):nth-of-type(n), p:nth-of-type(2) 选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 (3) div p 选择 &lt;div&gt; 元素内部的所有 &lt;p&gt; 元素。 (4) div&gt;p 选择父元素为 &lt;div&gt; 元素的所有 &lt;p&gt; 元素。 (5)div+p 选择紧接在 &lt;div&gt; 元素之后的所有 &lt;p&gt; 元素。 不要在属性值与单位之间留有空格。假如你使用 “margin-left: 20 px” 而不是 “margin-left: 20px” ，它仅在 IE 6 中有效，但是在 Mozilla/Firefox 或 Netscape 中却无法正常工作。 3.&lt;DOCTYLE&gt;&lt;!DOCTYPE&gt; 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的.DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 4.元素 （1）行内元素有：a b span img input select strong（强调的语气 （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p （3）常见的空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; (4)b与strong，i与em (1)Physical Style Elements – 自然样式标签： b, i, u, s, pre (2)Semantic Style Elements – 语义样式标签： strong, em, ins, del, code (3)title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响； 5浏览器内核 6.html语义化（1）用正确的标签做正确的事情。 （2）html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; （3）即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; （4）搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; （5）使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 7.HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 SGML 是一种很强大但很复杂的标记语言，HTML、XML 就是从中衍生出来的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[float与清除浮动]]></title>
    <url>%2Fnote%2F2018%2Fundefined11%2F5216f308.html</url>
    <content type="text"><![CDATA[float float的设计初衷是为了文字环绕效果，会让父元素高度塌陷。 块级元素之所以会单独占据一行是因为它们前后默认有换行符（假设，为更好理解块级元素），当进行浮动时，会把换行符去掉 在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。因此，对于内联元素，如果设置为浮动，会产生和块级框相同的效果。脱离了标准文档流，但仍在文档流中。文字和行级元素会环绕该元素，块级元素则不受影响。浮动元素的margin（外边距）不会与其他元素的margin合并，可与浮动元素的margin合并。 利用浮动与列表的结合可创建水平菜单 http://www.w3school.com.cn/tiy/t.asp?f=csse_float5 display:block 填充父元素整行（即使设置width小于父元素可填充宽度也会占据整行），高度可调正。 display:inline 宽度高度都不可调整 display: inline-block; 不会占据父元素整行，宽高都可调整 display:none和visible:hidden都能把网页上某个元素隐藏起来，但两者有区别: display:none —不为被隐藏的对象保留其物理空间，即该对象在页面上彻底消失，通俗来说就是看不见也摸不到。 visible:hidden— 使对象在网页上不可见，但该对象在网页上所占的空间没有改变，通俗来说就是看不见但摸得到 参考https://www.cnblogs.com/nicholas_f/archive/2009/03/27/1423207.html 清除浮动通过空标签在容器的结束标签前添加一个空标签，在空标签上直接设置样式“clear:both”。用这种方法来清除浮动，在大多数情况下是有效的，但这不太适合语义化。这取决于一个页面有多少浮动需要清除，这样造成页面上的空标签迅速堆积，而且在页面中没有上下文内容。 当 父 包 含 块 缩 成 一 条 时 ， 用 clear ： both 方 法 清 除 浮 动 无 效 ，它 一 般 用 于 紧 邻 后 面 的 元 素 的 清 除 浮 动。 通过overflow:hidden在具有浮动元素的父容器中设置“overflow”的属性值为“auto”在ie6里会有浮动条所以用hidden。父元素要有宽度，如果不是定宽时，width不可为100%，overflow：hidden会使元素BFC化，div内任何元素无论怎么折腾都是在内部，不会影响div外面的元素，而clearboth，则不会，仍可与外界margin进行纠缠。BFC(Block formatting context ) 块级格式化上下文 BFC触发条件 根元素或其它包含它的元素 浮动 (元素的 float 不是 none) 绝对定位的元素 (元素具有 position 为 absolute 或 fixed) 非块级元素具有 display: inline-block，table-cell, table-caption, flex, inline-flex 块级元素具有overflow ，且值不是 visible 通过伪元素clearfix”技巧是基于在父元素上使用“:before”和“:after”两个伪元素。使用这些伪元素，我们可以在浮动元素的父容器前面和后面创建隐藏元素。（:before 选择器在被选元素的内容前面插入内容。）“:before”伪元素是用来防止子元素顶部的外边距塌陷，使用“display: table”创建一个匿名的“table-cell”元素。这也确保在IE6和IE7下具有一致性。“:after”伪元素是用来防止子元素的底部的外边距塌陷，以及用来清除元素的浮动。 在IE6和7的浏览器中，加上“*zoom”属性来触发父元素的hasLayout的机制。决定了元素怎样渲染内容，以及元素与元素之间的相互影响。 #box:after {clear:both; content:&apos; &apos;; display:table; } #box{ *zoom: 1;} 伪类与伪元素 .:before/:after伪元素是在css2中提出来的。而::before/::after是在css3中的写法，这样从新提出是为了用两个冒号表示伪元素以区分伪类。 伪元素 它们用在css里某个选择器之后，为了增添装饰性内容的，因为这样可以实现语义化，如果用html来添加一些没有实际内容的节点或者辅助式样本的文本，他们是毫无意义的。 创建的伪元素默认是在所依附的元素之上的，我们可以使用z-index:-1;把它放到下面去。伪元素用于创建一些不在文档树中的元素，并为其添加样式。实际上不在文档树中。 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。 详细可参AlloyTeam：http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/ float与清除浮动xmind总结]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏式布局]]></title>
    <url>%2Fnote%2F2018%2Fundefined10%2F85f5447b.html</url>
    <content type="text"><![CDATA[左右两栏宽度固定，中间主体宽高自适应 通过margin1#center{ width:100%; } #center #c-inner { margin: 0 210px; float: left; } #left{ width: 200px; background-color: orange; margin-left: -100%; float: left; } #right{ width: 200px; background-color: purple; margin-left: -200px; float: left; } 注意： 盒子的顺序center-left-right center的width：100%不可少，否则当文字较少时，便无法撑起盒子#c-inner的横排空间。 通过margin2#left{ width: 200px; background-color: orange; float: left; } #center{ width:100%; float: left; margin:0 -210px 0 -210px; } #center #c-inner { margin: 0 210px; } #right{ width: 200px; background-color: purple; float: left; } 注意： 盒子顺序：left-center-right 盒子默认继承父元素的宽（是整个盒子模型等于父元素的宽，即当padding，margin增加时会挤压内容区），，若指明继承为width：100%。则，盒子的内容区为父元素的宽，也就是说，内容区的宽固定了，在增加padding，只会增大盒子模型而内容区不变，此时，padding的增加是从左向右即padding会造成盒子增大，内容区移动。 box-sizing 其属性值有两个。 content-box | border-box content-box默认值，标准盒子模型。宽高计算包含盒子的border和padding。 border-box宽高只包括内容区。 通过绝对定位#left{ width: 200px; position: absolute; top: 0; left: 0; } #c-inner { margin: 0 210px; } #right{ width: 200px; position: absolute; top: 0; right: 0; } 注意： 父元素高度取决于中间部分的高度，当两侧高度大于中间高度时，则出现高度塌陷，除非指定父元素的高度，当两侧高度小于中间部分时，可以使用。（且塌陷的父元素，无法利用清除浮动撑起来。因为这是定位，不是浮动，无法清除） 通过padding在margin1的基础上，去掉#c-inner的margin，在三个盒子的父元素加padding，left和right通过相对定位，移动至padding空白处。 通过flex布局参考http://www.cnblogs.com/ljchow/archive/2010/07/27/1785632.html http://ife.baidu.com/note/detail/id/666 彩蛋：position]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素的居中]]></title>
    <url>%2Fnote%2F2018%2Fundefined09%2F8fedc92a.html</url>
    <content type="text"><![CDATA[水平垂直居中方法一：.box { width: 400px; height: 200px; background-color: #ccc; margin: auto; position: absolute; left:0; top:0; bottom:0; right:0; } 方法二：引入transform.box { width: 400px; height: 200px; background-color: #ccc; margin: auto; position: absolute; /* 这里要明白绝对定位的50%相对父元素，下面translate50%是盒子box的50% */ left:50%; top:50%; transform: translate(-200px, -100px ) /* 宽高的1/2，另外可用transform: translate(-50%, -50%)替换，效果是一样的*/ transform 通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数。 通过 rotate() 方法旋转，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。 通过 scale() 方法缩放，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数：值 scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。 通过 skew() 方法倾斜，元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数：值 skew(30deg,20deg) 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。 matrix() 方法把所有 2D 转换方法组合在一起。matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 transform: skew(30deg,20deg); skewX(angle) skewY(angle) transform-origin 属性允许您改变被转换元素的位置 2D 转换元素能够改变元素 x 和 y 轴。3D 转换元素还能改变其 Z 轴。 方法三：与方法二相比用margin取代transform.box { width: 400px; height: 200px; background-color: #ccc; position: absolute; left:50%; top:50%; margin-left:-200px; /*这里的-200px不能用-50%所替代*/ margin-top:-100px; } 方法四：弹性布局Flex以下放在所要居中的div父元素中，父元素必须有高度 divpare { height: 800px; display: flex; justify-content: center; align-items: center; } 水平居中参照水平垂直居中： margin：0 auto； left:50%; margin-left:-width/2;或者 transform: translateX(-width·/2) 更多方法请参照https://www.w3cplus.com/css/vertically-center-content-with-css 彩蛋：框模型]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《影响力》]]></title>
    <url>%2Fnote%2F2018%2Fundefined06%2Fb85ac64d.html</url>
    <content type="text"><![CDATA[《影响力》【美】 罗伯特.西奥迪尼 著 陈叙 译 中国人民大学出版社 首先这本书还是挺实用的，讲了生活中常见的坑以及应该如何避开别人挖的坑。这本书被营销领域吹得挺厉害的，对此书的评价在结尾处聊。 太多字的思维导图不是很适合阅读，所以全图就不传了 第一章影响力的武器固定性为模式：黄鼠狼是火鸡的天敌。每当它们靠近时火鸡妈妈就会发出愤怒的叫声，对它们又啄又抓，即使用绳子拉着黄鼠狼标本去接近火鸡妈妈，也会立刻遭到他们猛烈地攻击。然而在同样的黄鼠狼标本内放入一个能发出“吱吱声”的小录音机，火鸡妈妈不仅会接受它正在靠近，而且还会把它拢在自己身下。一旦把收音机关上，黄鼠狼标本马上又会遭到凶猛的攻击。它会虐待甚至杀死自己的亲生孩子，也仅仅因为它没能发出这种叫声。这种盲目机械的，有规律的行为模式被称为“固定性为模式”。 1.1 有效请求帮助当我们请别人帮忙时，如果能讲出一个理由，我们得到别人帮助的可能性会更大 对不起，我有五页纸要复印，能不能让我先复印呢？因为我要复印几页纸。 93% 对不起，我有五页纸要复印，能不能让我先复印啊？因为我有急事。 成功率94%。 对不起，我有五页纸要复印，能不能让我先复印呢？ 60% “因为”一词触发了下意识顺从反应，人性惯性 1.2 低廉的的绿松石提升价格反而销售一空—–“价高=质优” 人生生活经验1.3 对比原理看过貌美的明星后会觉得相貌平平的异性更丑 一只手放进凉水，一只手放进热手。然后一起放进常温的水里，两只手的的感觉是一凉一热 推销商品时，先推销贵的，之后再推销便宜的，让人有实惠的感觉。（买车，再推销花哨的装饰） 买房时，销售会先带你看几套又破又贵的房子，然后其它普通的房子显得更加有吸引力 人身体的存在缺陷 生活中注意以上三个方面被人挖的坑，解决方法暂无。可以尝试下反人性，比如不贪小便宜，做个nice的人。当然谙熟人性，是一种能力，能力本身是没有对错的。由于生活节奏比较快，没有精力与能力对每件事亲自认识和分析，我们仍需要一些不假思索的下意识反应。 第二章互惠2.1 人类社会从互惠原理中获得了重要的竞争优势，因此我们每个人都知道，遵循这个原理就会得到社会认可，否则就会得到人们的嘲弄。拥有如此巨大社会认同，难免会被人加以利用 先送你一朵花，然后让你买东西 让你免费试吃，然后你感觉不好意思，就买了些东西。 海尔售后维修人员服务态度超好，行为超规范，会让人感觉到受了那么一丝丝恩惠，想再买一台海尔或者对人宣传海尔真是好。 2.2 让步 精髓就是鲁迅说的中国人爱折中。说借我一百元，被拒。接着那借我五十元。。在使用的过程中要注意第一步提出的要求不能太过分，要在情理之中，否则效果会适得其反。 让你买一百元的电影票，拒绝。（人已拒绝常会想补偿的心理）接着对提出请求你买无缘的巧克力，遂买。被跳坑。 互惠简单说就是吃人家嘴软，拿人家手短，人情往来。解决办法：最好就是不接受，但是不现实，可能会误伤些好心。为此首先要明白一种行为或恩惠是情理还是销售手段。对于情理当然需要另一个人情来回报，否侧就把恩惠与事情独立分开看，该拒绝就拒绝，不要被人用道德捆绑。最后现实生活肯定要复杂的多的多，祝好各位。 第三章承诺和一致3.1 一致性原理。一旦我们做出某个决定，某个承诺，或选择了某个立场，就会面对来自个人和外部的压力迫使我们的言行与它保持一致。在大多数情况下，保持一致都是一种最具适应性、最受尊重的行为。和互惠一样，个人观点被主流看法所挟持，进而所形成的一种巨大人性惯性。 言行一致的心理惯性 赌马者一旦下注，就对自己买的那匹马信心大增 选择了一个渣男，还安慰自己男票可好了。 东西放在一个地方，被人拿走时，20有4个出来制止。当告诉旁人帮帮照看下时，20有19个人出来制止。 家长答应孩子去买最近最火的玩具，商家故意缺货，在玩具店暂时买了其他玩具作为替代。等到玩具销售季节过去，最火的玩具开始供货，由于家长已答应孩子买那种玩具，进而保持营销的连贯性 思维一致 有时让我们逃避思考的不是思考过程的艰辛，而是思考得出的严重后果。这种压力加上机械性的保持一致，它能为我们提供一个暂时躲避烦恼的堡垒，从而让理性失效。 比如：你抓住了悬崖旁边的一根被老鼠咬过的藤绳，幻想它怎样都不会断 3.2承诺的惯性问：你好吗。答：好啊。问：买个彩票好吗？惯性回答：好啊。 先来小请求（诱敌上钩，操纵一个人的自我形象），再来大请求。 请在：支持美化环境的请愿书上签字。。给你一个良好的市民形象。。之后说要里一个安全驾驶的大牌子。（内心想：我是一个良好市民，应当同意） 3.3如何让承诺更有效力3.3.1书面承诺 物质证据，也可用来说服他人。 减少退货率：让购买人自己签署购买合同。 各大公司发起的征文比赛，用来吹捧自家产品。 进而大众逐渐相信自己所想来的产品优点， 履行一个承诺所要付出的努力越多，对许诺者的影响力越大。（人们更珍惜来之不易的东西） 许多大公司的面试难度非常大，当面试成功者一般更不愿离职，对团体的认同感更大。（内心os：能面试进来的都是精英） 3.3.2内心主动的选择 A对一些小朋友说：“你不能玩某个玩具B，玩它是不对的。如果你敢玩，我就会打你”。结果当时没人敢玩，过了几个星期后，A离开了学校，让小朋友自愿选择玩具时，77%的人拿了玩具B。 A又对另一批小朋友说：“玩玩玩具B是不对的”。几个星期后，大多数人都没人拿那个玩具。（想想怎么教育孩子，劝说孩子说让孩子觉察到的外部压力越少越好，不容易） 买车时，刚开始给个诱饵，说车的价钱比外面便宜四五百。首先让你喜欢在这买车，后来找个借口把诱饵拿掉。（但我们已被自己说服） 3.4 避免被坑感受自己胃及身体做出的反应，听从内心。 把诱饵，被赋予的形象拿掉后，自己会怎样做 第四章社会认同4.1 社会认同原理的本质：我们进行是非判断的标准之一就是看别人怎么想的，尤其是当我们决定什么是正确的行为的时候。精髓：只有大约5%的人是原创者，而其他95%的人都是模仿者。我们从众，进而成为盲流。 配音笑声：来大家一起尬笑啊。 酒吧侍者会在托盘上放上几张钞票假装是前面的顾客留下的。 帮助有恐惧症的人摆脱恐惧心理：小男孩怕狗，每天花二十分钟观看一个小男孩高兴地与狗玩耍的情景。4天后，67%的儿童愿意与狗玩耍。观看电影片段也有同样的效果。 2012是世界末日预言失败。加入当这个预言是某个宗教预言时，当预言失败时，一般宗教会解散，也有宗教通过疯狂接受教众，为其信仰建立一个认同体系（认同某种观念的人越多，这种观念就越正确）。 4.2 社会认同原理的影响力在不确定性与相似性情况下威力巨大 4.2.1 不确定性。当我们对自己缺乏信心时，当形势不是很明朗时，当不确定性占上风时，我们有可能并参照别人的行为。 当一名受害者在痛苦中苦苦挣扎着需要帮助时，众多的旁观者却没有一个伸出援手。 首先我们都喜欢在众人面前表现的泰然自若，老成持重。其次，当旁人众多时，每个人的责任感都在下降，认为“其他人会帮忙，其他人已经这样做了”。所以当你前面的人，无视的路过一名受害者时，你大概率会跟着无视。混乱，人口稠密，认识率低这样的城市环境，扩大了这种不确定性，显得城市感情疏离。在农村，基本都相互认识，判断都比较明确。更有效的呼救，让别人明确自己的情况，可直接喊help等，更进一步，对着一个人，盯着他，指着他，直接对他提出明确的请求。如果对着大众呼救，每个人都以别人会帮忙的，反而降低成功率。 当领导者教徒去自杀时，自身大多会参考其它教众的做法，所以有时出大家一起殉道吧。 4.2.2相似性 年轻人自杀报道增多时，会有更多年轻人自杀事故。当大学生自杀报道增多时，同理。同时有一些自杀者，由于一些原因会让自杀看起来更不像自杀。比如马航事件，就有人怀疑是智慧老练的机长，想自杀，然后拉了一堆人陪葬。当然我本然更愿意相信它飞往了异度空间，不久就会飞回来。 第五章 喜好5.1 原理：人们总是愿意答应自己认识和喜爱的人提出的请求。在销售某种商品时说，某某（你认识的人）已经买过了。或者说某某推荐我来的。所以类似，买东西时有人说你能推荐你认识的你认为会喜欢这款商品的人吗？不能，这是在消耗社会关系。 5.2 增加被喜好的因素5.2.1 外表的吸引力颜值即正义，对于长得好看的人人们自然联想到美好的品质。 5.2.2 相似性。 我们喜欢那些与我们相似的人，不管他们是在观点上，个性上，穿着喜好兴趣上，背景上，还是生活方式上与我们相似。 销售人员会模仿客户的姿势、语气以及说话风格。 以及平时所说的一见钟情，知己啦，除了长得好看以外。也许我们看到了更多的相似性。 5.2.3 称赞拍马屁，人类的天性。要迎合的有技巧。 5.2.4 接触与合作 人们倾向于喜欢熟悉的东西。 在一处选举中，被选举人把自己的名字改为了常见的名字。 在写电子邮件时注意把握对方的语言用词习惯。 有人希望种族融合，黑人和白人一起上学。但是由于他们的接触带有学习上的竞争性，结果反而更加讨厌。通过增加一些“合作学习”来解决。对于有共同方向与目标或者有共同利益的的群体，更容易互生好感。 5.2.5 关联人们不喜欢坏消息，所以连带着憎恨带来坏消息的人。 讨厌一个人，进而讨厌一群人。 厂家总是希望自己的商品与美好的事物联系在一起。什么，我的商品请明星代言，我的商品有有文化内涵，我的商品纯天然啦。 销售人员有时请客户吃大餐的一个原因是客户会把对大餐的喜爱转到销售人员身上。 当我们喜欢的球队胜利时，我们会标榜我们是粉丝。当失败时，大都沉默。同时，我们也会标榜我们读过什么书，喜欢什么人，和谁谁很厉害我认识。意图把美好的品质转移到自己身上。 5.3 解决办法：交易是交易，感情是感情。当我们在短时间内，对一个人的好感反常的好时，要特别注意。第六章 权威李开复曾经说道，好多学生来信要求他给他们指点人生的发展道路。过于迷信权威，也在一定程度解释了好多无法想象的行为，也许都只是服从了一个权威的命令 典型的权威标志 头衔 一些医生明显的开错药方，护士有能力分辨时，却依然选择沉默服从； 衣着：警服等行业服装 外部标志：定制西装，名车...... 等红灯时，前面时豪车会比较耐心。一般的车会忍不住按喇叭。 第七章 短缺爱一样东西的方法就是意识到你可能会失去它 喜好，购买，抉择时不因外在条件与环境怎样。要关注本质。假如未来人们拉的粑粑越来越少，有些人会不会去买？ 个人评价感觉就是一本心理学应用。对心理研究的态度，和对技术以及隐私权的的态度挺像的，就是工具本身没有利弊，在于用的人。 本书的总结可以说：人是社会人，为了维护形象会有固定的行为模式，进而被别有用心的人挖坑。 即使没有看过这本书，我想对于有一定社会经验的人，对这些套路也都很熟悉。有些人，可能一字不识，但他们仍对这社会，这亘古的人性有通透的认识。听些不识字的阿姨拉家常，感觉我只是看了些名词，而本质以及应用远不及叔叔阿姨。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bgcolor与background-color]]></title>
    <url>%2Fnote%2F2018%2Fundefined24%2F2107d71c.html</url>
    <content type="text"><![CDATA[归属不同bgcolor 属于 html标签，更确切的说属于body标签。因为当作用于其他大多数标签时不起作用。但当用于table标签时有作用，至于什么原理，还请聪明的你告诉我。而background-color属于css标签。当然css是大趋势，都用css是最好的。 &lt;html&gt; &lt;body bgcolor=&apos;blue&apos;&gt; &lt;h1 style=&apos;background-color:purple&apos; &gt;春天在哪里&lt;/h1&gt; &lt;h2 bgcolor=&apos;purple&apos;&gt;春天在哪里&lt;/h2&gt; &lt;table bgcolor=&apos;red&apos;&gt; &lt;tr&gt; &lt;td&gt;春天在哪里&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 运行以上代码可看出h2并未变成紫色。 注意 属性值务必用英文状态下的字符 。比如&#39;red&#39;，否则目标不会显示红色，而会突变为其他色。 html 的势力范围很明显要比body的势力范围大。（html是页面所到之处，body是内容主体所到之处）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
</search>
