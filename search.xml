<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DOM模型]]></title>
    <url>%2Fnote%2F2018%2Fundefined06%2Fff0a3f82.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于吃]]></title>
    <url>%2Fnote%2F2018%2Fundefined04%2Fec13cc6b.html</url>
    <content type="text"><![CDATA[1. 有哪些食物为了健康你一定不吃？ 绝对不吃：烟（致癌）、槟榔（致癌） 能不吃就不吃：含糖饮料（肥胖）、含糖量高的食品（肥胖）、酒（致癌）、路边摊（卫生状况糟糕） 偶尔吃：油炸（三高）、烟熏（可能致癌）、烤制（可能致癌）、其它高油高盐高糖或致癌加工食品 酒精作为一类致癌物，没有安全剂量可言，喝多喝少都有害，红酒白酒啤酒果酒药酒都有害，尽量不喝才是正确的 。其正面作用远不如危害大。 饼干，大部分蛋糕，开酥的面包（蝴蝶酥，唱片面包等），奶茶，冰淇淋，饮料，雀巢咖啡和伴侣。 原因: 高糖高油导致发胖。 螺类 ，不熟的肉类。 淘宝自制，美食节上的食物。 适合多吃：燕麦，西红柿。]]></content>
      <categories>
        <category>泛娱乐</category>
      </categories>
      <tags>
        <tag>知乎</tag>
        <tag>吃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网格布局（CSS Grid Layout）]]></title>
    <url>%2Fnote%2F2018%2Fundefined30%2F7e93ee50.html</url>
    <content type="text"><![CDATA[css网格布局引入了二维网格布局系统，可用于布局页面主要的区域布局或小型组件。flex布局：弹性盒子布局主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。 1. 网格容器通过在元素上声明 display：grid 或 display：inline-grid 来创建一个网格容器。一旦我们这样做，这个元素的所有直系子元素将成为网格元素。网格元素显示为蚂蚁线。divtwo无内容，宽高为零不显示。 2. 网格属性 grid-template-columns grid-template-rows grid-auto-rows grid-auto-columns grid-column-start grid-column-end grid-row-start grid-row-end grid-column-gap grid-row-gap 2.1我们通过 grid-template-columns 和 grid-template-rows 属性来定义网格中的行和列。 1grid-template-columns: 100px 200px 200px;/100px repeat(2,200px) 2.2 在隐式网格中用 grid-auto-rows 和 grid-auto-columns 属性来定义一个设置大小尺寸的轨道。即这两个属性只作用于隐式网格。 2.3 跨轨道放置网格元素 grid-column-start grid-column-end grid-row-start grid-row-end 2.4 网格间距 grid-column-gap grid-row-gap 3. fr 单位轨道可以使用任何长度单位进行定义 ，fr单位代表网格容器中可用空间的一等份。 ​ 1grid-template-columns: 50px repeat(2, 1fr);/ 50px 1fr 1fr 1grid-template-columns: 50px repeat(6, 1fr); 4. 隐式和显式网格grid-template-columns 属性定义了自己的列轨道，但是却让网格按所需的内容创建行，这些行会被创建在隐式网格中。显式网格包含了你在 grid-template-columns 和 grid-template-rows 属性中定义的行和列。果你在网格定义之外又放了一些东西，或者因为内容的数量而需要的更多网格轨道的时候，网格将会在隐式网格中创建行和列。按照默认，这些轨道将自动定义尺寸，所以会根据它里面的内容改变尺寸。 上面这句话更加通俗的说就是只有具有 grid-template-columns 和 grid-template-rows同时声明的网格才是显式网格。 4.1 例一1234567&lt;div class=&quot;wrapper&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;Two&lt;/div&gt; &lt;div&gt;Three&lt;/div&gt; &lt;div&gt;Four&lt;/div&gt; &lt;div&gt;Five&lt;/div&gt;&lt;/div&gt; 123.wrapper &#123; display: grid;&#125; 此时为隐式网格 4.2 例二1234.wrapper &#123; display: grid; grid-template-columns: 50px repeat(2, 1fr);&#125; 此时虽定义了列宽，但并未定义行高，行高为自适应，仍未隐式网格。 4.3 例三12345.wrapper &#123; display: grid; grid-template-columns: 50px repeat(2, 1fr); grid-template-rows：60px; &#125; 此时定义了三列一行，所以第一行高为60px，第二行高仍未自适应且为自动创建的隐式网格，尽管它继承了列宽； 第一行为显示网络，有行列共同声明。 4.4 例四123456.wrapper &#123; display: grid; grid-template-columns: 50px repeat(2, 1fr); grid-template-rows：60px; grid-auto-rows：50px; &#125; 为隐式网格定义行高，而显示网格仍未60px，并未受影响。 5. 轨道大小和minmax()grid-auto-rows：minmax(50px,auto) 定义了隐式网格的行高最小为50px，超出50px后高度自适应。 6. 网格线Grid 会为我们创建编号的网格线来让我们来定位每一个网格元素. 例如下面这个三列两行的网格中，就拥有四条纵向的网格线。 7. 网格单元一个网格单元是在一个网格元素中最小的单位， 从概念上来讲其实它和表格的一个单元格很像。 参考链接未完待续。。。。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弹性布局（flex）]]></title>
    <url>%2Fnote%2F2018%2Fundefined28%2F5c7aade3.html</url>
    <content type="text"><![CDATA[声明：本文大部分摘自别处，链接在文末给出。 1. Flex布局Flex 是 Flexible Box 的缩写，意为”弹性布局”。W3C针对布局设计的新标准，相对float和position会更加灵活处理父元素和子元素之间布局关系，让布局更加直观和灵活简单。有效的针对不同屏幕宽度大小的情况下，让元素自动有效合理处理布局结构。 适用范围弹性盒子布局主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。 1.1 Flex布局基本概念 1.1.2 弹性容器(Flex container)通过设置 display 属性的值为 flex 或 inline-flex来定义弹性容器。 就像blockandinline-block作用于描绘对象，对于其子元素当然不会有效果。 1.1.3 弹性项目(Flex item)弹性容器里子元素自动成为弹性项目，并且弹性项目的float、clear和vertical-align属性将失效。 1.1.4 轴(Axis) 主轴（main axis） 交叉轴（cross axis） 这个2个轴决定了容器里的项目整体布局效 1.2 Flex容器属性 flex-direction flex-wrap flex-flow justify-content align-items align-content 1.2.1 flex-direction决定主轴方向，默认情况下，元素都是从左到右地分布在主轴上4个取值： flex-direction: row | row-reverse | column | column-reverse; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 依次如下图： 1.2.2 flex-wrap是否可以换行（默认不换行），以及如果可以换行，如何排列 3个取值 flex-wrap: nowrap | wrap | wrap-reverse; nowrap: 默认不换行 wrap: 可以多行，第一行在上方 wrap-reverse: 可以多行，第一行在下方 1.2.3 flex-flowflex-direction 和 flex-wrap 的简写,默认row nowrap flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; 1.2.4 justify-content属性定义了项目在主轴上的对齐方式。.box { justify-content: flex-start | flex-end | center | space-between | space-around;} 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 1.2.5 align-items决定交叉轴的对齐方式 1234567align-items: flex-start | flex-end | center | baseline | stretch;flex-start: 交叉轴起点对齐flex-end: 交叉轴终点对齐center: 交叉轴居中对齐baseline: 第一行文字的底部对齐stretch: （默认）如果项目木有设置高度或者高度为auto,那么项目拉伸充满整个交叉轴空间 注意：记住justify-content是沿着主轴的，align-items是沿着交叉轴的，而flex-direction是转换主轴的。这对整体移动元素很关键。 1.2.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 详参：align-content更多属性,MDN. 1.3 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 1.3.1 orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 1.3.2 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 该属性可能取6个值，除了auto，其他都与align-items属性完全一致 1align-self: auto | flex-start | flex-end | center | baseline | stretch; 1.3.3 flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 1.3.4 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 1.3.5 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。当width与flex-basis同时存在以后者宽度为准。flex-basis 和 width 不同的地方是，它是和 flex 坐标轴保持一致的，flex-basis是影响主轴上大小。即当flex-direction为默认row时，flex-basis为项目宽度。当flex-direction属性值为column时，flex-basis值为项目高度。 1.3.6 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 参考链接通过动图形象地为你介绍 flexbox 是如何工作的（一）Flex 布局教程：语法篇flex基础布局详解使用 CSS 弹性盒子]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《批判性思维》]]></title>
    <url>%2Fnote%2F2018%2Fundefined27%2F50fabfb3.html</url>
    <content type="text"><![CDATA[批判性思维：思维、沟通、写作、应变、结决问题的根本技巧 (美)保罗，（美）埃尔德著 这个版本的翻译真的令人很不满意，如果可以就不要看这一版。坑 序论 我们就好比学样的猴子，只知道机械的模仿却不明就里。如果你开始用类似于植物学家观察植株的方式来对思维过程加以关注，你将会成为一个非凡杰出的人。你会开始注意到很少有人关注的事情。你会成为一只少有的杰出的猴子，了解模仿动作的含义，知道自己该如何模仿，以及为什么模仿，并明白如何评估和改进模仿的技巧。 只有当你清楚地意识到自己在怎样进行思考，并且努力地去认识这种思考所包含的优势和弱点时，当你建造了“大屏幕”来观看自己的思维过程后，你才逐渐成为思考者。 批判性思维：自我监控和自我改进的思维方式。 我们常说的三思而后行。在进行任何决策和行为前，要对将要发生的进程进行预判。比如要去吃饭，到吃饭的时间了吗，还是想逃避眼前的事情。要吃什么饭，面还是米。吃完饭直接回来吗，还是溜达一圈再回来。 第一章成为公正的思考者高级批判性思维高级批判性思维者致力于做到公正无私。这样就避免了利用自己的技巧来侥胜对方，我们用同样的高标准来衡量所有的思维过程。希望那些支持和反对我们的人所进行的推理都是出色的。对那些我们无情反驳和对自己的推理都用同样的标准来要求。我们要质疑自己的的证据、结论、暗示和观点，一如质疑他人的这些思维要素。 公正思维有何要求公正思维必须力争不偏不倚和毫无偏见的态度来对待和某情景有关的是所有观点，不受个人感受或私利的左右，也不受朋友，团体的感受或利益的影响。 做到公正思维必须同时具备 态度谦逊 勇敢无畏 设身处地 诚实 坚持不懈 笃信推理 意志自由 态度谦逊：吾生也有涯，而知也无涯态度谦逊可以定义为对个体知识局限性的清楚认识，避免一叶障目，管中窥豹。同时也要思考自己的观点、想法的来源是否正确偏颇。 了解肤浅的认识 选择一门自己取得高分的课程，然后思考以下问题 学习这门课的目的是什么？ 这个领域的工作者都在努力达到什么样的目标？ 他们一般会提出什么样的问题？ 他们一般致力于解决什么样的问题？ 他们搜集什么样的数据或者信息？ 他们是怎样以该领域所特有的方式来搜集信息的？ 这领域最基本的观念或者理论是什么？ 对于该领域的学习是怎样改变你对世界的看法的？ 勇敢无畏：勇于挑战信念 “从来如此，便对吗？”__鲁迅 当自己的观点、信念被质疑时，要勇于克服被别人否定的恐惧。 不要害怕犯错误，同时也要勇于质疑。 我不会随意认同任何信念的内容，我只认同自己形成这些信念的过程，紧紧跟随证据和推理引领的方向，摒弃那些不为证据或理性思考所支持的信念。 设身处地：考察对立观点若想做到设身处地，就得准确地重建他人观点和推理过程。当我们以自我为中心进行思考时，就无法理解其他人的想法、感受和情绪。 坚持不懈：排除万难，战胜挫折当一个人在面对脑力劳动的困难与挫折而不放弃时，此人就具备了坚持不懈。如果缺乏坚持不懈，就无法对学科进行透彻思考，进而获得远见卓识。竭力避免头脑的挫折，获得的却是因为无法解决日常生活中的复杂问题而日益滋生的挫败感。 同时我们要避免过于苛求证据，避免对自己的推论和解释过于苛责，避免锱铢必较。一定程度上的自负是必要的。 第二章 思维发展的起初四个阶段成为一个出色的思考者，一般要经过以下阶段 第一个阶段：轻率鲁莽的思考者（我们对自己思维过程中的重大问题一无所知） 第二个阶段：面临挑战的思考者（我们开始意识到自己思维中存在的问题了） 第三个阶段：初出茅庐的思考者（我们尝试着提高自己的思维技巧，但是缺乏有规律的训练） 第四个阶段：实践操练的思考者（我们意识到了有规律训练的必要性） 第五个阶段：技艺高超的思考者（随着训练的深入我们的思维技巧与日俱进） 第六个阶段：思想大师（技艺非凡和富有洞见的思考成为我们的第二本能） 第三个阶段：初出茅庐的思考者在这个阶段，开始着手提升自己的价值观。 有哪些对塑造思想产生了重大影响： 你诞生于某种文明之中（欧洲文明、非洲文明、美洲文明以及亚洲文明） 你在某个时间点诞生（某个世纪的某一年） 你在某地出生（某个国家，某个城市，南方或北方，东方或西方） 你是由具有特定信仰的父母所抚养（关于家庭，人际关系，婚姻，宗教，政治，教育） 。。。。。 如果能改变上面的某种影响，那么信念体系会截然不同。 第三章 理解自我 对待事情要以积极的态度进行思考，态度与行动是相互影响的。好心情会笑，反过来笑也可以带动好心情。 大脑自我催眠说：真好吃。 嗯 嘴巴说：哎，果然好好吃啊。 你说你大脑骗起自己的身体来，会有多可怕的能量。所以，要好好利用。 第四章 推论：根据已知正确，或看上去正确的事物，得出其他事物的正确性。 假设：认为理所当然或者预先假定的东西，通常为我们已知且深信不疑，是我们信念体系的一部分。 第五章:思维的衡量标准思维的8大元素：1、目的：我是要干嘛？达到什么目的？2、悬而未决的问题：根据这个目的遇到的最主要问题或者议题是什么？3、信息：为了解决这个问题我需要收集哪些信息、数据、事实或者经验？4、解释和推理：根据掌握的信息进行解释或者推理。5、概念：界定解决问题中出现的理论、定义、规则、原理、模式等概念，统一标准。6、假设：清楚在解释和推理中隐含的假设条件什么？7、结果和意义：通过逻辑得出意义和结果是什么？8、观点：从哪个角度、视角出发来解决问题的？ 推理的要素，为了结论正确，需要确保的得出结论的过程正确。对于每个思维元素都应该综合考虑是否达到了思维的标准。 思维的9大标准 ： 清楚 正确 精确 深度 广度 切题 有逻辑性 有意义 公正 作为一个批判性思维者，我们应该对自己的思想提出如下问题：我的思路清晰吗？正确吗？精确吗？切题吗？是否有逻辑性？我所思考的事情有意义吗？在一定的场合中正当吗？ 清楚 你能解释这一观点吗？ 你能换一种方法表达这个观点吗？ 你能给出图例或例子吗？ 能不能把问题说明白，没有歧义。区分模糊和清楚的观点。 “他是个好人” 这句话就模糊，由于我们不知道这句话发生的场景，就会揣测出不同的意思。 精确 精确意味着给出一些必须的细节，来让别人理解说话人的意思。有时则无需这种细节。比如 冰箱里有没有牛奶，回答 有。已经足够了，一般不用回答出还有多少 “小明超重了” 这句话清楚正确却不精确，我们不知道超重了多少，一斤、两斤 深度 面对吸毒问题应该采取什么措施，答 拒绝毒品。 广度 从不同的角度考虑问题 第六章 正确提问引发出色思维思维不是由答案，而是由问题推动的。问题体现了要完成的任务和存在的疑点，而答案往往是思考的终结。 思维应当能结出果实，否则就一无所用。 三类问题： 事实性问题。 这种问题只要一个正确答案。 比如：水的沸点有多大？ 见仁见智问题。这类问题因人看法不同，以主观性为主 比如：你喜欢留什么样的发型？ 判断性问题。这种问题需要推理，对此问题的回答，不能太主观。可以用思维的标准来进行检验。 如：清楚，深度，广度等。一个复杂的问题往往跨越多个思维领域。（心理学，社会学，经济学，生物学，政治，道德） 比如：死刑应该被取消吗？ 成为苏格拉底式的提问者 苏格拉底式的提问的基本原理： 试着去理解一种见解或看法的根本基础，并在以后的问题中遵循这些基础。（例如：你的信念依据是什么？你能更详细低解释自己的思想，让我更好地理解你的观点吗？） 只有当一种思想和其他思想共同形成一个网络时，它才能完整的存在。因此，应当把所有的主张都当做引发更多思考的连接点，寻找它们之间的联系。就是我们所说发散性思维。（例如：如果你所说属实，那x或y不也如此吗？） 所有的问题都是环环相扣的，思考也是如此。因此，提出问题时，也不要忘记了它们会引发的其他问题。（例如：要回答这个复杂的问题，还需要回答其他相关的问题？） 除了以苏格拉底的方式进行提问，还以从以下几个方面进行提问： 围绕思维的衡量标准提出问题 围绕思维要素提出问题 围绕先验问题发问 我们在处理复杂的问题时，要设计先验问题–即回答复杂问题之前需要解决的问题。 要回答“什么是多元文化主义“要先解决”解决什么是文化“又应该先回答”决定文化归属的因素是什么“ 围绕思维领域提出问题（历史，政治，文化，心理，经济） 第七章 精通思考，掌握知识 每门课程的知识都体现了独特的思维方式。 所有的知识都是由人类思想所创造；他们由思想形成、分析、合成、表达、评价、重建、改造；也是通过思想来学习，理解并应用。如果试图把知识和思想分开，那么将什么也得不到。 第八章 规划你的学习 大学课程的规划 弄懂课程中的基本概念 找出每门课程必须的思维模式 运用学科逻辑进行思考。 为自己规划课程 第十五章 批判性地、有道德地学习和使用信息]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超链接与伪类]]></title>
    <url>%2Fnote%2F2018%2Fundefined15%2F59c34dbb.html</url>
    <content type="text"><![CDATA[在 HTML 4.01 中，&lt;a&gt; 标签可以是超链接或锚。在 HTML5 中，&lt;a&gt; 标签始终是超链接，但是如果未设置 href 属性，则只是超链接的占位符,则不可以使用如下属性：download, hreflang, media, rel, target 以及 type 属性,此时color等无法设置属性值。 a:link /* 未访问的链接 */ a:visited /* 已访问的链接 */ a:hover /* 鼠标移动到链接上 可以用在表格上*/ a:focus /*获得焦点状态 可以用在输入框上*/ a:active /* 选定的链接 激活发生在链接被点击时 可以用在提交按钮上*/ 上面的次序很重要，否则有些样式会不起作用。次序为：lvhfa。简单记法：Lord Vader Hate Furry Animals。 1. 突出显示不同类型的链接1.1如图给链接加个小图标 实现方法： 1.可用img直接vertical-align：top； 在超链接上通过background来实现。 同理，如果想实现在文字的下面加些特殊的下划线，也可通过background把图片定到文字下。 1.2 给链接在focus状态下加个下标线 通过 a { text-decoration: none;} a:focus{ padding-bottom: 22px; border-bottom: 2px solid red } 启示：通过伪类状态的不同属性（link,visited,hover,focus,active）,可以在不同的属性下设置一些不同的样式，比如focus时文字背景颜色变为红色 2 图像翻转不同伪类状态属性时文字的背景图片不同，可以营造一种错觉的的图像翻转，就是把文字的背景颜色变为背景图像。 2.1pixy方法由于这种方法在在第一次加载图像时会有点迟钝，因此我们可以将悬停的图像作为背景应用于父元素，从而预先加载他们。再进一步，可以把多个图像放在一个背景图像的不同位置，因此减少了服务器请求的数量。把所有图像放在同一个位置的方法叫做pixy方法。（pixy是发明者的昵称） 2.2 css精灵多个服务器请求会对站点的性能产生显著的影响，所以在pixy方法的启示下，可以把一个网站的所有图标和，图形等放在一个图像上。这就是css精灵。 然而在个人的实践下，这种方法并不好用，对各个图像的位置要求比较大，为此需要的花费好多时间进行调试。所以使用与否看需求了。 2.3 文字图像同时翻转在这里进行图像翻转的同时，文字是不变的。要想实现文字与背景都改变，需要用到text-indent与position:absloute，然而这两者会产生放一起会产生奇特的化学反应。即当 父元素的text-indent作用于文字时position:absloute里的文字会一起移动，position:absloute的原位仍在，但对其文字失去控制能力。如下： &lt;div id=&quot;hh&quot;&gt; &lt;div id=&quot;ff&quot;&gt;fdsklfj&lt;/div&gt; 我是按钮链接 &lt;/div&gt; #hh{width:500px; text-align: center;background-color: grey;} #ff{ width:100px; position: absolute; top: 0; left: 0; } 当对#hh添加text-indent:100px时,盒子ff的文字会一起移动; 为解决这个问题我们可以使用覆盖的方式。如下两个同级元素，由于盒子hh完全被盒子ff的绝对定位覆盖即盒子ff层次在盒子hh之上，此时位于下面的盒子#hh:hover失效 &lt;div id=&quot;hh&quot;&gt; 我是按钮链接 &lt;/div&gt; &lt;div id=&quot;ff&quot;&gt;fdsklfj&lt;/div&gt; #hh{width:500px; text-align: center;background-color: grey; } #hh:hover{ text-indent: 1000px;} #ff{ width: 500px; position: absolute; top: 8px; left: 8px; } #ff:hover{text-align: center; color:yellow} 对#ff:hover添加background-color:red 3 悬停下拉菜单 &lt;ul id=&quot;one&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;Products&lt;/a&gt; &lt;ul id=&quot;two&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Services&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Contact Us&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Services&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Contact Us&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; #one li { list-style: none; float: left; border:1px solid #486b20;background-color: #8bd400; width: 85px;} #one li a{text-decoration: none;} #two {position: absolute; left: -1000px; padding: 0; } #one li:hover #two{ left: auto; } #two li{ float: none; width: 85px; } 下拉菜单的难点在于#one li:hover #two{ left: auto; },通过父元素的状态来控制子元素。 4.锚锚可以作为内部引用，也可以作为外部链接。 &lt;a href=&quot;#na&quot;&gt;one&lt;/a&gt; &lt;a href=&quot;&quot; id=&quot;jump&quot;&gt;two&lt;/a&gt; ...... &lt;a name=&quot;na&quot;&gt;three&lt;/a&gt; &lt;a href=&quot;#jump&quot;&gt;four&lt;/a&gt; 点击one会跳到three，点击four会跳到two。 name属性在H5中不在支持。 5.backgroundbackground-repeat repeat 默认。背景图像将在垂直方向和水平方向重复。 repeat-x 背景图像将在水平方向重复。 repeat-y 背景图像将在垂直方向重复。 no-repeat 背景图像将仅显示一次。 inherit 规定应该从父元素继承 background-repeat 属性的设置 background-sizecover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。 contain 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域 可用长度百分比（顺序宽高），如果只设置一个值，第二个值auto； 详参http://www.w3school.com.cn/cssref/pr_background-size.asp]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《JavaScript高级程序设计》]]></title>
    <url>%2Fnote%2F2018%2Fundefined13%2F556216f0.html</url>
    <content type="text"><![CDATA[[美] Nicholas C.Zakes 著 李松峰 曹力 译 （第三版） 本文以JS高程为主线， 阮一峰的《 JavaScript标准参考教程》为辅。 第一章 JavaScript简介1.1 JavaScript简史由于网页的大小和复杂性不断增加以及网速的限制。为完成简单的表单验证（是否没有填写某个必填项，是否输入了无效的值）而频繁地与服务器交换数据只会加重用户的负担，为此，1995年当时就职于Netscape公司的Brendan Eich为Netscape Navigator开发了一种名为LiveScript的脚本语言–该语言可同时在浏览器的与服务器中使用（仅在客户端就可以完成简单的验证），为了搭上热炒Java的顺风车，改名为JavaScript。 微软为与Netscape竞争，在自家的IE浏览器里加入了JScript，就有了两个不同的JavaScript版本，为了标准化，由欧洲制造商协会（ECMA，European Computer MAnufacturers Association）牵头来自一些公司程序员共同制定了ECMA-262–定义一种名为ECMAScript(发音为“ek-ma-script”)的新脚本语言标准。 1.2 JavaScript实现一个完整的JavaScript实现应该有以下三个不同的部分组成 核心（ECMAScript）：提供核心语言功能； 文档对象模型（DOM）：提供访问和操作网页内容的方法和接口； 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。 1.2.1 ECMAScript由ECMA-262定义的ECMAScript与浏览器没有依赖关系，web浏览器只是其实现可能的宿主环境之一。主要定义了核心语言功能： 语法 类型 语句 关键字 保留字 操作符 对象 1.2.2 文档对象模型（DOM）文档对象模型（DOM,Document Object Model）是针对XML但经过扩展用于HTML的应用程序接口（API，Application Programmaing Interface）。DOM把整个页面映射为一个多层节点结构，形成dom树开发人员获得页面内容和结构的控制权，借助DOM提供的API，开发人员可以轻松自如地删除，添加，替换和修改任何节点。 第二章 在HTML中使用JavaScript2.1 &lt;script&gt;元素向HTML页面中插入JavaScript的主要方法就是使用&lt;script&gt;元素,在页面中正常情况下按先后顺序依次解析。HTML4.0为&lt;script&gt;定义了下列六个属性 async：可选。表示立即下载脚本，但不妨碍页面中的其他操作。 charset：可选。很少用，忽略。 defer：可选；表示立即下载脚本，但可以延迟到文档完全被解析和显示之后再执行。现实中如果有多个延迟脚本，不一定会按照顺序执行，所以最好只包含一个。 language：已废弃。 src：可选。表示包含要执行代码的外部文件地址。 type：可选。 2.2 嵌入代码与外部文件2.2.1 嵌入代码12345&lt;script type="text/javascript"&gt; function sayHi（）&#123; alert（"Hi!"） &#125;&lt;/script&gt; 不能在嵌入的代码中任何地方出现&lt;/script&gt;,这会让浏览器产生一个错误。可通过转义字符“\”,&lt;\/script&gt;. 2.1.2 嵌入外部文件1&lt;script type="text/javascript" src= "example.js" &gt; &lt;/script&gt; 标签之间不应该包含额外的代码块，会被忽略，只解析外部脚本文件。为减少呈现页面的延迟，通常把JavaScript的引用放在内容之后&lt;/body&gt;之前。 2.3 &lt;noscript&gt;元素当浏览器不支持js时如何让页面平稳地退化，创造一个&lt;noscript&gt;元素，这个标签能够出现在&lt;body&gt;中的任何HTML元素——&lt;script&gt;元素除外。包含在&lt;noscript&gt;元素中的内容在以下情况才会显示出来： 浏览器不支持脚本 浏览器支持脚本，但被禁用。 &lt;noscript&gt; &lt;p&gt;本页面需要支持（启用）JavaScript&lt;/p&gt; &lt;/noscript&gt; 第三章 基本概念3.1 语法ECMAScript的语法大量借鉴了C及其它类C语言（如java和perl）的语法。 3.1.1 区分大小写ECMAScript中的一切（变量，函数名和操作符）都区分大小写。 3.1.2 标识符标识符，就是指变量、函数、属性的名字，或者函数的参数。 书写要求： 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）; 其他字符可以是字母、下划线、美元符号或数字。 标识符中的字母也可以包含扩展的ASCII 或Unicode 字母字符。但不推荐这样做。 按惯例，标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词首字母大写。不能把关键字，保留字，true，false和null用作标识符。 JavaScript有一些保留字，关键字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 否则在严格模式下，可能会抛出错误。 3.1.3 注释使用C风格的注释。单行注释//单行注释，/*块级注释*/。块级注释中，每个行首也可加*号，提高注释的可读性。 此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以&lt;!--和--&gt;也被视为合法的单行注释。 12x = 1; &lt;!-- x = 2;--&gt; x = 3; 上面代码中，只有x = 1会执行，其他的部分都被注释掉了。 需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。 1234567function countdown(n) &#123; while (n --&gt; 0) console.log(n);&#125;countdown(3)// 2// 1// 0 上面代码中，n --&gt; 0实际上会当作n-- &gt; 0，因此输出2、1、0。 3.1.4 严格模式严格模式是为JavaScript定义了一种不同的解析与执行模型。一些不确定的行为将会的到处理，不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： “use strict”; 其实它是一个编译指示，告诉JS引擎切换到严格模式。也可以指定函数在严格模式下执行，在函数内部的上方添加编译指示： 1234function doSomething( ) &#123; &quot;&quot;use strict&quot;; //函数体&#125; 3.1.5 语句ECMAScript中的语句以一个分号结尾；如果省略分号，则由解析器花费时间推测语句的结尾，也有可能会导致压缩错误。 1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。 分号前面可以没有任何内容，JavaScript引擎将其视为空语句。 1;;; 上面的代码就表示3个空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。 3.2 关键字和保留字关键字：用于表示控制语句的开始或结束，或者用于执行特定的操作等。 保留字：虽然还没有任何特定用途，但他们将来有可能被用来关键字。 3.3 变量JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型，有效但不推荐。 每个变量仅仅是一个用来保存值的占位符而已。 变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 1var a = 1; 上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a。以后，引用变量名a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。 变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。 12var a;a = 1; 如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。 123var a = 1;// 基本等同a = 1; 但是，不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量， 用var操作符定义的变量将成为定义该变量作用域的局部变量即如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁，在函数外部不能被访问到。 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。 12x// ReferenceError: x is not defined 上面代码直接使用变量x，系统就报错，告诉你变量x没有声明。 可以在同一条var命令中声明多个变量。 1var a, b; 如果使用var重新声明一个已经存在的变量，是无效的。 123var x = 1;var x;x // 1 上面代码中，变量x声明了两次，第二次声明是无效的。 但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值 3.3.1 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。 12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。 123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 刚在谷歌浏览器控制台测试，上面代码块1，结果是显示undefined， 2结果为1。火狐中代码块1，2结果都为1。是否可以认为，js引擎更智能了？？ 3.4 数据类型JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。） 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 对象是最复杂的数据类型，又可以分成三个子类型。 狭义的对象（object） 数组（array） 函数（function） 狭义的对象和数组是两种不同的数据组合方式 函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量 。 3.4.1 typeof 操作符JavaScript 有三种方法，可以用来检测给定变量的数据类型。 typeof运算符 instanceof运算符 Object.prototype.toString方法 数值、字符串、布尔值分别返回number、string、boolean，函数返回function 。null返回object ，对象返回object 。undefined返回undefined 。 undefined返回undefined 。 利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。 12345v// ReferenceError: v is not definedtypeof v// "undefined" 上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined. 这样做没有意义，严格模式下会导致错误。 实际编程中，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === "undefined") &#123; // ...&#125; 对象返回object。 123typeof window // &quot;object&quot;typeof &#123;&#125; // &quot;object&quot;typeof [] // &quot;object&quot; 上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。 12345var o = &#123;&#125;;var a = [];o instanceof Array // falsea instanceof Array // true 3.4.2 null 和 undefinedundefined 类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。 声明并未加以初始化与尚未定义即未声明且未初始化的变量是不一样的。 null也是只有一个值的数据类型，这个特殊值时null.从逻辑角度来讲null值表示一个空对象指针。 如果定义的变量准备在将来用于保存对象，就应该明确的让变量保存null值。然而没有必要把变量的值显示的设为undefined。 相等性测试 12alert （null == undefined）// truenull === undefined // false 实际上undefined值派生于null值，引入undefined值是为了正式区分空对象指针与未经初始化的变量。 undefined表示“未定义”，下面是返回undefined的典型场景。 1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined 3.4.3 布尔值(boolen)布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN &quot;&quot;或&#39;&#39;（空字符串） 3.4.4 数值（number）1. 整数和浮点数JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 11 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 120.1 + 0.2 === 0.3// false 计算机内是用二进制进行存储，在浮点数转化为二进制时会发生取舍，所以0.1可能是0.100002。 2. 数值精度根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。 1(-1)^符号位 * 1.xx...xx * 2^指数部分 上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。 精度最多只能到53个二进制位，这意味着，绝对值小于等于2的53次方的整数，即-253到253，都可以精确表示。 1234567891011121314Math.pow(2, 53)// 9007199254740992 Math.pow(2, 53) + 1// 9007199254740992Math.pow(2, 53) + 2// 9007199254740994Math.pow(2, 53) + 3// 9007199254740996Math.pow(2, 53) + 4// 9007199254740996 上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。 123456Math.pow(2, 53)// 9007199254740992// 多出的三个有效数字，将无法保存9007199254740992111// 9007199254740992000 上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的111）都会无法保存，变成0。 3. 数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。 1Math.pow(2, 1024) // Infinity 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 1Math.pow(2, -1075) // 0 下面是一个实际的例子。 1234567var x = 0.5;for(var i = 0; i &lt; 25; i++) &#123; x = x * x;&#125;x // 0 上面代码中，对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。 JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。 12Number.MAX_VALUE // 1.7976931348623157e+308Number.MIN_VALUE // 5e-32 4. 数值的进制使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 十进制：没有前导0的数值。 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。 十六进制：有前缀0x或0X的数值。 二进制：有前缀0b或0B的数值。 默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。 1230xff // 2550o377 // 2550b11 // 3 如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。 1230xzz // 报错0o88 // 报错0b22 // 报错 上面代码中，十六进制出现了字母z、八进制出现数字8、二进制出现数字2，因此报错。 通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。 120888 // 8880777 // 511 前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。 数值也可以采用科学计数法表示，下面是几个科学计数法的例子。 科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。 以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。 （1）小数点前的数字多于21位。 123451234567890123456789012// 1.2345678901234568e+21123456789012345678901// 123456789012345680000 （2）小数点后的零多于5个。 123456// 小数点后紧跟5个以上的零，// 就自动转为科学计数法0.0000003 // 3e-7// 否则，就保持原来的字面形式0.000003 // 0.000003 5. NaN（1）含义 NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），表示一个本来要返回数值的操作数未返回数值的情况。主要出现在将字符串解析成数字出错的场合。 15 - &apos;x&apos; // NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。 另外，一些数学函数的运算结果会出现NaN。 123Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN 0除以0也会得到NaN。 10 / 0 // NaN 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。 1typeof NaN // &apos;number&apos; （2）运算规则 NaN不等于任何值，包括它本身。 1NaN === NaN // false 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。 1[NaN].indexOf(NaN) // -1 NaN在布尔运算时被当作false。 1Boolean(NaN) // false NaN与任何数（包括它自己）的运算，得到的都是NaN。 1234NaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN （3）isNaN() 这个函数只接受一个参数，该参数可以是任何类型，如果能够转化为数值，函数返false。反之任何不能被转化为数值的值都会导致函数返回true。 6. Infinity（1）含义 Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。 1234567// 场景一Math.pow(2, 1024)// Infinity// 场景二0 / 0 // NaN1 / 0 // Infinity 上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回Infinity。第二个场景是0除以0会得到NaN，而非0数值除以0，会返回Infinity。 Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。 1234Infinity === -Infinity // false1 / -0 // -Infinity-1 / -0 // Infinity 上面代码中，非零正数除以-0，会得到-Infinity，负数除以-0，会得到Infinity。 由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，而是返回Infinity，所以单纯的数学运算几乎没有可能抛出错误。 Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。 12Infinity &gt; 1000 // true-Infinity &lt; -1000 // true Infinity与NaN比较，总是返回false。 12345Infinity &gt; NaN // false-Infinity &gt; NaN // falseInfinity &lt; NaN // false-Infinity &lt; NaN // false （2）运算规则 Infinity的四则运算，符合无穷的数学计算规则。 12345 * Infinity // Infinity5 - Infinity // -InfinityInfinity / 5 // Infinity5 / Infinity // 0 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。 1230 * Infinity // NaN0 / Infinity // 0Infinity / 0 // Infinity Infinity加上或乘以Infinity，返回的还是Infinity。 12Infinity + Infinity // InfinityInfinity * Infinity // Infinity Infinity减去或除以Infinity，得到NaN。 12Infinity - Infinity // NaNInfinity / Infinity // NaN Infinity与null计算时，null会转成0，等同于与0的计算。 123null * Infinity // NaNnull / Infinity // 0Infinity / null // Infinity Infinity与undefined计算，返回的都是NaN。 12345undefined + Infinity // NaNundefined - Infinity // NaNundefined * Infinity // NaNundefined / Infinity // NaNInfinity / undefined // NaN 要想确定一个数是不是有穷，可以使用isFinite()函数，如果参数位于最小值和最大值中间会返回true。 7. 数值转换 Number() 可用于任何数据类型 parseInt()和parseFloat()两个函数用于把字符串转化为数值 7.1 使用Number函数，可以将任意类型的值转化成数值。下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。 （1）原始类型值 原始类型值的转换规则如下。 123456789101112131415161718192021// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&apos;324&apos;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&apos;324abc&apos;) // NaN// 空字符串转为0Number(&apos;&apos;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0 Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。 12parseInt(&apos;42 cats&apos;) // 42Number(&apos;42 cats&apos;) // NaN 上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。 另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。 12parseInt(&apos;\t\v\r12.34\n&apos;) // 12Number(&apos;\t\v\r12.34\n&apos;) // 12.34 （2）对象 简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。 123Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5 之所以会这样，是因为Number背后的转换规则比较复杂。 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 第三步，如果toString方法返回的是对象，就报错。 7.2 parseInt()（1）基本用法 parseInt方法用于将字符串转为整数。 1parseInt(&apos;123&apos;) // 123 如果字符串头部有空格，空格会被自动去除。 1parseInt(&apos; 81&apos;) // 81 如果parseInt的参数不是字符串，则会先转为字符串再转换。 123parseInt(1.23) // 1// 等同于parseInt(&apos;1.23&apos;) // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。 12345parseInt(&apos;8a&apos;) // 8parseInt(&apos;12**&apos;) // 12parseInt(&apos;12.34&apos;) // 12parseInt(&apos;15e2&apos;) // 15parseInt(&apos;15px&apos;) // 15 上面代码中，parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 12345parseInt(&apos;abc&apos;) // NaNparseInt(&apos;.3&apos;) // NaNparseInt(&apos;&apos;) // NaNparseInt(&apos;+&apos;) // NaNparseInt(&apos;+1&apos;) // 1 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。 1parseInt(&apos;0x10&apos;) // 16 如果字符串以0开头，将其按照10进制解析。 1parseInt(&apos;011&apos;) // 11 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 1234567parseInt(1000000000000000000000.5) // 1// 等同于parseInt(&apos;1e+21&apos;) // 1parseInt(0.0000008) // 8// 等同于parseInt(&apos;8e-7&apos;) // 8 （2）进制转换 parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。 123parseInt(&apos;1000&apos;) // 1000// 等同于parseInt(&apos;1000&apos;, 10) // 1000 下面是转换指定进制的数的例子。 123parseInt(&apos;1000&apos;, 2) // 8parseInt(&apos;1000&apos;, 6) // 216parseInt(&apos;1000&apos;, 8) // 512 上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。 12345parseInt(&apos;10&apos;, 37) // NaNparseInt(&apos;10&apos;, 1) // NaNparseInt(&apos;10&apos;, 0) // 10parseInt(&apos;10&apos;, null) // 10parseInt(&apos;10&apos;, undefined) // 10 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。 12parseInt(&apos;1546&apos;, 2) // 1parseInt(&apos;546&apos;, 2) // NaN 上面代码中，对于二进制来说，1是有意义的字符，5、4、6都是无意义的字符，所以第一行返回1，第二行返回NaN。 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。 12345678910parseInt(0x11, 36) // 43parseInt(0x11, 2) // 1// 等同于parseInt(String(0x11), 36)parseInt(String(0x11), 2)// 等同于parseInt(&apos;17&apos;, 36)parseInt(&apos;17&apos;, 2) 上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。 这种处理方式，对于八进制的前缀0，尤其需要注意。 1234567parseInt(011, 2) // NaN// 等同于parseInt(String(011), 2)// 等同于parseInt(String(9), 2) 上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt(&#39;011&#39;, 2)，011则是会被当作二进制处理，返回3。 JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。 7.5 parseFloat()parseFloat方法用于将一个字符串转为浮点数。 1parseFloat(&apos;3.14&apos;) // 3.14 如果字符串符合科学计数法，则会进行相应的转换。 12parseFloat(&apos;314e-2&apos;) // 3.14parseFloat(&apos;0.0314E+2&apos;) // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 1parseFloat(&apos;3.14more non-digit characters&apos;) // 3.14 parseFloat方法会自动过滤字符串前导的空格。 1parseFloat(&apos;\t\v\r12.34\n &apos;) // 12.34 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。 123parseFloat([]) // NaNparseFloat(&apos;FF2&apos;) // NaNparseFloat(&apos;&apos;) // NaN 上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。 这些特点使得parseFloat的转换结果不同于Number函数。 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat(&apos;&apos;) // NaNNumber(&apos;&apos;) // 0parseFloat(&apos;123.45#&apos;) // 123.45Number(&apos;123.45#&apos;) // NaN 3.4.5 字符串（String）1.定义字符串就是零个或多个16位Unicode字符排在一起的字符序列，放在单引号或双引号之中。 12&apos;abc&apos;&quot;abc&quot; 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 12&apos;key = &quot;value&quot;&apos;&quot;It&apos;s a long journey&quot; 上面两个都是合法的字符串。 如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。 12345&apos;Did she say \&apos;Hello\&apos;?&apos;// &quot;Did she say &apos;Hello&apos;?&quot;&quot;Did she say \&quot;Hello\&quot;?&quot;// &quot;Did she say &quot;Hello&quot;?&quot; 由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。 字符串默认只能写在一行内，分成多行将会报错。 1234&apos;abc&apos;// SyntaxError: Unexpected token ILLEGAL 上面代码将一个字符串分成三行，JavaScript 就会报错。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234567var longString = 'Long \long \long \string';longString// "Long long long string" 上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 1234var longString = 'Long ' + 'long ' + 'long ' + 'string'; 如果想输出多行字符串，有一种利用多行注释的变通方法。 12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split('\n').slice(1, -1).join('\n')// "line 1// line 2// line 3" 上面的例子中，输出的字符串就是多行 2. 转义反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 需要用反斜杠转义的特殊字符，主要有下面这些。 \0 ：null（\u0000） \b ：后退键（\u0008） \f ：换页符（\u000C） \n ：换行符（\u000A） \r ：回车键（\u000D） \t ：制表符（\u0009） \v ：垂直制表符（\u000B） \&#39; ：单引号（\u0027） \&quot; ：双引号（\u0022） \\ ：反斜杠（\u005C） 上面这些字符前面加上反斜杠，都表示特殊含义。 123console.log(&apos;1\n2&apos;)// 1// 2 上面代码中，\n表示换行，输出的时候就分成了两行。 反斜杠还有三种特殊用法。 （1）\HHH 反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\251表示版权符号。显然，这种方法只能输出256种字符。 （2）\xHH \x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\xA9表示版权符号。这种方法也只能输出256种字符。 （3）\uXXXX \u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\u00A9表示版权符号。 下面是这三种字符特殊写法的例子。 1234567&apos;\251&apos; // &quot;©&quot;&apos;\xA9&apos; // &quot;©&quot;&apos;\u00A9&apos; // &quot;©&quot;&apos;\172&apos; === &apos;z&apos; // true&apos;\x7A&apos; === &apos;z&apos; // true&apos;\u007A&apos; === &apos;z&apos; // true 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。 12&apos;\a&apos;// &quot;a&quot; 上面代码中，a是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。 如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。 12&quot;Prev \\ Next&quot;// &quot;Prev \ Next&quot; 3. 字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 1234567var s = &apos;hello&apos;;s[0] // &quot;h&quot;s[1] // &quot;e&quot;s[4] // &quot;o&quot;// 直接对字符串使用方括号运算符&apos;hello&apos;[1] // &quot;e&quot; 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 123&apos;abc&apos;[3] // undefined&apos;abc&apos;[-1] // undefined&apos;abc&apos;[&apos;x&apos;] // undefined 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 12345678910var s = 'hello';delete s[0];s // "hello"s[1] = 'a';s // "hello"s[5] = '!';s // "hello" 上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。 12var lang = &quot;Java&quot;;lang = lang + &quot;Script&quot; 实现这个操作的过程如下：首先创建一个能容纳10个字符的新字符串然后在这个新字符串中填充&quot;Java&quot;和&quot;Script&quot;，最后一步是销毁原来的&quot;Java&quot;和&quot;Script&quot; 字符串。 5. 转换字符串String函数可以将任意类型的值转化成字符串，转换规则如下。 （1）原始类型值 数值：转为相应的字符串。 字符串：转换后还是原来的值。 布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;。 undefined：转为字符串&quot;undefined&quot;。 null：转为字符串&quot;null&quot;。 12345String(123) // "123"String('abc') // "abc"String(true) // "true"String(undefined) // "undefined"String(null) // "null" （2）对象 String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。 12String(&#123;a: 1&#125;) // &quot;[object Object]&quot;String([1, 2, 3]) // &quot;1,2,3&quot; String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。 先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果valueOf方法返回的是对象，就报错。 下面是一个例子。 123456String(&#123;a: 1&#125;)// &quot;[object Object]&quot;// 等同于String(&#123;a: 1&#125;.toString())// &quot;[object Object]&quot; 上面代码先调用对象的toString方法，发现返回的是字符串[object Object]，就不再调用valueOf方法了。 如果toString法和valueOf方法，返回的都是对象，就会报错。 1234567891011var obj = &#123; valueOf: function () &#123; return &#123;&#125;; &#125;, toString: function () &#123; return &#123;&#125;; &#125;&#125;;String(obj)// TypeError: Cannot convert object to primitive value 下面是通过自定义toString方法，改变返回值的例子。 1234567891011121314151617181920212223String(&#123; toString: function () &#123; return 3; &#125;&#125;)// "3"String(&#123; valueOf: function () &#123; return 2; &#125;&#125;)// "[object Object]"String(&#123; valueOf: function () &#123; return 2; &#125;, toString: function () &#123; return 3; &#125;&#125;)// "3" 上面代码对三个对象使用String函数。第一个对象返回toString方法的值（数值3），第二个对象返回的还是toString方法的值（[object Object]），第三个对象表示toString方法先于valueOf方法执行。 4. length 属性length属性返回字符串的长度，该属性也是无法改变的。 12345678var s = 'hello';s.length // 5s.length = 3;s.length // 5s.length = 7;s.length // 5 上面代码表示字符串的length属性无法改变，但是不会报错。 3.5 操作符操作符是用来操作数据值的。 3.5.1 一元操作符 只能操作一个值的操作符。 1. 递增和递减操作符借鉴C语言，前置性和后置型。（前置自增减，后置自增减） 12var age = 29;++age; 与下面效果相同 12var age = 29;age = age + 1; 自增减操作与执行语句的优先级相等 1234var num1 = 2;var num2 = 20;var num3 = --num1 + num2; // 21 var num4 = num + num2; // 21 第三行等同于： 12var num1 = 2 - 1 ;var num3 = num1 + num2; // 21 本操作符对任何值都适用，将非数值转化为数值。 2. 一元加和减操作符（与加性操作符进行区别） 数值的正负 把非数值转换为数值，与Number函数的作用相同。 1234var s1 = "01";var s2 = "z";s1 = +s1; //值变为数值1s2 = +s2; //值变为NaN 3.5.2 位操作符位运算符用于直接对二进制位进行计算，一共有7个。 js中数值以64位存储，但位操作先将64位转为32位进行操作再将结果转回64位。NaN和Infinity值应用位操作时，被当为0来处理。位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。 二进制或运算符（or）：符号为|，表示若两个二进制位都为0，则结果为0，否则为1。 二进制与运算符（and）：符号为&amp;，两个二进制位都为1，则结果为1，否则为0。 二进制否运算符（not）：符号为~，表示对一个二进制位取反。 异或运算符（xor）：符号为^，二进制位不相同，则结果为1，否则为0。 左移运算符（left shift）：符号为&lt;&lt;， 将数值所有位向左移指定的位数。 右移运算符（right shift）：符号为&gt;&gt;，保留符号位右移。 带符号位的右移运算符（zero filled right shift）：符号为&gt;&gt;&gt;。 对于有符号的整数，前31位表示数值，32位表示数值的正负：0正，1负。这个位置叫符号位。负数同样用二进制码存储，但是使用的是二进制补码。 比如-18的二进制码，先求得18的二进制码，变为反码，反码加1. 按位非（not） ~25 -26 按位与（and） 23 &amp; 3 1 左移 2 &lt;&lt;4 (2:二进制10，移4位100000) 64 按位异（xor） 25 ^ 3 26 3.5.3布尔操作符布尔运算符用于将表达式转为布尔值，一共包含四个运算符。 取反运算符：! 逻辑非 且运算符：&amp;&amp; 逻辑与 或运算符：|| 逻辑或 三元运算符：?: 1. 取反运算符（!）取反运算符是一个感叹号，用于将布尔值变为相反值，即true变成false，false变成true。 12!true // false!false // true 对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。 undefined null false 0 NaN 空字符串（&#39;&#39;） 2. 且运算符（&amp;&amp;）且运算符（&amp;&amp;）往往用于多个表达式的求值。 它的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。 3. 或运算符（||）或运算符（||）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。 4. 三元条件运算符（?:）三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。 3.5.4 乘性操作符三个： 乘法* 除法/ 求模% 乘法如果不是数值，后台会先使用Number（）函数转化为数值。 特殊值： 乘积超过数值范围则返回Infinity或-Infinity 一个是NaN，结果为NaN Infinity*0=NaN Infinity与非零相乘则Infinity或-Infinity Infinity*Infinity=Infinity。 除法 一个是NaN，结果为NaN Infinity / Infinity=NaN 0/0=NaN 3.5.5 加性操作如果其中一个为字符串，则进行拼接。 3.5.6 关系操作符在操作字符串时，比较的是字符串首位字符编码值。 12var result = "23" &lt; "3" //true var result = "Brick" &lt; "alphabet" // true “2”的字符编码50，“3的字符编码”51. B 的编码值66，a是97. javaScript 一共提供了8个比较运算符。 &lt; 小于运算符 &gt; 大于运算符 &lt;= 小于或等于运算符 &gt;= 大于或等于运算符 == 相等运算符 === 严格相等运算符 （不进行转换） != 不相等运算符 !== 严格不相等运算符 3.5.7 逗号操作符逗号操作符多用于声明多个变量；但除此之外还可以用于赋值，用于赋值时总会返回表达式中的去最后一项。 1var num = (5, 1, 4, 0); //num 的值为0。 指数运算符指数运算符（**）完成指数运算，前一个运算子是底数，后一个运算子是指数。 12 ** 4 // 16 赋值运算符赋值运算符（Assignment Operators）用于给变量赋值。 最常见的赋值运算符，当然就是等号（=）。 1234567891011121314151617// 等同于 x = x + yx += y// 等同于 x = x - yx -= y// 等同于 x = x * yx *= y// 等同于 x = x / yx /= y// 等同于 x = x % yx %= y// 等同于 x = x ** yx **= y 3.6 语句3.6.1 条件语句JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。 ifif代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。 if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 12345if (m === 3) &#123; // 满足条件时，执行的语句&#125; else &#123; // 不满足条件时，执行的语句&#125; 对同一个变量进行多次判断时，多个if...else语句可以连写在一起。 123456789if (m === 0) &#123; // ...&#125; else if (m === 1) &#123; // ...&#125; else if (m === 2) &#123; // ...&#125; else &#123; // ...&#125; else代码块总是与离自己最近的那个if语句配对。 123456var m = 1;var n = 2;if (m !== 1)if (n === 2) console.log('hello');else console.log('world'); 上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。 1234567if (m !== 1) &#123; if (n === 2) &#123; console.log('hello'); &#125; else &#123; console.log('world'); &#125;&#125; 如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。 12345678if (m !== 1) &#123; if (n === 2) &#123; console.log('hello'); &#125;&#125; else &#123; console.log('world');&#125;// world switch多个if...else连在一起使用的时候，可以转为使用更方便的switch结构。 12345678910switch (fruit) &#123; case "banana": // ... break; case "apple": // ... break; default: // ...&#125; 上面代码根据变量fruit的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。 需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。 3.6.2 循环语句循环语句用于重复执行某个操作，它有多种形式 while 循环While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。 如果只有一条语句，可以省略大括号，否则就必须加上大括号。 123while (条件) &#123; 语句;&#125; for 循环for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下 123for (初始化表达式; 条件; 递增表达式) &#123; 语句&#125; 初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。 条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。 递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量 省略了for语句表达式的三个部分，结果就导致了一个无限循环。 for-infor-in 语句是一种精准的迭代语句，可以用力枚举对象的属性。 123for(property in expression)&#123; statement&#125; do…while 循环do…while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 123do &#123; 语句&#125; while (条件);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html与css碎点]]></title>
    <url>%2Fnote%2F2018%2Fundefined11%2F528414c2.html</url>
    <content type="text"><![CDATA[1.引入css样式表 行内式（内联式） &lt;标记名 style=&quot;属性1：属性值1； 属性2：属性值2；&quot;&gt; 内容&lt;/标记名&gt; 内嵌式 &lt;style type=&quot;text/css&quot;&gt; 选择器{属性1：属性值1；} &lt;/style&gt;可放在文档的任何地方，浏览器从上至下解析代码 嵌入式&lt;link href =&quot;css文件路径&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; 需放在&lt;head&gt;部分 导入式 在head部分应用style，并在style标记内开头处使用@import “css文件路径”。与链入式功能基本相同，但链入式与页面同时加载，而导入式是页面加载完后，再被加载。import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 2.选择器伪类的a伪类没有行内式。 &lt;a style=&quot; :hover: red;&quot;&gt;&lt;/a&gt; 2.1常见选择器 (1):nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素 (2):nth-of-type(n), p:nth-of-type(2) 选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 (3) div p 选择 &lt;div&gt; 元素内部的所有 &lt;p&gt; 元素。 (4) div&gt;p 选择父元素为 &lt;div&gt; 元素的所有 &lt;p&gt; 元素。 (5)div+p 选择紧接在 &lt;div&gt; 元素之后的所有 &lt;p&gt; 元素。 不要在属性值与单位之间留有空格。假如你使用 “margin-left: 20 px” 而不是 “margin-left: 20px” ，它仅在 IE 6 中有效，但是在 Mozilla/Firefox 或 Netscape 中却无法正常工作。 3.&lt;DOCTYLE&gt;&lt;!DOCTYPE&gt; 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的.DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 4.元素 （1）行内元素有：a b span img input select strong（强调的语气 （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p （3）常见的空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; (4)b与strong，i与em (1)Physical Style Elements – 自然样式标签： b, i, u, s, pre (2)Semantic Style Elements – 语义样式标签： strong, em, ins, del, code (3)title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响； 5浏览器内核 6.html语义化（1）用正确的标签做正确的事情。 （2）html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; （3）即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; （4）搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; （5）使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 7.HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 SGML 是一种很强大但很复杂的标记语言，HTML、XML 就是从中衍生出来的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[float与清除浮动]]></title>
    <url>%2Fnote%2F2018%2Fundefined11%2F5216f308.html</url>
    <content type="text"><![CDATA[float float的设计初衷是为了文字环绕效果，会让父元素高度塌陷。 块级元素之所以会单独占据一行是因为它们前后默认有换行符（假设，为更好理解块级元素），当进行浮动时，会把换行符去掉 在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。因此，对于内联元素，如果设置为浮动，会产生和块级框相同的效果。脱离了标准文档流，但仍在文档流中。文字和行级元素会环绕该元素，块级元素则不受影响。浮动元素的margin（外边距）不会与其他元素的margin合并，可与浮动元素的margin合并。 利用浮动与列表的结合可创建水平菜单 http://www.w3school.com.cn/tiy/t.asp?f=csse_float5 display:block 填充父元素整行（即使设置width小于父元素可填充宽度也会占据整行），高度可调正。 display:inline 宽度高度都不可调整 display: inline-block; 不会占据父元素整行，宽高都可调整 display:none和visible:hidden都能把网页上某个元素隐藏起来，但两者有区别: display:none —不为被隐藏的对象保留其物理空间，即该对象在页面上彻底消失，通俗来说就是看不见也摸不到。 visible:hidden— 使对象在网页上不可见，但该对象在网页上所占的空间没有改变，通俗来说就是看不见但摸得到 参考https://www.cnblogs.com/nicholas_f/archive/2009/03/27/1423207.html 清除浮动通过空标签在容器的结束标签前添加一个空标签，在空标签上直接设置样式“clear:both”。用这种方法来清除浮动，在大多数情况下是有效的，但这不太适合语义化。这取决于一个页面有多少浮动需要清除，这样造成页面上的空标签迅速堆积，而且在页面中没有上下文内容。 当 父 包 含 块 缩 成 一 条 时 ， 用 clear ： both 方 法 清 除 浮 动 无 效 ，它 一 般 用 于 紧 邻 后 面 的 元 素 的 清 除 浮 动。 通过overflow:hidden在具有浮动元素的父容器中设置“overflow”的属性值为“auto”在ie6里会有浮动条所以用hidden。父元素要有宽度，如果不是定宽时，width不可为100%，overflow：hidden会使元素BFC化，div内任何元素无论怎么折腾都是在内部，不会影响div外面的元素，而clearboth，则不会，仍可与外界margin进行纠缠。BFC(Block formatting context ) 块级格式化上下文 BFC触发条件 根元素或其它包含它的元素 浮动 (元素的 float 不是 none) 绝对定位的元素 (元素具有 position 为 absolute 或 fixed) 非块级元素具有 display: inline-block，table-cell, table-caption, flex, inline-flex 块级元素具有overflow ，且值不是 visible 通过伪元素clearfix”技巧是基于在父元素上使用“:before”和“:after”两个伪元素。使用这些伪元素，我们可以在浮动元素的父容器前面和后面创建隐藏元素。（:before 选择器在被选元素的内容前面插入内容。）“:before”伪元素是用来防止子元素顶部的外边距塌陷，使用“display: table”创建一个匿名的“table-cell”元素。这也确保在IE6和IE7下具有一致性。“:after”伪元素是用来防止子元素的底部的外边距塌陷，以及用来清除元素的浮动。 在IE6和7的浏览器中，加上“*zoom”属性来触发父元素的hasLayout的机制。决定了元素怎样渲染内容，以及元素与元素之间的相互影响。 #box:after {clear:both; content:&apos; &apos;; display:table; } #box{ *zoom: 1;} 伪类与伪元素 .:before/:after伪元素是在css2中提出来的。而::before/::after是在css3中的写法，这样从新提出是为了用两个冒号表示伪元素以区分伪类。 伪元素 它们用在css里某个选择器之后，为了增添装饰性内容的，因为这样可以实现语义化，如果用html来添加一些没有实际内容的节点或者辅助式样本的文本，他们是毫无意义的。 创建的伪元素默认是在所依附的元素之上的，我们可以使用z-index:-1;把它放到下面去。伪元素用于创建一些不在文档树中的元素，并为其添加样式。实际上不在文档树中。 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。 详细可参AlloyTeam：http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/ float与清除浮动xmind总结]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏式布局]]></title>
    <url>%2Fnote%2F2018%2Fundefined10%2F85f5447b.html</url>
    <content type="text"><![CDATA[左右两栏宽度固定，中间主体宽高自适应 通过margin1#center{ width:100%; } #center #c-inner { margin: 0 210px; float: left; } #left{ width: 200px; background-color: orange; margin-left: -100%; float: left; } #right{ width: 200px; background-color: purple; margin-left: -200px; float: left; } 注意： 盒子的顺序center-left-right center的width：100%不可少，否则当文字较少时，便无法撑起盒子#c-inner的横排空间。 通过margin2#left{ width: 200px; background-color: orange; float: left; } #center{ width:100%; float: left; margin:0 -210px 0 -210px; } #center #c-inner { margin: 0 210px; } #right{ width: 200px; background-color: purple; float: left; } 注意： 盒子顺序：left-center-right 盒子默认继承父元素的宽（是整个盒子模型等于父元素的宽，即当padding，margin增加时会挤压内容区），，若指明继承为width：100%。则，盒子的内容区为父元素的宽，也就是说，内容区的宽固定了，在增加padding，只会增大盒子模型而内容区不变，此时，padding的增加是从左向右即padding会造成盒子增大，内容区移动。 box-sizing 其属性值有两个。 content-box | border-box content-box默认值，标准盒子模型。宽高计算包含盒子的border和padding。 border-box宽高只包括内容区。 通过绝对定位#left{ width: 200px; position: absolute; top: 0; left: 0; } #c-inner { margin: 0 210px; } #right{ width: 200px; position: absolute; top: 0; right: 0; } 注意： 父元素高度取决于中间部分的高度，当两侧高度大于中间高度时，则出现高度塌陷，除非指定父元素的高度，当两侧高度小于中间部分时，可以使用。（且塌陷的父元素，无法利用清除浮动撑起来。因为这是定位，不是浮动，无法清除） 通过padding在margin1的基础上，去掉#c-inner的margin，在三个盒子的父元素加padding，left和right通过相对定位，移动至padding空白处。 通过flex布局参考http://www.cnblogs.com/ljchow/archive/2010/07/27/1785632.html http://ife.baidu.com/note/detail/id/666 彩蛋：position]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素的居中]]></title>
    <url>%2Fnote%2F2018%2Fundefined09%2F8fedc92a.html</url>
    <content type="text"><![CDATA[水平垂直居中方法一：.box { width: 400px; height: 200px; background-color: #ccc; margin: auto; position: absolute; left:0; top:0; bottom:0; right:0; } 方法二：引入transform.box { width: 400px; height: 200px; background-color: #ccc; margin: auto; position: absolute; /* 这里要明白绝对定位的50%相对父元素，下面translate50%是盒子box的50% */ left:50%; top:50%; transform: translate(-200px, -100px ) /* 宽高的1/2，另外可用transform: translate(-50%, -50%)替换，效果是一样的*/ transform 通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数。 通过 rotate() 方法旋转，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。 通过 scale() 方法缩放，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数：值 scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。 通过 skew() 方法倾斜，元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数：值 skew(30deg,20deg) 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。 matrix() 方法把所有 2D 转换方法组合在一起。matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 transform: skew(30deg,20deg); skewX(angle) skewY(angle) transform-origin 属性允许您改变被转换元素的位置 2D 转换元素能够改变元素 x 和 y 轴。3D 转换元素还能改变其 Z 轴。 方法三：与方法二相比用margin取代transform.box { width: 400px; height: 200px; background-color: #ccc; position: absolute; left:50%; top:50%; margin-left:-200px; /*这里的-200px不能用-50%所替代*/ margin-top:-100px; } 方法四：弹性布局Flex以下放在所要居中的div父元素中，父元素必须有高度 divpare { height: 800px; display: flex; justify-content: center; align-items: center; } 水平居中参照水平垂直居中： margin：0 auto； left:50%; margin-left:-width/2;或者 transform: translateX(-width·/2) 更多方法请参照https://www.w3cplus.com/css/vertically-center-content-with-css 彩蛋：框模型]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《影响力》]]></title>
    <url>%2Fnote%2F2018%2Fundefined06%2Fb85ac64d.html</url>
    <content type="text"><![CDATA[《影响力》【美】 罗伯特.西奥迪尼 著 陈叙 译 中国人民大学出版社 首先这本书还是挺实用的，讲了生活中常见的坑以及应该如何避开别人挖的坑。这本书被营销领域吹得挺厉害的，对此书的评价在结尾处聊。 太多字的思维导图不是很适合阅读，所以全图就不传了 第一章影响力的武器固定性为模式：黄鼠狼是火鸡的天敌。每当它们靠近时火鸡妈妈就会发出愤怒的叫声，对它们又啄又抓，即使用绳子拉着黄鼠狼标本去接近火鸡妈妈，也会立刻遭到他们猛烈地攻击。然而在同样的黄鼠狼标本内放入一个能发出“吱吱声”的小录音机，火鸡妈妈不仅会接受它正在靠近，而且还会把它拢在自己身下。一旦把收音机关上，黄鼠狼标本马上又会遭到凶猛的攻击。它会虐待甚至杀死自己的亲生孩子，也仅仅因为它没能发出这种叫声。这种盲目机械的，有规律的行为模式被称为“固定性为模式”。 1.1 有效请求帮助当我们请别人帮忙时，如果能讲出一个理由，我们得到别人帮助的可能性会更大 对不起，我有五页纸要复印，能不能让我先复印呢？因为我要复印几页纸。 93% 对不起，我有五页纸要复印，能不能让我先复印啊？因为我有急事。 成功率94%。 对不起，我有五页纸要复印，能不能让我先复印呢？ 60% “因为”一词触发了下意识顺从反应，人性惯性 1.2 低廉的的绿松石提升价格反而销售一空—–“价高=质优” 人生生活经验1.3 对比原理看过貌美的明星后会觉得相貌平平的异性更丑 一只手放进凉水，一只手放进热手。然后一起放进常温的水里，两只手的的感觉是一凉一热 推销商品时，先推销贵的，之后再推销便宜的，让人有实惠的感觉。（买车，再推销花哨的装饰） 买房时，销售会先带你看几套又破又贵的房子，然后其它普通的房子显得更加有吸引力 人身体的存在缺陷 生活中注意以上三个方面被人挖的坑，解决方法暂无。可以尝试下反人性，比如不贪小便宜，做个nice的人。当然谙熟人性，是一种能力，能力本身是没有对错的。由于生活节奏比较快，没有精力与能力对每件事亲自认识和分析，我们仍需要一些不假思索的下意识反应。 第二章互惠2.1 人类社会从互惠原理中获得了重要的竞争优势，因此我们每个人都知道，遵循这个原理就会得到社会认可，否则就会得到人们的嘲弄。拥有如此巨大社会认同，难免会被人加以利用 先送你一朵花，然后让你买东西 让你免费试吃，然后你感觉不好意思，就买了些东西。 海尔售后维修人员服务态度超好，行为超规范，会让人感觉到受了那么一丝丝恩惠，想再买一台海尔或者对人宣传海尔真是好。 2.2 让步 精髓就是鲁迅说的中国人爱折中。说借我一百元，被拒。接着那借我五十元。。在使用的过程中要注意第一步提出的要求不能太过分，要在情理之中，否则效果会适得其反。 让你买一百元的电影票，拒绝。（人已拒绝常会想补偿的心理）接着对提出请求你买无缘的巧克力，遂买。被跳坑。 互惠简单说就是吃人家嘴软，拿人家手短，人情往来。解决办法：最好就是不接受，但是不现实，可能会误伤些好心。为此首先要明白一种行为或恩惠是情理还是销售手段。对于情理当然需要另一个人情来回报，否侧就把恩惠与事情独立分开看，该拒绝就拒绝，不要被人用道德捆绑。最后现实生活肯定要复杂的多的多，祝好各位。 第三章承诺和一致3.1 一致性原理。一旦我们做出某个决定，某个承诺，或选择了某个立场，就会面对来自个人和外部的压力迫使我们的言行与它保持一致。在大多数情况下，保持一致都是一种最具适应性、最受尊重的行为。和互惠一样，个人观点被主流看法所挟持，进而所形成的一种巨大人性惯性。 言行一致的心理惯性 赌马者一旦下注，就对自己买的那匹马信心大增 选择了一个渣男，还安慰自己男票可好了。 东西放在一个地方，被人拿走时，20有4个出来制止。当告诉旁人帮帮照看下时，20有19个人出来制止。 家长答应孩子去买最近最火的玩具，商家故意缺货，在玩具店暂时买了其他玩具作为替代。等到玩具销售季节过去，最火的玩具开始供货，由于家长已答应孩子买那种玩具，进而保持营销的连贯性 思维一致 有时让我们逃避思考的不是思考过程的艰辛，而是思考得出的严重后果。这种压力加上机械性的保持一致，它能为我们提供一个暂时躲避烦恼的堡垒，从而让理性失效。 比如：你抓住了悬崖旁边的一根被老鼠咬过的藤绳，幻想它怎样都不会断 3.2承诺的惯性问：你好吗。答：好啊。问：买个彩票好吗？惯性回答：好啊。 先来小请求（诱敌上钩，操纵一个人的自我形象），再来大请求。 请在：支持美化环境的请愿书上签字。。给你一个良好的市民形象。。之后说要里一个安全驾驶的大牌子。（内心想：我是一个良好市民，应当同意） 3.3如何让承诺更有效力3.3.1书面承诺 物质证据，也可用来说服他人。 减少退货率：让购买人自己签署购买合同。 各大公司发起的征文比赛，用来吹捧自家产品。 进而大众逐渐相信自己所想来的产品优点， 履行一个承诺所要付出的努力越多，对许诺者的影响力越大。（人们更珍惜来之不易的东西） 许多大公司的面试难度非常大，当面试成功者一般更不愿离职，对团体的认同感更大。（内心os：能面试进来的都是精英） 3.3.2内心主动的选择 A对一些小朋友说：“你不能玩某个玩具B，玩它是不对的。如果你敢玩，我就会打你”。结果当时没人敢玩，过了几个星期后，A离开了学校，让小朋友自愿选择玩具时，77%的人拿了玩具B。 A又对另一批小朋友说：“玩玩玩具B是不对的”。几个星期后，大多数人都没人拿那个玩具。（想想怎么教育孩子，劝说孩子说让孩子觉察到的外部压力越少越好，不容易） 买车时，刚开始给个诱饵，说车的价钱比外面便宜四五百。首先让你喜欢在这买车，后来找个借口把诱饵拿掉。（但我们已被自己说服） 3.4 避免被坑感受自己胃及身体做出的反应，听从内心。 把诱饵，被赋予的形象拿掉后，自己会怎样做 第四章社会认同4.1 社会认同原理的本质：我们进行是非判断的标准之一就是看别人怎么想的，尤其是当我们决定什么是正确的行为的时候。精髓：只有大约5%的人是原创者，而其他95%的人都是模仿者。我们从众，进而成为盲流。 配音笑声：来大家一起尬笑啊。 酒吧侍者会在托盘上放上几张钞票假装是前面的顾客留下的。 帮助有恐惧症的人摆脱恐惧心理：小男孩怕狗，每天花二十分钟观看一个小男孩高兴地与狗玩耍的情景。4天后，67%的儿童愿意与狗玩耍。观看电影片段也有同样的效果。 2012是世界末日预言失败。加入当这个预言是某个宗教预言时，当预言失败时，一般宗教会解散，也有宗教通过疯狂接受教众，为其信仰建立一个认同体系（认同某种观念的人越多，这种观念就越正确）。 4.2 社会认同原理的影响力在不确定性与相似性情况下威力巨大 4.2.1 不确定性。当我们对自己缺乏信心时，当形势不是很明朗时，当不确定性占上风时，我们有可能并参照别人的行为。 当一名受害者在痛苦中苦苦挣扎着需要帮助时，众多的旁观者却没有一个伸出援手。 首先我们都喜欢在众人面前表现的泰然自若，老成持重。其次，当旁人众多时，每个人的责任感都在下降，认为“其他人会帮忙，其他人已经这样做了”。所以当你前面的人，无视的路过一名受害者时，你大概率会跟着无视。混乱，人口稠密，认识率低这样的城市环境，扩大了这种不确定性，显得城市感情疏离。在农村，基本都相互认识，判断都比较明确。更有效的呼救，让别人明确自己的情况，可直接喊help等，更进一步，对着一个人，盯着他，指着他，直接对他提出明确的请求。如果对着大众呼救，每个人都以别人会帮忙的，反而降低成功率。 当领导者教徒去自杀时，自身大多会参考其它教众的做法，所以有时出大家一起殉道吧。 4.2.2相似性 年轻人自杀报道增多时，会有更多年轻人自杀事故。当大学生自杀报道增多时，同理。同时有一些自杀者，由于一些原因会让自杀看起来更不像自杀。比如马航事件，就有人怀疑是智慧老练的机长，想自杀，然后拉了一堆人陪葬。当然我本然更愿意相信它飞往了异度空间，不久就会飞回来。 第五章 喜好5.1 原理：人们总是愿意答应自己认识和喜爱的人提出的请求。在销售某种商品时说，某某（你认识的人）已经买过了。或者说某某推荐我来的。所以类似，买东西时有人说你能推荐你认识的你认为会喜欢这款商品的人吗？不能，这是在消耗社会关系。 5.2 增加被喜好的因素5.2.1 外表的吸引力颜值即正义，对于长得好看的人人们自然联想到美好的品质。 5.2.2 相似性。 我们喜欢那些与我们相似的人，不管他们是在观点上，个性上，穿着喜好兴趣上，背景上，还是生活方式上与我们相似。 销售人员会模仿客户的姿势、语气以及说话风格。 以及平时所说的一见钟情，知己啦，除了长得好看以外。也许我们看到了更多的相似性。 5.2.3 称赞拍马屁，人类的天性。要迎合的有技巧。 5.2.4 接触与合作 人们倾向于喜欢熟悉的东西。 在一处选举中，被选举人把自己的名字改为了常见的名字。 在写电子邮件时注意把握对方的语言用词习惯。 有人希望种族融合，黑人和白人一起上学。但是由于他们的接触带有学习上的竞争性，结果反而更加讨厌。通过增加一些“合作学习”来解决。对于有共同方向与目标或者有共同利益的的群体，更容易互生好感。 5.2.5 关联人们不喜欢坏消息，所以连带着憎恨带来坏消息的人。 讨厌一个人，进而讨厌一群人。 厂家总是希望自己的商品与美好的事物联系在一起。什么，我的商品请明星代言，我的商品有有文化内涵，我的商品纯天然啦。 销售人员有时请客户吃大餐的一个原因是客户会把对大餐的喜爱转到销售人员身上。 当我们喜欢的球队胜利时，我们会标榜我们是粉丝。当失败时，大都沉默。同时，我们也会标榜我们读过什么书，喜欢什么人，和谁谁很厉害我认识。意图把美好的品质转移到自己身上。 5.3 解决办法：交易是交易，感情是感情。当我们在短时间内，对一个人的好感反常的好时，要特别注意。第六章 权威李开复曾经说道，好多学生来信要求他给他们指点人生的发展道路。过于迷信权威，也在一定程度解释了好多无法想象的行为，也许都只是服从了一个权威的命令 典型的权威标志 头衔 一些医生明显的开错药方，护士有能力分辨时，却依然选择沉默服从； 衣着：警服等行业服装 外部标志：定制西装，名车...... 等红灯时，前面时豪车会比较耐心。一般的车会忍不住按喇叭。 第七章 短缺爱一样东西的方法就是意识到你可能会失去它 喜好，购买，抉择时不因外在条件与环境怎样。要关注本质。假如未来人们拉的粑粑越来越少，有些人会不会去买？ 个人评价感觉就是一本心理学应用。对心理研究的态度，和对技术以及隐私权的的态度挺像的，就是工具本身没有利弊，在于用的人。 本书的总结可以说：人是社会人，为了维护形象会有固定的行为模式，进而被别有用心的人挖坑。 即使没有看过这本书，我想对于有一定社会经验的人，对这些套路也都很熟悉。有些人，可能一字不识，但他们仍对这社会，这亘古的人性有通透的认识。听些不识字的阿姨拉家常，感觉我只是看了些名词，而本质以及应用远不及叔叔阿姨。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>读</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bgcolor与background-color]]></title>
    <url>%2Fnote%2F2018%2Fundefined24%2F2107d71c.html</url>
    <content type="text"><![CDATA[归属不同bgcolor 属于 html标签，更确切的说属于body标签。因为当作用于其他大多数标签时不起作用。但当用于table标签时有作用，至于什么原理，还请聪明的你告诉我。而background-color属于css标签。当然css是大趋势，都用css是最好的。 &lt;html&gt; &lt;body bgcolor=&apos;blue&apos;&gt; &lt;h1 style=&apos;background-color:purple&apos; &gt;春天在哪里&lt;/h1&gt; &lt;h2 bgcolor=&apos;purple&apos;&gt;春天在哪里&lt;/h2&gt; &lt;table bgcolor=&apos;red&apos;&gt; &lt;tr&gt; &lt;td&gt;春天在哪里&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 运行以上代码可看出h2并未变成紫色。 注意 属性值务必用英文状态下的字符 。比如&#39;red&#39;，否则目标不会显示红色，而会突变为其他色。 html 的势力范围很明显要比body的势力范围大。（html是页面所到之处，body是内容主体所到之处）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmlcss</tag>
      </tags>
  </entry>
</search>
