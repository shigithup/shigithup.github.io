<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.cat.net/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="读,JavaScript," />










<meta name="description" content="[美]   Nicholas  C.Zakes    著   李松峰   曹力  译  （第三版） 本文以JS高程为主线， 阮一峰的《 JavaScript标准参考教程》为辅。 第四章 变量、作用域和内存问题 第五章  引用类型">
<meta name="keywords" content="读,JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="读《JavaScript高级程序设计》（2）">
<meta property="og:url" content="https://shigithup.github.io/note/2018/undefined07/9b59a5f6.html">
<meta property="og:site_name" content="迷途小书童">
<meta property="og:description" content="[美]   Nicholas  C.Zakes    著   李松峰   曹力  译  （第三版） 本文以JS高程为主线， 阮一峰的《 JavaScript标准参考教程》为辅。 第四章 变量、作用域和内存问题 第五章  引用类型">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://myphoto.shigaozhen.cn/myselfhexo/20180507/172742584.jpg">
<meta property="og:image" content="http://myphoto.shigaozhen.cn/myselfhexo/20180507/182113261.jpg">
<meta property="og:image" content="http://myphoto.shigaozhen.cn/myselfhexo/20180507/194834166.png">
<meta property="og:image" content="http://myphoto.shigaozhen.cn/myselfhexo/20180510/100314990.jpg">
<meta property="og:image" content="http://myphoto.shigaozhen.cn/myselfhexo/20180510/173931748.png">
<meta property="og:image" content="https://www.w3cplus.com/sites/default/files/blogs/2016/1603/array-slice-2.png">
<meta property="og:updated_time" content="2018-05-24T09:50:14.893Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读《JavaScript高级程序设计》（2）">
<meta name="twitter:description" content="[美]   Nicholas  C.Zakes    著   李松峰   曹力  译  （第三版） 本文以JS高程为主线， 阮一峰的《 JavaScript标准参考教程》为辅。 第四章 变量、作用域和内存问题 第五章  引用类型">
<meta name="twitter:image" content="http://myphoto.shigaozhen.cn/myselfhexo/20180507/172742584.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":"ture","onmobile":"ture"},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://shigithup.github.io/note/2018/undefined07/9b59a5f6.html"/>





  <title>读《JavaScript高级程序设计》（2） | 迷途小书童</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><meta name="google-site-verification" content="a33qFOFK35xetcET7qBnQHDDB3VkD8mOMd8uwvF6A28" />

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">迷途小书童</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">史高震的世界碎片</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://shigithup.github.io/note/2018/undefined07/9b59a5f6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="3039535188@qq.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">读《JavaScript高级程序设计》（2）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-07T11:16:23+08:00">
                2018-05-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-05-24T17:50:14+08:00">
                2018-05-24
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/note/2018/undefined07/9b59a5f6.html" class="leancloud_visitors" data-flag-title="读《JavaScript高级程序设计》（2）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>[美]   Nicholas  C.Zakes    著   李松峰   曹力  译  （第三版）</p>
<p>本文以JS高程为主线， 阮一峰的《 JavaScript标准参考教程》为辅。</p>
<p>第四章 变量、作用域和内存问题</p>
<p>第五章  引用类型</p>
</blockquote>
<a id="more"></a>
<h1 id="第四章-变量、作用域和内存问题"><a href="#第四章-变量、作用域和内存问题" class="headerlink" title="第四章 变量、作用域和内存问题"></a>第四章 变量、作用域和内存问题</h1><p>本章内容：</p>
<blockquote>
<ul>
<li>理解基本类型和引用类型的值</li>
<li>理解执行环境</li>
<li>理解垃圾收集</li>
</ul>
</blockquote>
<h1 id="4-1-基本类型和引用类型的值"><a href="#4-1-基本类型和引用类型的值" class="headerlink" title="4.1  基本类型和引用类型的值"></a>4.1  基本类型和引用类型的值</h1><p>基本类型的访问是按值访问的，就是说你可以操作保存在变量中的实际的值。我们不能给基本类型添加属性和方法。</p>
<p>基本类型的值是不可变的：</p>
<p> 比如一个字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'jozo'</span>; name.toUpperCase(); <span class="comment">// 输出 'JOZO' console.log(name); // 输出 'jozo'</span></span><br></pre></td></tr></table></figure>
<p>会发现原始的name并未发生改变，而是调用了toUpperCase()方法后返回的是一个新的字符串。</p>
<h2 id="4-1-1-复制变量值"><a href="#4-1-1-复制变量值" class="headerlink" title="4.1.1 复制变量值"></a>4.1.1 复制变量值</h2><p>复制基本类型的值，会在对象变量上创建一个新值，然后把该值复制到为新变量分配的位置上。例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = num1;</span><br></pre></td></tr></table></figure>
<p>其过程如下：</p>
<p>复制前的变量值</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">num1</td>
<td>5（Number类型）</td>
</tr>
</tbody>
</table>
<p>复制后的变量对象</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>num2</td>
<td>5（Number类型）</td>
</tr>
<tr>
<td>num1</td>
<td>5（Number类型）</td>
</tr>
</tbody>
</table>
<p>这两个变量可以独立操作而不受任何影响。</p>
<p>复制引用类型的值，会把对象变量的值复制一份，然后把该值放到 到为新变量分配的位置上。例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.name = <span class="string">"我有名字了"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.name); <span class="comment">// 我有名字了</span></span><br></pre></td></tr></table></figure>
<p>由上面例子，我们声明了一个引用数据类型变量obj1，并把它赋值给了另外一个引用数据类型变量obj2。当我们obj2添加了一个name属性并赋值”我有名字了”。obj1同样拥有了和obj2一样的name属性。说明这两个引用数据类型变量指向同一个堆内存对象。obj1赋值给obj2，实际只是把这个堆内存对象在栈内存的引用地址复制了一份给了obj2，但它们本质上共同指向了同一个堆内存对象。</p>
<p>下面我们来演示这个引用数据类型赋值过程：</p>
<p><img src="http://myphoto.shigaozhen.cn/myselfhexo/20180507/172742584.jpg" alt="mark"></p>
<p>自然，给obj2添加name属性，<u>实际上是给堆内存中的对象添加了name属性</u>，obj2和obj1在栈内存中保存的只是堆内存对象的引用地址，虽然也是拷贝了一份，但指向的对象却是同一个。故而改变obj2引起了obj1的改变。</p>
<p><a href="http://www.jb51.net/article/65911.htm" target="_blank" rel="noopener">这一段引自本链接</a></p>
<h2 id="4-1-2-传递参数"><a href="#4-1-2-传递参数" class="headerlink" title="4.1.2 传递参数"></a>4.1.2 传递参数</h2><p>访问变量有按值和按引用两种方式（如同变量的基本类型值的复制和引用类型的值的复制），而参数只按值传递。 其实可以这么理解，只有按值传递。只不过基本类型传递是变量本身实在的值，而引用类型传递是也是变量的值，只不过这里的值是引用地址。</p>
<p><img src="http://myphoto.shigaozhen.cn/myselfhexo/20180507/182113261.jpg" alt="mark"></p>
<h1 id="4-2-执行环境及作用域"><a href="#4-2-执行环境及作用域" class="headerlink" title="4.2 执行环境及作用域"></a>4.2 执行环境及作用域</h1><p>执行环境：定义了变量和函数有权访问的其他数据，决定了他们各自的行为。</p>
<p>JavaScript中的运行环境大概包括三种情况：<br>（1）全局环境：JavaScript代码运行起来会首先进入该环境<br>（2）函数环境：当函数被调用执行时，会进入当前函数中执行代码<br>（3）eval</p>
<p>全局执行环境是最外层的一个执行环境。在web浏览器中全局执行环境被认为是window对象。每个函数都有自己的执行环境。内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境的任何变量和函数；这是因为某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数也会被销毁。这也解释了局部变量不能在变量对象被外访问到的原因。</p>
<p>作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。当代码在一个环境中执行时，都会创建一个作用域链。 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。</p>
<p><img src="http://myphoto.shigaozhen.cn/myselfhexo/20180507/194834166.png" alt="mark"></p>
<h2 id="4-2-1-延长作用域链："><a href="#4-2-1-延长作用域链：" class="headerlink" title="4.2.1 延长作用域链："></a>4.2.1 延长作用域链：</h2><p>虽然执行环境只有两种——全局作用域和局部作用域，但是还是可以通过某种方式来延长作用域链。因为有些语句可以在作用域链的顶部增加一个临时的变量对象。<br>有两种情况会发生这种现象：<br>1、try-catch语句的catch块；<br>2、with语句；</p>
<h2 id="4-2-2-没有块级作用域"><a href="#4-2-2-没有块级作用域" class="headerlink" title="4.2.2 没有块级作用域"></a>4.2.2 没有块级作用域</h2><p>在其他类c语言中由花括号封闭的代码块都有自己的作用域，即js中执行环境。</p>
<p>任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> （<span class="literal">true</span>）&#123; </span><br><span class="line">	<span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert color;</span><br></pre></td></tr></table></figure>
<p>在js中color在外部仍可以访问到，而在有块级作用域的语言中，则访问不到。只有函数后的的代码块才是执行环境。</p>
<h2 id="4-3-垃圾收集"><a href="#4-3-垃圾收集" class="headerlink" title="4.3 垃圾收集"></a>4.3 垃圾收集</h2><p>内存生命周期</p>
<p>不管什么程序语言，内存生命周期基本是一致的：   </p>
<pre><code>分配你所需要的内存
使用分配到的内存（读、写）
不需要时将其释放\归还
</code></pre><p>垃圾回收的机制原理：找出不再使用的变量，然后释放掉其占用的内存。垃圾回收器会按照固定的时间或预定的的时间间隔周期性的执行。</p>
<p>来看下局部变量的生命周期。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，一旦函数结束，局部变量就没有存在必要了，可以释放它们占用的内存。但并不是所有的变量都那么容易判断是否还有存在的必要。</p>
<p>垃圾回收器必须知道哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来回收。用于<strong>标记无用变量</strong>的策略有很多，常见的有两种方式：</p>
<h3 id="1-标记清除"><a href="#1-标记清除" class="headerlink" title="1. 标记清除"></a>1. 标记清除</h3><p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量的标记和被环境中的变量引用的变量的标记，此后，如果变量再被标记则表示此变量准备被删除。</p>
<p>简单来说：垃圾收集器中有俩次判断变量是否要被收集。如果这俩次没逃脱掉，那就肯定要被收集的。<br>一是变量未被引用，二是已经执行过finalize方法。。。<br>也就是俩次标记，具体可以查下Jvm垃圾收集算法。<a href="https://segmentfault.com/q/1010000011936009" target="_blank" rel="noopener">参考自</a></p>
<h3 id="2-引用计数"><a href="#2-引用计数" class="headerlink" title="2. 引用计数"></a>2. 引用计数</h3><p>引用计数的含义是跟踪记录每个<strong>值</strong>被引用的次数。</p>
<blockquote>
<p>注意是值被引用的计数，释放的是值所占的内存。</p>
</blockquote>
<p>当创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1，在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1，需要释放一个对象时，就将该对象的引用计数减1，直至对象的引用计数为0，对象的内存会被立刻释放。</p>
<p>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">  a: &#123;</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></span><br><span class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2变量是第二个对“这个对象”的引用</span></span><br><span class="line">o = <span class="number">1</span>;      <span class="comment">// 现在，“这个对象”的原始引用o被o2替换了，即现在“这个对象”只被o2一个引用。</span></span><br><span class="line"><span class="keyword">var</span> oa = o2.a; <span class="comment">// 引用“这个对象”的a属性</span></span><br><span class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></span><br><span class="line">o2 = <span class="string">"yo"</span>; <span class="comment">// 最初的对象现在已经是零引用了</span></span><br><span class="line">           <span class="comment">// 他可以被垃圾回收了</span></span><br><span class="line">           <span class="comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span></span><br><span class="line">oa = <span class="literal">null</span>; <span class="comment">// a属性的那个对象现在也是零引用了</span></span><br><span class="line">           <span class="comment">// 它可以被垃圾回收了</span></span><br></pre></td></tr></table></figure>
<p> 该算法有个限制：无法处理循环引用。</p>
<p>两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"azerty"</span>;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p><strong>解除引用</strong>；一旦数据不再有用，通过将其值设置为null来释放其引用。</p>
<p>局部变量就是在离开执行环境时自动被解除引用。解除引用不意味释放内存，而是让值脱离执行环境，以便垃圾收集器运行时将其收回。</p>
<h1 id="4-4-堆内存与栈内存"><a href="#4-4-堆内存与栈内存" class="headerlink" title="4.4 堆内存与栈内存"></a>4.4 堆内存与栈内存</h1><p>在JS中，每一个数据都需要一个内存空间。内存空间又被分为两种，栈内存(stock)与堆内存</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th>堆内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储基础数据类型</td>
<td>存储引用数据类型</td>
</tr>
<tr>
<td>按值访问</td>
<td>按引用访问</td>
</tr>
<tr>
<td>存储的值大小固定</td>
<td>存储的值大小不定，可动态调整</td>
</tr>
<tr>
<td>由系统自动分配内存空间</td>
<td>由程序员通过代码进行分配</td>
</tr>
<tr>
<td>主要用来执行程序    主</td>
<td>要用来存放对象</td>
</tr>
<tr>
<td>空间小，运行效率高</td>
<td>空间大，但是运行效率相对较低</td>
</tr>
<tr>
<td>先进后出，后进先出</td>
<td>无序存储，可根据引用直接获取</td>
</tr>
</tbody>
</table>
<h1 id="第五章-引用类型"><a href="#第五章-引用类型" class="headerlink" title="第五章 引用类型"></a>第五章 引用类型</h1><p>引用类型的值（对象）是<strong>引用类型</strong>的一个实例。引用类型是一种数据结构，用于将数据和功能组织在一起。它也被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。</p>
<p>上面这句话应该意味着 </p>
<blockquote>
<p>引用类型是类在js中进行了修正以更符合js的要求一个变种。</p>
</blockquote>
<p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>
<p>新对象是使用new操作符后跟一个构造函数来创建的，构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>这行代码创建了Object引用类型的一个新实例，然后把该实例保存在了变量person中。使用的构造函数是Object，它只为新对象定义了默认的属性进和方法。</p>
<ul>
<li>对象：对象是类的一个实例 ，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li>类：类是一个模板，它描述一类对象的行为和状态。 </li>
</ul>
<p>下图中男孩女孩为类，而具体的每个人为该类的对象：</p>
<p><img src="http://myphoto.shigaozhen.cn/myselfhexo/20180510/100314990.jpg" alt="mark"></p>
<p>参考链接：<a href="http://www.runoob.com/java/java-object-classes.html" target="_blank" rel="noopener">Java 对象和类</a></p>
<h1 id="5-1-Object-类型"><a href="#5-1-Object-类型" class="headerlink" title="5.1 Object 类型"></a>5.1 Object 类型</h1><p>对象就是一组“键值对”（key-value，键名和键值）的集合，是一种无序的复合数据集合。</p>
<p>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键值），所以加不加引号都可以。但是如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</p>
<p>它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。如果属性的值还是一个对象，就形成了链式引用。</p>
<h2 id="创建Object实例的方法有两种。"><a href="#创建Object实例的方法有两种。" class="headerlink" title="创建Object实例的方法有两种。"></a>创建Object实例的方法有两种。</h2><p>第一种是使用new操作符后跟Object构造函数，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>（）；</span><br><span class="line">person.name = <span class="string">"xiangming"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>另一种方法是使用对象字面量表示法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	person.name ： <span class="string">"xiangming"</span>;</span><br><span class="line">	<span class="number">5</span> ： <span class="literal">true</span>；</span><br><span class="line">    person.age ： <span class="number">29</span>；</span><br><span class="line">    <span class="comment">//最后一个属性后面，加逗号可能会在旧版本浏览器，如ie7等中导致错误。</span></span><br><span class="line">    <span class="comment">//数值属性值会自动转换为字符串。</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;；</span><br><span class="line">person.name = <span class="string">"xiangming"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;               </span><br><span class="line"><span class="comment">// 这两个例子是等价的。</span></span><br></pre></td></tr></table></figure>
<p>这里的左花括号表示对象字面量的开始，if（）{}这里的则表示一个语句块的开始。<br>因此也解释了函数作用域的一个疑问，即在在if后面的{}定义的局部变量为什么在外部仍可以访问到，也因此if后的{}不是一个执行环境。</p>
<h2 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h2><p>一般都是用点表示法，在js中也可以用方括号表示法。在使用方括号时要将访问的属性以字符串的形式放在方括号里。例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person[<span class="string">"name"</span>]);  <span class="comment">//xiaoming</span></span><br><span class="line">alert(person.name);</span><br></pre></td></tr></table></figure>
<p> 方括号方法的优点是可以通过访问变量来访问属性，例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> propertyName = <span class="string">"name"</span>;</span><br><span class="line">alert(personn[propertyName]);</span><br></pre></td></tr></table></figure>
<p>如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字保留字，有些不能用点表示法来访问，可以使用方括号表示法。    </p>
<h2 id="for…in-循环"><a href="#for…in-循环" class="headerlink" title="for…in 循环"></a>for…in 循环</h2><p>for…in循环用来遍历一个对象的全部属性。</p>
<p>for…in循环有两个使用注意点。</p>
<p>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。<br>它不仅遍历对象自身的属性，还遍历继承的属性。<br>举例来说，对象都继承了toString属性，但是for…in循环不会遍历到这个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// toString 属性是存在的</span></span><br><span class="line">obj.toString <span class="comment">// toString() &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125; <span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象obj继承了toString属性，该属性不会被for…in循环遍历到，因为它默认是“不可遍历”的。 </p>
<p>如果继承的属性是可遍历的，那么就会被for…in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for…in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123; name: &apos;老张&apos; &#125;;</span><br><span class="line">for (var key in person) &#123;</span><br><span class="line">  if (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    console.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// name</span><br></pre></td></tr></table></figure>
<h1 id="5-2-Array-类型"><a href="#5-2-Array-类型" class="headerlink" title="5.2 Array  类型"></a>5.2 Array  类型</h1><p>数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。任何类型的数据，都可以放入数组。</p>
<p>如果数组的元素还是数组，就形成了多维数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] <span class="comment">// 2</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。</p>
<p>数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。<strong>通过数字索引可以增加和替换数据项。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];alert(arr.toString());</span><br><span class="line"><span class="built_in">Object</span>.keys(arr)</span><br><span class="line"><span class="comment">// ["0", "1", "2"]</span></span><br><span class="line">alert = (arr.length); <span class="comment">//3  </span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">`e`</span>;<span class="comment">//arr = ['a', 'b', 'c',,,e];第四项和第五项为undefined。</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Object.keys方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。</p>
<p>JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。</p>
<h2 id="创建数组的方式也有两种："><a href="#创建数组的方式也有两种：" class="headerlink" title="创建数组的方式也有两种："></a>创建数组的方式也有两种：</h2><p>第一种使用Array构造函数，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">//new操作符可省略</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//length值为20的数组</span></span><br><span class="line"> <span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Greg"</span>);</span><br><span class="line"><span class="comment">//如果传递的是非数值类型的参数，会创建包含那个值的数组。</span></span><br></pre></td></tr></table></figure>
<p>第二种方法使用字面量表示法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,]</span><br><span class="line"><span class="comment">// 创建两项或三项的数组（不同的版本的浏览器解解析有bug）第三项是undefined，所小心逗号</span></span><br></pre></td></tr></table></figure>
<h2 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h2><p>数组的<code>length</code>属性，返回数组的成员数量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说<code>length</code>属性的最大值就是 4294967295。</p>
<p>只要是数组，就一定有<code>length</code>属性。该属性是一个动态的值，等于键名中的最大整数加上<code>1</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">a[<span class="string">'p'</span>] = <span class="string">'abc'</span>;</span><br><span class="line">a.length <span class="comment">// 0</span></span><br><span class="line">a[<span class="number">2.1</span>] = <span class="string">'abc'</span>;</span><br><span class="line">a.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码将数组的键分别设为字符串和小数，结果都不影响<code>length</code>属性。因为，<code>length</code>属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以<code>length</code>属性保持为<code>0</code>。</p>
<h2 id="5-2-1-检测数组"><a href="#5-2-1-检测数组" class="headerlink" title="5.2.1 检测数组"></a>5.2.1 检测数组</h2><p>参考3.4.1typeof 操作符。</p>
<p>确定某个对象是不是数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">    <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>instance of 操作符的问题在于，它假定只有一个全局执行环境。如果网页包含多个框架，实际上就是存在多个不同的全局执行环境，从而存在多个不同版本的Array构造函数。如果一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架原生创建的的数组分别具有各自不同的构造函数。</p>
<p>为结决这个问题，ES5新增了<code>Array.isArray()</code>方法，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">     <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-2-转换方法"><a href="#5-2-2-转换方法" class="headerlink" title="5.2.2 转换方法"></a>5.2.2 转换方法</h2><p>所有的对象都具有<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>方法。其中调用<code>valueOf()</code>返回的还是数组本身，而调用数组的<code>toLocaleString()</code>方法会返回数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。</p>
<p>跳出数组的视角来看这几个定义，其实要分清这几个性价比实在不高，先放着：</p>
<p>valueOf() 方法返回一个String对象的原始值（primitive value）。</p>
<p>String 全局对象是一个用于字符串或一个字符序列的构造函数。String 对象用于处理文本（字符串）。</p>
<p>toString() 方法返回一个表示该对象的字符串。</p>
<p>toString()与String()的区别就在于String()还能转换null和undefined值，可以说是toString()的增强版。</p>
<p>toLocaleString() 方法返回一个该对象的字符串表示。此方法被用于派生对象为了特定语言环境的目的（locale-specific purposes）而重载使用。</p>
<p><del>什么是对象，尴尬，有说js里所有的事物都是对象：字符串、数值、数组、函数… 此外，JavaScript 允许自定义对象。 所有事物都是对象JavaScript 提供多个内建对象。（心里mmp）</del></p>
<p><del>String()方法</del><br><del>在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。String()函数遵循下列转换规则：</del></p>
<p><del>如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果；</del><br><del>如果值是null，则返回”null”；</del><br><del>如果值是undefined，则返回”undefined”</del>。参靠3.4.5-5</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">alert(arr.toString());<span class="comment">//a,b,c</span></span><br><span class="line">alert(arr.valueOf())<span class="comment">//["a", "b", "c"]</span></span><br></pre></td></tr></table></figure>
<p>另外，toLocalString()方法经常也会返回与toString()和valueOf()方法相同的值，但也不总是如此。当调用数组的toLocaleString()方法时，它也会创建一个数组的以逗号分割的字符串。而与前两个方法唯一的不同指出在于，这因此i是为了取得每一项的值，调用的是每一项的toLocaleString()方法，而不是toString()方法。请看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    toLocaleString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Nikolaos"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Nicholas"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    toLocaleString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Grigorios"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Greg"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> people = [person1, person2];</span><br><span class="line">alert(people);                   <span class="comment">//Nicholas,Greg</span></span><br><span class="line">alert(people.toString());        <span class="comment">//Nicholas,Greg</span></span><br><span class="line">alert(people.toLocaleString());  <span class="comment">//Nikolaos,Grigorios</span></span><br></pre></td></tr></table></figure>
<p>join() 方法只接收一个参数，即用作分隔符的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors =[<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>];</span><br><span class="line">alert(colors);<span class="comment">//red,green,blue</span></span><br><span class="line">alert(colors.join(<span class="string">','</span>)); <span class="comment">//red,green,blue</span></span><br><span class="line">alert(colors.join(<span class="string">'||'</span>)); <span class="comment">//red||green||blue</span></span><br></pre></td></tr></table></figure>
<h2 id="5-2-3-栈方法"><a href="#5-2-3-栈方法" class="headerlink" title="5.2.3 栈方法"></a>5.2.3 栈方法</h2><p>ES数组也提供了一种让数组行为类似于其他数据结构的方法。</p>
<p>栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构。只在栈的顶部增添和移除。</p>
<p>push（）方法可以接收任意数量的参数，把它们逐个添加到数组的末尾，返回修改后的数组的长度。</p>
<p>pop（）方法从数组末尾移除最后一项，减少数组的<code>length</code>的值，返回移除的项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">'red'</span>,<span class="string">'green'</span>);</span><br><span class="line">alert(count);<span class="comment">//2</span></span><br><span class="line">alert(colors);<span class="comment">// red,green</span></span><br><span class="line"><span class="keyword">var</span> item = colors.pop();</span><br><span class="line">alert(item); <span class="comment">// green</span></span><br></pre></td></tr></table></figure>
<h2 id="5-2-4-队列方法"><a href="#5-2-4-队列方法" class="headerlink" title="5.2.4 队列方法"></a>5.2.4 队列方法</h2><p>队列FIFO（先进先出）。在末端添加项，前端移除项。</p>
<p>shift 移除数组第一个项，并返回该项。</p>
<p>unshift在数组前端添加任意个项，返回数组新长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>,<span class="string">'green'</span>];</span><br><span class="line">alert(colors.shift()); <span class="comment">//red</span></span><br><span class="line"><span class="keyword">var</span> item = colors.unshift(<span class="string">'yellow'</span>,<span class="string">'blue'</span>);</span><br><span class="line">alert(item); <span class="comment">//4</span></span><br><span class="line">alert(colors);<span class="comment">//yellow,blue,red,green</span></span><br></pre></td></tr></table></figure>
<p><img src="http://myphoto.shigaozhen.cn/myselfhexo/20180510/173931748.png" alt="mark"></p>
<h2 id="5-2-5-重排序方法"><a href="#5-2-5-重排序方法" class="headerlink" title="5.2.5  重排序方法"></a>5.2.5  重排序方法</h2><p>reverse()方法会反转数组项的顺序。（仅仅是翻转而已，并不按大小）</p>
<p>sort()方法按升序排列数组项。（比较字符串大小，不是数值大小）</p>
<p>为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以 确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。</p>
<p><u>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下</u>：</p>
<ol>
<li>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</li>
<li>若 a 等于 b，则返回 0。</li>
<li>若 a 大于 b，则返回一个大于 0 的值。</li>
</ol>
<blockquote>
<p>默认这个返回值，是按升序排列的，把1改为返回一个大于0的值，3返回一个小于0的值，就可按降序排列。</p>
</blockquote>
<p>如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values); <span class="comment">//0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
<p>以下就是一个简单的比较函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values); <span class="comment">//0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
<p>对于数值类型或者valueOf（）方法会返回数值类型的对象类型，可用一个更简单的比较函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value2 - value1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br></pre></td></tr></table></figure>
<h2 id="5-2-6-操作方法"><a href="#5-2-6-操作方法" class="headerlink" title="5.2.6 操作方法"></a>5.2.6 操作方法</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p><code>concat()</code> 方法用于连接两个或多个数组。</p>
<p>该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.concat(arrayX,arrayX,......,arrayX)</span><br></pre></td></tr></table></figure>
<p>arrayX    必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个，如果没有参数那么仅是复制了原函数。</p>
<p>如果要进行 <code>concat()</code> 操作的参数是数组，那么添加的是数组中的元素，而不是数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">document</span>.write(a.concat(<span class="number">4</span>,<span class="number">5</span>));<span class="comment">//1,2,3,4,5</span></span><br></pre></td></tr></table></figure>
<p><code>push()</code>和<code>concat()</code>方法都可以将传的参数添加到数组的后面，只不过<code>push()</code>是在原数组上操作（改变的是原数组），<code>concat()</code>不会改变原数组，创建原数组的副本，并且把传的参数添加到新数组后面。</p>
<p><code>push()</code>传递的参数是数组时，将整个数组传给原数组末尾，如示例中得到的结果[“a”, “b”, Array[2], Array[3]]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["a", "b"]</span></span><br><span class="line">arr.push([<span class="string">'c'</span>,<span class="string">'d'</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["a", "b", Array[2], Array[3]]</span></span><br></pre></td></tr></table></figure>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p><code>slice()</code>方法它也能基于当前数组创建一个新数组，而且对原数组也并不会有任何影响。<br><code>slice()</code>接受一个或两个参数，即要返回项的起始和结束位置（<strong>但不包括结束位置的项</strong>）。当只给<code>slice()</code>传递一个参数时，该方法返回从该参数指定位置开始到当前数组末尾的所有项。如下面示例：</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2016/1603/array-slice-2.png" alt=""></p>
<p>当传递的参数是负值,用数组长度加上该负值。结束位置小于或等于开始位置，将返回一个空数组。</p>
<p><code>slice()</code>方法和<code>concat()</code>方法类似，会在原数组上构建一个新数组，并不会影响原数组。</p>
<p><strong>参考自，w3cplus。</strong></p>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>可删除、插入、替换。splice()方法还会影响原数组</p>
<p>在<code>splice()</code>方法中指定两个参数，第一个参数是指定开始删除数组项位置，第二个数是指删除数组项的个数。</p>
<p><code>splice(0,2)</code>会删除数组中前两项。</p>
<p>指定三个参数，第一个参数为插入的起始位置，第二个参数为<code>0</code>(要删除的数组项数量，因为删除数量是为<code>0</code>，所以不做删除)，第三个参数是要插入的数组项。（数组项可任意多）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>];</span><br><span class="line"><span class="keyword">var</span> removed = colors.splice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">alert(colors); <span class="comment">//green,blue</span></span><br><span class="line">alert(removed);<span class="comment">//red</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">'yellow'</span>,<span class="string">'orange'</span>);</span><br><span class="line">alert(colors);<span class="comment">//grenn,yellow,orange,blue</span></span><br><span class="line">alert(removed);返回一个空数组，因为删除项为<span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'red'</span>,<span class="string">'purple'</span>);</span><br><span class="line">alert(colors);<span class="comment">//grenn,red,purple,orange,blue</span></span><br><span class="line">alert(removed);</span><br></pre></td></tr></table></figure>
<h2 id="5-2-7-位置方法"><a href="#5-2-7-位置方法" class="headerlink" title="5.2.7 位置方法"></a>5.2.7 位置方法</h2><p>ES5为数组实例添加了两个位置方法：<code>indexOf()</code>和<code>lastIndexi()</code>.这两个方法都可以接收两个参数：要<strong>查找的项</strong>和（可选）表示查找位置起点的索引。<code>indexOf()</code>从数组的开头（位置0）开始，<code>lastIndexi()</code>从数组的末尾开始。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>];</span><br><span class="line">alert(colors.indexOf(<span class="string">'green'</span>));<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>这两个方法都返回要查找的项在数组中的位置，<u>或者在没找到的情况下返回-1</u>.在比较查找的第一项与数组中的每一项时，要使用全等操作符，要严格相等。</p>
<h2 id="5-2-8-迭代方法"><a href="#5-2-8-迭代方法" class="headerlink" title="5.2.8 迭代方法"></a>5.2.8 迭代方法</h2><p>五个迭代方法 都接受两个参数：要在每一项上运行的函数 和 运行该函数的作用域（可选）。传入这些方法中的函数会接收三个参数：数组项的值，该项在数组中的位置和数组对象本身。</p>
<p>ES5为数组定义了五个迭代方法：</p>
<ul>
<li>forEach()：对数组中每一项运行给定函数。该函数没有返回值。</li>
<li>every(): 对数组中的每一项运行给定函数。如果函数对每一项都返回 true，则返回 true。</li>
<li>some(): 对数组中每一项运行给定函数。如果函数对 任一项返回 true，则返回 true</li>
<li>filter(): 对数组中的每一项运行给定函数。返回该函数会返回 true 的项组成的数组。 </li>
<li>map(): 对数组中每一项运行给定函数。返回每次函数调用的结果组成的函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];  </span><br><span class="line">        <span class="comment">// item:当前遍历项，index:当前项索引，array:数组对象本身  </span></span><br><span class="line">        <span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> item &gt; <span class="number">2</span>;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        alert(everyResult);<span class="comment">//false  </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> item &gt; <span class="number">2</span>;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        alert(someResult);<span class="comment">//true  </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> item &gt; <span class="number">2</span>;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        alert(filterResult);<span class="comment">//[3,4,5,4,3]  </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> item * <span class="number">2</span>;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        alert(mapResult);<span class="comment">//[2,4,6,8,10,8,6,4,2]  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//forEach 本质上和for循环没有区别  </span></span><br><span class="line">        <span class="keyword">var</span> forEachResult=numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;  </span><br><span class="line">	    <span class="comment">//执行某些操作 比如 alert(item)  </span></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="5-2-9-归并算法"><a href="#5-2-9-归并算法" class="headerlink" title="5.2.9 归并算法"></a>5.2.9 归并算法</h2><p>ECMAScript 5 新增两个归并数组的方法：reduce() 和 reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。<br>使用<code>reduce</code>()还是<code>reduceRight()</code>，主要取决于要从哪头开始遍历，除此之外，它们完全相同。前者从数组的第一项开始，后者从从最后一项开始 。<br>reduce()方法接受两个参数 ：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。</p>
<p>我们先说一说第一个参数。这个参数（函数）接收 4 个参数：前一个值，当前值，项的索引和数组对象。</p>
<p>来个例子🌰：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 reduce() 方法可以执行求数组里所有值之和的操作</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prev);  <span class="comment">// 共执行四次，依次输出 1， 3， 6， 10</span></span><br><span class="line">  <span class="built_in">console</span>.log(cur);   <span class="comment">// 共执行四次，依次输出 2， 3， 4， 5</span></span><br><span class="line">  <span class="built_in">console</span>.log(index); <span class="comment">// 共执行四次，依次输出 1, 2, 3, 4</span></span><br><span class="line">  <span class="built_in">console</span>.log(array); <span class="comment">// 共执行四次，每次都输出原数组 [1,2,3,4,5]</span></span><br><span class="line">  <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>第一次执行回调函数，prev 是 1（数组的第一项） ，cur 是 2（数组的第二项），index 是 1（注意并没从 0 开始）。<br>第二次，prev 是 3 （1 加 2 的结果），cur 是 3 （数组的第三项），index 是 2。</p>
<p>这个过程会持续到把数组中的每一项都访问一遍，最后返回结果（一共执行四次，得到 1 + 2 + 3 + 4 + 5 = 15）。</p>
<h2 id="5-3-Date-类型"><a href="#5-3-Date-类型" class="headerlink" title="5.3 Date 类型"></a>5.3 Date 类型</h2><h2 id="静态方法（Date-方法-而不是通过变量名-方法）"><a href="#静态方法（Date-方法-而不是通过变量名-方法）" class="headerlink" title="静态方法（Date.方法()而不是通过变量名.方法）"></a>静态方法（<code>Date.方法()</code>而不是通过<code>变量名.方法</code>）</h2><p>Date对象是 JavaScript 原生的时间库。它以1970年1月1日00:00:00(UTC)作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。</p>
<p>要创建一个日期对象，使用new操作符和Date构造函数即可，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">//Mon May 14 2018 08:28:34 GMT+0800 (中国标准时间)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">100000</span>);</span><br><span class="line">now;<span class="comment">// Thu Jan 01 1970 08:01:40 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
<p>在调用构造函数而不传递参数的情况下，新创建的对象自动获取当前时间,如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数(即从UTC时间1970年一月一日午夜起至该日期经过的毫秒数)。</p>
<p>为了简化这一过程，ES提供了两个方法：<code>Date.parse()</code>和<code>Date.UTC()</code></p>
<h2 id="1-Date-parse"><a href="#1-Date-parse" class="headerlink" title="1. Date.parse()"></a>1. <code>Date.parse()</code></h2><p><code>Date.parse()</code>方法接收一个表示日期的字符串数，<u>然后返回相应的毫秒数</u>，如果接收的字符串不能被解析，则返回NaN，但是由于浏览器不同，不一定返回NaN。</p>
<p>日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区。但是，其他格式也可以被解析。</p>
<p>由于 <code>parse()</code> 是 Date 的一个静态方法 , 所以应该使用<code>Date.parse()</code> 来调用，而不是作为 Date 的实例方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">'2014-03-07'</span>)); </span><br><span class="line"><span class="comment">//Fri Mar 07 2014 08:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">'2014-03-07'</span>));</span><br><span class="line">与  <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2014-03-07'</span>);now;是等价的。<span class="built_in">Date</span>构造函数会在后台调用<span class="built_in">Date</span>.parse()。</span><br></pre></td></tr></table></figure>
<h2 id="2-Date-UTC"><a href="#2-Date-UTC" class="headerlink" title="2. Date.UTC()"></a>2. <code>Date.UTC()</code></h2><p>接受和构造函数最长形式的参数相同的参数（从2到7），并<u>返回从 1970-01-01 00:00:00 UTC 开始所经过的毫秒数</u>。 参数分别为年份、月份（0-11）、日（1-31）、小时（0-23）、分钟、秒以及毫秒数。前两个参数必须，月，默认天数1，其它默认为0 。</p>
<h2 id="3-Date-now"><a href="#3-Date-now" class="headerlink" title="3. Date.now()"></a>3. Date.now()</h2><p>Date.now() 方法<u>返回自1970年1月1日 00:00:00 UTC到当前时间的毫秒数</u>。</p>
<p>因为 now() 是Date的一个静态函数，所以必须以 Date.now() 的形式来使用。</p>
<p> 总：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(dateString);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(year, month [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);</span><br></pre></td></tr></table></figure>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>Date的实例对象，有几十个自己的方法，除了<code>valueOf</code>和<code>toString</code>，可以分为以下三类。</p>
<p>to类：从Date对象返回一个字符串，表示指定的时间。<br>get类：获取Date对象的日期和时间。<br>set类：设置Date对象的日期和时间。</p>
<p>valueOf方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法和<code>Date.now()</code>。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_Date.asp" target="_blank" rel="noopener">Date()</a></td>
<td>返回当日的日期和时间。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getDate.asp" target="_blank" rel="noopener">getDate()</a></td>
<td>从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getDay.asp" target="_blank" rel="noopener">getDay()</a></td>
<td>从 Date 对象返回一周中的某一天 (0 ~ 6)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getMonth.asp" target="_blank" rel="noopener">getMonth()</a></td>
<td>从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getFullYear.asp" target="_blank" rel="noopener">getFullYear()</a></td>
<td>从 Date 对象以四位数字返回年份。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getYear.asp" target="_blank" rel="noopener">getYear()</a></td>
<td>请使用 getFullYear() 方法代替。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getHours.asp" target="_blank" rel="noopener">getHours()</a></td>
<td>返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getMinutes.asp" target="_blank" rel="noopener">getMinutes()</a></td>
<td>返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getSeconds.asp" target="_blank" rel="noopener">getSeconds()</a></td>
<td>返回 Date 对象的秒数 (0 ~ 59)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getMilliseconds.asp" target="_blank" rel="noopener">getMilliseconds()</a></td>
<td>返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getTime.asp" target="_blank" rel="noopener">getTime()</a></td>
<td>返回 1970 年 1 月 1 日至今的毫秒数。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getTimezoneOffset.asp" target="_blank" rel="noopener">getTimezoneOffset()</a></td>
<td>返回本地时间与格林威治标准时间 (GMT) 的分钟差。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getUTCDate.asp" target="_blank" rel="noopener">getUTCDate()</a></td>
<td>根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getUTCDay.asp" target="_blank" rel="noopener">getUTCDay()</a></td>
<td>根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getUTCMonth.asp" target="_blank" rel="noopener">getUTCMonth()</a></td>
<td>根据世界时从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getUTCFullYear.asp" target="_blank" rel="noopener">getUTCFullYear()</a></td>
<td>根据世界时从 Date 对象返回四位数的年份。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getUTCHours.asp" target="_blank" rel="noopener">getUTCHours()</a></td>
<td>根据世界时返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getUTCMinutes.asp" target="_blank" rel="noopener">getUTCMinutes()</a></td>
<td>根据世界时返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getUTCSeconds.asp" target="_blank" rel="noopener">getUTCSeconds()</a></td>
<td>根据世界时返回 Date 对象的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_getUTCMilliseconds.asp" target="_blank" rel="noopener">getUTCMilliseconds()</a></td>
<td>根据世界时返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_parse.asp" target="_blank" rel="noopener">parse()</a></td>
<td>返回1970年1月1日午夜到指定日期（字符串）的毫秒数。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setDate.asp" target="_blank" rel="noopener">setDate()</a></td>
<td>设置 Date 对象中月的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setMonth.asp" target="_blank" rel="noopener">setMonth()</a></td>
<td>设置 Date 对象中月份 (0 ~ 11)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setFullYear.asp" target="_blank" rel="noopener">setFullYear()</a></td>
<td>设置 Date 对象中的年份（四位数字）。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setYear.asp" target="_blank" rel="noopener">setYear()</a></td>
<td>请使用 setFullYear() 方法代替。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setHours.asp" target="_blank" rel="noopener">setHours()</a></td>
<td>设置 Date 对象中的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setMinutes.asp" target="_blank" rel="noopener">setMinutes()</a></td>
<td>设置 Date 对象中的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setSeconds.asp" target="_blank" rel="noopener">setSeconds()</a></td>
<td>设置 Date 对象中的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setMilliseconds.asp" target="_blank" rel="noopener">setMilliseconds()</a></td>
<td>设置 Date 对象中的毫秒 (0 ~ 999)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setTime.asp" target="_blank" rel="noopener">setTime()</a></td>
<td>以毫秒设置 Date 对象。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setUTCDate.asp" target="_blank" rel="noopener">setUTCDate()</a></td>
<td>根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setUTCMonth.asp" target="_blank" rel="noopener">setUTCMonth()</a></td>
<td>根据世界时设置 Date 对象中的月份 (0 ~ 11)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setUTCFullYear.asp" target="_blank" rel="noopener">setUTCFullYear()</a></td>
<td>根据世界时设置 Date 对象中的年份（四位数字）。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setutchours.asp" target="_blank" rel="noopener">setUTCHours()</a></td>
<td>根据世界时设置 Date 对象中的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setUTCMinutes.asp" target="_blank" rel="noopener">setUTCMinutes()</a></td>
<td>根据世界时设置 Date 对象中的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setUTCSeconds.asp" target="_blank" rel="noopener">setUTCSeconds()</a></td>
<td>根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_setUTCMilliseconds.asp" target="_blank" rel="noopener">setUTCMilliseconds()</a></td>
<td>根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_tosource_boolean.asp" target="_blank" rel="noopener">toSource()</a></td>
<td>返回该对象的源代码。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_toString_date.asp" target="_blank" rel="noopener">toString()</a></td>
<td>把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_toTimeString.asp" target="_blank" rel="noopener">toTimeString()</a></td>
<td>把 Date 对象的时间部分转换为字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_toDateString.asp" target="_blank" rel="noopener">toDateString()</a></td>
<td>把 Date 对象的日期部分转换为字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_toGMTString.asp" target="_blank" rel="noopener">toGMTString()</a></td>
<td>请使用 toUTCString() 方法代替。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_toUTCString.asp" target="_blank" rel="noopener">toUTCString()</a></td>
<td>根据世界时，把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_toLocaleString.asp" target="_blank" rel="noopener">toLocaleString()</a></td>
<td>根据本地时间格式，把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_toLocaleTimeString.asp" target="_blank" rel="noopener">toLocaleTimeString()</a></td>
<td>根据本地时间格式，把 Date 对象的时间部分转换为字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_toLocaleDateString.asp" target="_blank" rel="noopener">toLocaleDateString()</a></td>
<td>根据本地时间格式，把 Date 对象的日期部分转换为字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_utc.asp" target="_blank" rel="noopener">UTC()</a></td>
<td>根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_valueOf_date.asp" target="_blank" rel="noopener">valueOf()</a></td>
<td>返回 Date 对象的原始值。</td>
</tr>
</tbody>
</table>
<p>set:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span> (<span class="string">'January 6, 2013'</span>);</span><br><span class="line"></span><br><span class="line">d <span class="comment">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line">d.setDate(<span class="number">9</span>) <span class="comment">// 1357660800000        返回的是毫秒数</span></span><br><span class="line">d <span class="comment">// Wed Jan 09 2013 00:00:00 GMT+0800 (CST)  返回设置后的日期显示</span></span><br></pre></td></tr></table></figure>
<p>to:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line">d.toUTCString() <span class="comment">//"Mon, 14 May 2018 02:05:17 GMT"</span></span><br></pre></td></tr></table></figure>
<p>get:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">d.getDate()<span class="comment">//14 当前日期（5.14）</span></span><br></pre></td></tr></table></figure>
<p><a href="https://baike.baidu.com/item/%E4%B8%96%E7%95%8C%E6%97%B6/692237?fr=aladdin&amp;fromid=6026868&amp;fromtitle=GMT" target="_blank" rel="noopener">GMT与UTC两个时区</a></p>
<h1 id="5-4-RegEXp-类型"><a href="#5-4-RegEXp-类型" class="headerlink" title="5.4 RegEXp 类型"></a>5.4 RegEXp 类型</h1><h2 id="字面量知识点补充"><a href="#字面量知识点补充" class="headerlink" title="字面量知识点补充"></a>字面量知识点补充</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types" target="_blank" rel="noopener">参考链接</a></p>
<p>字面量是由语法表达式定义的常量；或，通过由一定字词组成的语词表达式定义的常量。</p>
<ul>
<li>数组字面量(Array literals)</li>
<li>布尔字面量(Boolean literals)</li>
<li>浮点数字面量(Floating-point literals)</li>
<li>整数(Intergers)</li>
<li>对象字面量(Object literals)</li>
<li>RegExp literals</li>
<li>字符串字面量(String literals)</li>
</ul>
<p>数组字面值是一个封闭在方括号对([])中的包含有零个或多个表达式的列表，其中每个表达式代表数组的一个元素。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>布尔类型有两种字面量：true和false。</p>
<p>整数和浮点数他们数值本身就是其字面量。</p>
<p>对象字面值是封闭在花括号对({})中的一个对象的零个或多个”属性名-值”对的（元素）列表。</p>
<p>一个正则表达式是字符被斜线（译注：正斜杠“/”）围成的表达式。 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/ab+c/</span>;</span><br></pre></td></tr></table></figure>
<p>字符串字面量是由双引号（”）对或单引号（’）括起来的零个或多个字符</p>
<p>​                                                                   补充完毕</p>
<hr>
<p>使用下面类似Perl的语法，就可以创建一个正则表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern/</span>flags;</span><br></pre></td></tr></table></figure>
<p>其中模式部分是正则表达式，每一个正则表达式都可带有<u>一个或多个</u>标志（flags），用以表明正则表达式的行为。</p>
<p>如果指定，标志可以具有以下值的任意组合：</p>
<ul>
<li>g    全局搜索。也就是匹配目标字符串中所有可能的匹配项，而不是只进行第一次匹配。<br>   i    不区分大小写搜索。<br>   m    多行搜索。<br>   y    执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。</li>
<li>u      Unicode; 将模式视为Unicode序列点的序列</li>
</ul>
<p>RegExp 构造函数创建了一个正则表达式对象，用于将文本与一个模式匹配。</p>
<p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/</span>;</span><br></pre></td></tr></table></figure>
<p>另一种是使用RegExp构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>, <span class="string">'i'</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>
<p>两种方法的不同之处在于：<br>字面量，<u>在加载脚本后</u>，正则表达式字面值提供正则表达式的编译（又引擎编译）。当正则表达式保持不变时，使用此方法可获得更好的性能。</p>
<p>使用构造函数提供正则表达式的<u>运行时</u>编译。使用构造函数，当你知道正则表达式模式将会改变，或者你不知道模式，并从另一个来源，如用户输入。</p>
<h2 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h2><p>方括号用于查找某个范围内的字符：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_charset.asp" target="_blank" rel="noopener">[abc]</a></td>
<td>查找方括号之间的任何字符。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_charset_not.asp" target="_blank" rel="noopener">[^abc]</a></td>
<td>查找任何不在方括号之间的字符。</td>
</tr>
<tr>
<td>[0-9]</td>
<td>查找任何从 0 至 9 的数字。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>查找任何从小写 a 到小写 z 的字符。</td>
</tr>
<tr>
<td>[A-Z]</td>
<td>查找任何从大写 A 到大写 Z 的字符。</td>
</tr>
<tr>
<td>[A-z]</td>
<td>查找任何从大写 A 到小写 z 的字符。</td>
</tr>
<tr>
<td>[adgk]</td>
<td>查找给定集合内的任何字符。</td>
</tr>
<tr>
<td>[^adgk]</td>
<td>查找给定集合外的任何字符。</td>
</tr>
<tr>
<td>(red\</td>
<td>blue\</td>
<td>green)</td>
<td>查找任何指定的选项。</td>
</tr>
</tbody>
</table>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>元字符（Metacharacter）是拥有特殊含义的字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_dot.asp" target="_blank" rel="noopener">.</a></td>
<td>查找单个字符，除了换行和行结束符。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_wordchar.asp" target="_blank" rel="noopener">\w</a></td>
<td>查找单词字符。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_wordchar_non.asp" target="_blank" rel="noopener">\W</a></td>
<td>查找非单词字符。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_digit.asp" target="_blank" rel="noopener">\d</a></td>
<td>查找数字。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_digit_non.asp" target="_blank" rel="noopener">\D</a></td>
<td>查找非数字字符。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_whitespace.asp" target="_blank" rel="noopener">\s</a></td>
<td>查找空白字符。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_whitespace_non.asp" target="_blank" rel="noopener">\S</a></td>
<td>查找非空白字符。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_begin.asp" target="_blank" rel="noopener">\b</a></td>
<td>匹配单词边界。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_begin_not.asp" target="_blank" rel="noopener">\B</a></td>
<td>匹配非单词边界。</td>
</tr>
<tr>
<td>\0</td>
<td>查找 NUL 字符。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_newline.asp" target="_blank" rel="noopener">\n</a></td>
<td>查找换行符。</td>
</tr>
<tr>
<td>\f</td>
<td>查找换页符。</td>
</tr>
<tr>
<td>\r</td>
<td>查找回车符。</td>
</tr>
<tr>
<td>\t</td>
<td>查找制表符。</td>
</tr>
<tr>
<td>\v</td>
<td>查找垂直制表符。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_octal.asp" target="_blank" rel="noopener">\xxx</a></td>
<td>查找以八进制数 xxx 规定的字符。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_hex.asp" target="_blank" rel="noopener">\xdd</a></td>
<td>查找以十六进制数 dd 规定的字符。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_unicode_hex.asp" target="_blank" rel="noopener">\uxxxx</a></td>
<td>查找以十六进制数 xxxx 规定的 Unicode 字符。</td>
</tr>
</tbody>
</table>
<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><table>
<thead>
<tr>
<th>量词</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_onemore.asp" target="_blank" rel="noopener">n+</a></td>
<td>匹配任何包含至少一个 n 的字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_zeromore.asp" target="_blank" rel="noopener">n*</a></td>
<td>匹配任何包含零个或多个 n 的字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_zeroone.asp" target="_blank" rel="noopener">n?</a></td>
<td>匹配任何包含零个或一个 n 的字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_nx.asp" target="_blank" rel="noopener">n{X}</a></td>
<td>匹配包含 X 个 n 的序列的字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_nxy.asp" target="_blank" rel="noopener">n{X,Y}</a></td>
<td>匹配包含 X 至 Y 个 n 的序列的字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_nxcomma.asp" target="_blank" rel="noopener">n{X,}</a></td>
<td>匹配包含至少 X 个 n 的序列的字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_ndollar.asp" target="_blank" rel="noopener">n$</a></td>
<td>匹配任何结尾为 n 的字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_ncaret.asp" target="_blank" rel="noopener">^n</a></td>
<td>匹配任何开头为 n 的字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_nfollow.asp" target="_blank" rel="noopener">?=n</a></td>
<td>匹配任何其后紧接指定字符串 n 的字符串。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jsref/jsref_regexp_nfollow_not.asp" target="_blank" rel="noopener">?!n</a></td>
<td>匹配任何其后没有紧接指定字符串 n 的字符串。</td>
</tr>
</tbody>
</table>
<p><a href="https://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">初步熟悉正则</a></p>
<h2 id="5-4-1-RegExp-实例属性"><a href="#5-4-1-RegExp-实例属性" class="headerlink" title="5.4.1 RegExp 实例属性"></a>5.4.1 RegExp 实例属性</h2><ul>
<li>ignoreCase：返回一个布尔值，表示是否设置了i标志。</li>
<li>global：返回一个布尔值，表示是否设置了g标志。</li>
<li>RegExp.prototype.multiline：返回一个布尔值，表示是否设置了m标志。以上三个属性仅为修饰。</li>
<li>lastIndex：返回一个数值，表示下一次开始搜索的位置，起始为0，该属性可读写。</li>
<li>source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>
</ul>
<p>然而并没多大用处，因为这些信息全部包含在模式声明中，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/abc/igm</span>;</span><br><span class="line"></span><br><span class="line">r.ignoreCase <span class="comment">// true</span></span><br><span class="line">r.global <span class="comment">// true</span></span><br><span class="line">r.multiline <span class="comment">// true</span></span><br><span class="line">r.lastIndex <span class="comment">// 0</span></span><br><span class="line">r.source <span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure>
<h2 id="5-4-2-实例方法"><a href="#5-4-2-实例方法" class="headerlink" title="5.4.2  实例方法"></a>5.4.2  实例方法</h2><h3 id="exec（）"><a href="#exec（）" class="headerlink" title="exec（）"></a>exec（）</h3><p>该方法是专为捕获数组而设立的。<code>exec()</code>接受一个参数，即要应用模式的字符串，然后返回第一个包含匹配项信息的数组，如果没有找到匹配，则返回 null。返回的数组虽然是Array实例。但包含两个额外属性：index和input。其中index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串，在数组中，第一项是整个模式匹配的字符串，其他项是与模式中的捕获匹配的字符串（如果没有捕获组，则该数组只包含一项）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line">                   </span><br><span class="line"><span class="keyword">var</span> matches = pattern.exec(text);</span><br><span class="line">matches；<span class="comment">//["mom and dad and baby", " and dad and baby", " and baby", index: 0, input: "mom and dad and baby", groups: undefined]</span></span><br><span class="line">alert(matches.index);    <span class="comment">//0</span></span><br><span class="line">alert(matches.input);    <span class="comment">//"mom and dad and baby"</span></span><br><span class="line">alert(matches[<span class="number">0</span>]);       <span class="comment">//"mom and dad and baby"</span></span><br><span class="line">alert(matches[<span class="number">1</span>]);       <span class="comment">//" and dad and baby"</span></span><br><span class="line">alert(matches[<span class="number">2</span>]);       <span class="comment">//" and baby"</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，使用 exec() 方法，即使在正则表达式中设置了全局模式（g 标志），它也只会返回字符串中的第一个匹配项。区别在于，不设置全局模式的情况下，在同一个字符串上调用多次 exec() 将始终返回第一个匹配项的信息。而设置了全局模式后，在同一个字符串上调用多次 exec() 方法将会在之前查找完的位置继续向下查找新的匹配项。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;        </span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/.at/</span>;  <span class="comment">//'.'匹配除换行符之外的任何单个字符。</span></span><br><span class="line">                   </span><br><span class="line"><span class="keyword">var</span> matches = pattern1.exec(text);   </span><br><span class="line">matches; <span class="comment">//["cat", index: 0, input: "cat, bat, sat, fat", groups: undefined]</span></span><br><span class="line">alert(matches.index);        <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>]);           <span class="comment">//cat</span></span><br><span class="line">alert(pattern1.lastIndex);   <span class="comment">//0</span></span><br><span class="line">                   </span><br><span class="line">matches = pattern1.exec(text);        </span><br><span class="line">alert(matches.index);        <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>]);           <span class="comment">//cat</span></span><br><span class="line">alert(pattern1.lastIndex);   <span class="comment">//0</span></span><br><span class="line">                   </span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/.at/g</span>;</span><br><span class="line">                   </span><br><span class="line"><span class="keyword">var</span> matches = pattern2.exec(text);    </span><br><span class="line">alert(matches.index);        <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>]);           <span class="comment">//cat</span></span><br><span class="line">alert(pattern2.lastIndex);   <span class="comment">//0</span></span><br><span class="line">                   </span><br><span class="line">matches = pattern2.exec(text);        </span><br><span class="line">alert(matches.index);</span><br><span class="line"><span class="comment">//5  "cat, ",bat在字符串的起始位index是6，而输出是5，所以index输出的应是匹配项起始位的前一位，而依次规则第一位的index应该是-1，实际是0，依次此规则对于第一位不适合。</span></span><br><span class="line">alert(matches[<span class="number">0</span>]);           <span class="comment">//bat</span></span><br><span class="line">alert(pattern2.lastIndex);   <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<h3 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h3><p>它接受一个字符串参数，在模式与该参数匹配的情况下返回true；否则返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容时，使用这个非常方便，因此test方法经常被用在if语句中，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"000-00-0000"</span>;        </span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</span><br><span class="line">                   </span><br><span class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</span><br><span class="line">    alert(<span class="string">"The pattern was matched."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持正则表达式的 String 对象的方法<br>方法    描述<br>search    检索与正则表达式相匹配的值。<br>match    找到一个或多个正则表达式的匹配。<br>replace    替换与正则表达式匹配的子串。<br>split    把字符串分割为字符串数组。</p>
<h2 id="5-4-3-RegExp-构造函数属性"><a href="#5-4-3-RegExp-构造函数属性" class="headerlink" title="5.4.3 RegExp 构造函数属性"></a>5.4.3 RegExp 构造函数属性</h2><ul>
<li>input (简写为$_) 最近一次要匹配的字符串。</li>
<li>lastMatch(简写$&amp;) 最近一次的匹配项</li>
<li>lastParen(简写$+) 最近一次匹配的捕获组。</li>
<li>leftContext(简写$`) input字符串中lastMatch之前的文本</li>
<li>rightContext(简写$’) input字符串中lastMatch之后的文本</li>
<li>multiline(简写$*) 布尔值，表示是否所有表达式都使用多行模式。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text =<span class="string">"you are in haorooms 博客，看文章呢"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern =<span class="regexp">/(.)aorooms/g</span>;</span><br><span class="line"><span class="keyword">if</span>(pattern.test(text))&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$_); <span class="comment">//you are in haorooms 博客，看文章呢</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$`"</span>]);<span class="comment">//you are in</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$'"</span>]);<span class="comment">//博客，看文章呢</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$&amp;"</span>]);<span class="comment">//haorooms</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$+"</span>]);<span class="comment">//h</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$*"</span>]);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上面几个属性之外还有 （RegExp.$1,RegExp.$2,RegExp.$3,RegExp.$4,RegExp.$5,RegExp.$6,RegExp.$7,RegExp.$8,RegExp.$9）,一共有9个。用来存储匹配的捕获组。在调用<code>exec()</code>或<code>test()</code>方法时，这些属性会被自动填充。其实，说简单的，就是可以获得（）括号内匹配的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text =<span class="string">"you are in haorooms 博客，看文章呢"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern =<span class="regexp">/(.)ao(..)om(.)/g</span>;</span><br><span class="line"><span class="keyword">if</span>(pattern.test(text))&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//h</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>);<span class="comment">//ro</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">3</span>);<span class="comment">//s</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-5-Function-类型"><a href="#5-5-Function-类型" class="headerlink" title="5.5 Function 类型"></a>5.5 Function 类型</h1><p>Function（函数）类型实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具备属性和方法，由于函数是对象，因此函数名实际上也是一个指向函数对象的指针。参考4.1章节。没有函数重载的概念。</p>
<p>函数定义：</p>
<ul>
<li>通过函数声明</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1 ,numb2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过函数表达式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">num1 ,numb2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>两者区别有两点：</p>
<ul>
<li>解析器在向执行环境中加载数据时，解析器会先读取函数声明，并使其在执行任何代码之前可用（可以访问）；对于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。函数提升，参考3.3.1变量提升。例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">函数声明</span><br><span class="line">alert (sum (<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1,numb2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1,numb2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line">alert (sum (<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">函数表达式</span><br><span class="line">alert (sum (<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">num1 ,numb2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line"><span class="keyword">var</span> sum ;</span><br><span class="line">alert (sum (<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">num1 ,numb2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>js引擎会把函数声明提升到顶部。而对于通过函数表达式定义的函数则会抛出错误。</p>
<p>通过函数表达式定义的函数，形式看起来好像常规的变量赋值语句，即创建一个函数并将他赋值给变量functionName。这种情况下创建的函数叫匿名函数。因为function关键字后面没有标识符，匿名函数的name属性是空字符串，也就是没有。</p>
<ul>
<li></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> sayHello;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> (sayHey));<span class="comment">//=&gt;function    </span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> (sayHo));<span class="comment">//=&gt;undefined</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">function</span> <span class="title">sayHey</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">"sayHey"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           sayHello = <span class="function"><span class="keyword">function</span> <span class="title">sayHo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">"sayHello"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">sayHey</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"sayHey2"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      sayHello = <span class="function"><span class="keyword">function</span> <span class="title">sayHo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"sayHello2"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">sayHey();<span class="comment">// =&gt; sayHey2  //2019 5 23测，谷歌和火狐都返回sayHey，360极速返回sayHey2</span></span><br><span class="line">sayHello();<span class="comment">// =&gt; sayHello</span></span><br></pre></td></tr></table></figure>
<p>分析：sayHey是用函数声明创建的，在JS解析时JS编译器将函数定义进行了函数提升，也就是说，在解析JS代码的时候，JS编译器（条件判断不形成新的作用域，两个sayHey函数定义都被提升到条件判断之外）检测到作用域内有两个同名的sayHey定义，第一个定义先被提升，第二个定义接着被提升（第二个定义在第一个定义之下），第二个定义覆盖了第一个sayHey定义，所以sayHey（）输出sayHey2；而sayHello是用函数表达式创建的，其表达式的内容是在JS运行时（不是解析时）才能确定（这里条件判断就起到作用了），所以sayHello表达式执行了第一个函数定义并赋值，则sayHello（）输出sayHello。</p>
<h2 id="5-5-1-作为值的函数"><a href="#5-5-1-作为值的函数" class="headerlink" title="5.5.1 作为值的函数"></a>5.5.1 作为值的函数</h2><p>因为ECMAScriopt中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不久可以像传递参数一样把一个函数传递个另一个函数，而且可以将一个函数作为另一个函数的结果返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someFunction(someArgument);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ad10</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result1 =callSomeFunction(add10,<span class="number">10</span>);</span><br><span class="line">alert(result1); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result2 = callSomeFunction(getGreeting, <span class="string">"Icey"</span>);</span><br><span class="line">alert(result2); <span class="comment">//"Hello Icey"</span></span><br></pre></td></tr></table></figure>
<p>要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。</p>
<p>从函数中返回另一个函数的应用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照某个对象的属性进行排序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [&#123;<span class="attr">name</span>:<span class="string">"Icey"</span>, <span class="attr">age</span>:<span class="number">25</span>&#125;, &#123;<span class="attr">name</span>:<span class="string">"Root"</span>, <span class="attr">age</span>:<span class="number">24</span>&#125;];</span><br><span class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>));</span><br><span class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//"Icey"</span></span><br><span class="line"></span><br><span class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));</span><br><span class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//"Root"</span></span><br></pre></td></tr></table></figure>
<p>sort()方法参考。5.2.5重排序方法。</p>
<h2 id="5-5-2-函数内部属性-arguments和this"><a href="#5-5-2-函数内部属性-arguments和this" class="headerlink" title="5.5.2 函数内部属性(arguments和this)"></a>5.5.2 函数内部属性(arguments和this)</h2><p>在函数内部，有两个特殊的对象：arguments和this。其中，arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。请看下面这个非常经典的阶乘函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;	</span><br><span class="line">	<span class="keyword">if</span>(num &lt;= <span class="number">1</span>)&#123;	</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> num * factorial(num<span class="number">-1</span>);	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;	</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trueFactorial = factorial;</span><br><span class="line"></span><br><span class="line">factorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;&#125;;</span><br><span class="line">	</span><br><span class="line">alert(trueFactorial(<span class="number">5</span>)); <span class="comment">//120</span></span><br><span class="line">alert(factorial(<span class="number">5</span>)); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>在此，变量trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回0的函数赋值给factorial变量。如果像原来的factorial()那样不使用arguments.callee，调用trueFactorial()就会返回0。可是，在解除了函数体内的代码与函数名的耦合状态之后，trueFactorial()仍然能够正常地计算阶乘，至于factorial()，它现在只是一个返回0的函数。函数内部的另一个特殊对象是this，其行为与java和C#中的this大致类似。换句话说，this引用的是函数执行的环境对象——或者也可以说是this值(当在网页的全局作用域中调用函数时，this对象引用的就是window)。来看下面的例子。</p>
<p><strong>在闭包中使用this对象也可能会导致一些问题。this的对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的的方法调用时，this等于那个对象。</strong>7.2章闭包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span> : <span class="string">"blue"</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">//	red</span></span><br><span class="line">o.sayColor = sayColor; </span><br><span class="line">o.sayColor(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
<p>上面这个函数sayColor()是在全局作用域中定义的，this对象引用了window对象。由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。当在全局作用域中调用sayColor()时，this引用的是全局对象window，换句话说，对this.color求值会转换成对window.color求值，于是结果就返回了”red”。而当把这个函数赋给对象o并调用o.sayColor()时，this引用的是对象o，因此对this.color求值会转换成对o.color求值，结果就返回了”blue”。</p>
<p>请读者一定要牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的sayColor()函数与o.sayColor()指向的仍然是同一个函数。</p>
<h2 id="5-5-3-函数属性和方法"><a href="#5-5-3-函数属性和方法" class="headerlink" title="5.5.3 函数属性和方法"></a>5.5.3 函数属性和方法</h2><p>每个函数都包含两个属性：length 和 prototype</p>
<p>length:当前函数希望接受的命名参数的个数</p>
<p>prototype：是保存他们所有实例方法的真正所在</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>) </span>&#123;  </span><br><span class="line">	alert(name);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> num1 + num2;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    alert(<span class="string">"hi"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">alert(sayName.length);<span class="comment">//1 参数个数一个  </span></span><br><span class="line">alert(sum.length);<span class="comment">//2 参数个数2个  </span></span><br><span class="line">alert(sayHi.length);<span class="comment">//0 没有参数</span></span><br></pre></td></tr></table></figure>
<p>每个函数都包含两个非继承而来的方法：apply() 和 call()</p>
<p>这两个方法都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。（通俗的说就是在一个函数里通过这两个方法引用另一个函数）</p>
<p>首先 apply() 接受两个参数：一个是函数运行的作用域，另一个参数数组（可以是数组实例也可以是 arguments 对象） </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">return</span> num1 + num2;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);<span class="comment">//传入arguments对象  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]);  </span><br><span class="line">&#125;  </span><br><span class="line">    alert(callSum1(<span class="number">10</span>, <span class="number">10</span>));<span class="comment">//20  </span></span><br><span class="line">    alert(callSum2(<span class="number">10</span>, <span class="number">10</span>));<span class="comment">//20 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果没有运用apply</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> sum;<span class="comment">//传入arguments对象  </span></span><br><span class="line">&#125;  </span><br><span class="line">  alert(callSum1(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">//    function sum(num1, num2) &#123; </span></span><br><span class="line">	<span class="keyword">return</span> num1 + num2;  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>其次，call 方法第一个参数没有变化，变化的是其余的参数都是传递参数，传递给函数的参数需要逐个列举出来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> num1 + num2;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);  </span><br><span class="line">&#125;  </span><br><span class="line">alert(callSum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>至于使用哪个方法更方便，完全取决于你的意愿。如果没有参数，用哪个都一样。</p>
<p>为了更好地理解，再举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">这个函数可能有点难理解或者小错误，引入这个例子主要为了立即这两个方法</span><br><span class="line">function animal(name,food) &#123;</span><br><span class="line">   this.name = name,</span><br><span class="line">    this.food = food,</span><br><span class="line">   this.say = function() &#123;</span><br><span class="line">        console.log(name +&quot; likes &quot; + this.food + &apos;.&apos;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function rabbit(name,food) &#123;</span><br><span class="line">   animal.call(this,name,food);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Judy = new rabbit(&apos;Judy&apos;,&apos;carrot&apos;);</span><br><span class="line"></span><br><span class="line">Judy.say();// &gt;&gt;&gt; Judy likes carrot.</span><br><span class="line"></span><br><span class="line">可以看出，我们声明了一个叫Judy的对象，我们并没有在rabbit对象里添加任何属性和方法，但是我们使用call()继承了原本属于animal的属性和方法。就可以做到animal函数所有能做到的事情。</span><br><span class="line">本例引用链接：https://segmentfault.com/a/1190000004581945</span><br></pre></td></tr></table></figure>
<p>但是，apply 和 call 方法的出现绝对不是只是为了怎样去传递参数。</p>
<p>它们真正的用武之地在于扩充函数赖以运行的作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;  </span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>: <span class="string">"blue"</span>&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    alert(<span class="keyword">this</span>.color);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">sayColor();<span class="comment">//red  </span></span><br><span class="line"></span><br><span class="line">sayColor.call(<span class="keyword">this</span>);<span class="comment">//red  </span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>);<span class="comment">//red  </span></span><br><span class="line">ayColor.call(o);<span class="comment">//blue</span></span><br></pre></td></tr></table></figure>
<p>使用 apply 和 call 来扩充作用域的最大的好处就是不需要与方法有任何的耦合关系。</p>
<p>ECMAScript5 还定义了一个方法：bind()。这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind 函数的值 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>: <span class="string">"blue"</span>&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">	alert(<span class="keyword">this</span>.color);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFun = sayColor.bind(o);  </span><br><span class="line">bindFun();<span class="comment">//blue</span></span><br></pre></td></tr></table></figure>
<h1 id="5-6-基本包装类型"><a href="#5-6-基本包装类型" class="headerlink" title="5.6 基本包装类型"></a>5.6 基本包装类型</h1><p>为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型：Boolean、Number 和String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值得时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1=<span class="string">"some text"</span>; </span><br><span class="line"><span class="keyword">var</span> s2=s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值，而下一行代码调用了 s1的 substring() 方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要·从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。</p>
<ol>
<li><ul>
<li>创建 String 类型的一个实例；</li>
</ul>
</li>
<li><ul>
<li>在实例上调用指定的方法；</li>
</ul>
</li>
<li><ul>
<li>销毁这个实例</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>); </span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>上面三个步骤也分别使用于Boolean和Number类型对应的布尔值和数字值。</p>
<p>引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能再运行时为基本类型值添加属性和方法。如下面例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1=<span class="string">"some text"</span>  </span><br><span class="line">s1.color=<span class="string">"red"</span>;  </span><br><span class="line">alert(s1.color);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>当然，可以显示的地调用 Boolean、Number 和 String 来创建基本包装类型的对象。不过，应该在绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本包装类型还是引用基本包装类型的值。对基本包装类型的实例调用 typeof 会返回 “object”，而且所有基本包装类型的对象都会被转换为布尔值 true。</p>
<p>Object 构造函数也会像工厂方法一样，根据传入值得类型返回相应基本包装类型的实例。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>);  </span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>把字符串传给 Object 构造函数，就会创建 String 的实例；而传入数值参数会得到Number 的实例，传入布尔值参数就会得到 Boolean 的实例。</p>
<p>要注意的是，使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value=<span class="string">"25"</span>;  </span><br><span class="line"><span class="keyword">var</span> number=<span class="built_in">Number</span>(value); <span class="comment">//转型函数  </span></span><br><span class="line">alert(<span class="keyword">typeof</span> number); <span class="comment">//"number"  </span></span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">//构造函数  </span></span><br><span class="line">alert(<span class="keyword">typeof</span> obj); <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，变量 number 中保存的是基本类型的值 25，而变量 obj 中保存的是Number 的实例。</p>
<p><strong>5.6.1,5.6.2,5.6.3这三小节，<a href="http://www.w3school.com.cn/js/pro_js_referencetypes.asp" target="_blank" rel="noopener">请参考位W3c。ECMAScript 引用类型</a></strong></p>
<h2 id="5-6-1-Boolean-类型"><a href="#5-6-1-Boolean-类型" class="headerlink" title="5.6.1 Boolean 类型"></a>5.6.1 Boolean 类型</h2><p>Boolean 对象将覆盖 Object 对象的 ValueOf() 方法，返回原始值，即 true 和 false。ToString() 方法也会被覆盖，返回字符串 “true” 或 “false”</p>
<h2 id="5-6-2-Number-类型"><a href="#5-6-2-Number-类型" class="headerlink" title="5.6.2 Number 类型"></a>5.6.2 Number 类型</h2><p>Number是与数字对应的引用类型。要创建Number对象，可以在调用Number构造函数时，向其中传递相应的数值。例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span> (<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>与Boolean类型一样，Number类型也重写了<code>valueOf()</code>,<code>toLocaleString()</code>和<code>toString()</code>方法。重写后<code>valueOf()</code>返回对象表示的基本类型的值。另外两个方法返回字符串形式的数值。</p>
<p>补充：<code>toString()</code>方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式，例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="toFixed-方法"><a href="#toFixed-方法" class="headerlink" title="toFixed() 方法"></a>toFixed() 方法</h3><p>toFixed() 方法返回的是具有指定位数小数的数字的字符串表示。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toFixed(<span class="number">2</span>));  <span class="comment">//输出 "68.00"</span></span><br></pre></td></tr></table></figure>
<p>在这里，toFixed() 方法的参数是 2，说明应该显示两位小数。该方法返回 “68.00”，空的字符串位由 0 来补充。对于处理货币的应用程序，该方法非常有用。toFixed() 方法能表示具有 0 到 20 位小数的数字，超过这个范围的值会引发错误。</p>
<h3 id="toExponential-方法"><a href="#toExponential-方法" class="headerlink" title="toExponential() 方法"></a>toExponential() 方法</h3><p>与格式化数字相关的另一个方法是 toExponential()，它返回的是用科学计数法表示的数字的字符串形式。</p>
<p>与 toFixed() 方法相似，toExponential() 方法也有一个参数，指定要输出的小数的位数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toExponential(<span class="number">1</span>));  <span class="comment">//输出 "6.8e+1"</span></span><br></pre></td></tr></table></figure>
<p>这段代码的结果是 “6.8e+1”，前面解释过，它表示 6.8x101。问题是，如果不知道要用哪种形式（预定形式或指数形式）表示数字怎么办？可以用 toPrecision() 方法。</p>
<h3 id="toPrecision-方法"><a href="#toPrecision-方法" class="headerlink" title="toPrecision() 方法"></a>toPrecision() 方法</h3><p>toPrecision() 方法根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。例如，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toPrecision(<span class="number">1</span>));  <span class="comment">//输出 "7e+1"</span></span><br></pre></td></tr></table></figure>
<p>这段代码的任务是用一位数字表示数字 68，结果为 “7e+1”，以另外的形式表示即 70。的确，toPrecision() 方法会对数进行舍入。不过，如果用 2 位数字表示 68，就容易多了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toPrecision(<span class="number">2</span>));  <span class="comment">//输出 "68"</span></span><br></pre></td></tr></table></figure>
<p>当然，输出的是 “68”，因为这正是该数的准确表示。不过，如果指定的位数多于需要的位数又如何呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toPrecision(<span class="number">3</span>));  <span class="comment">//输出 "68.0"</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，toPrecision(3) 等价于 toFixed(1)，输出的是 “68.0”。</p>
<p>toFixed()、toExponential() 和 toPrecision() 方法都会进行舍入操作，以便用正确的小数位数正确地表示一个数</p>
<h2 id="5-6-3-String-类型"><a href="#5-6-3-String-类型" class="headerlink" title="5.6.3  String 类型"></a>5.6.3  String 类型</h2><p>String 类型是字符串的对象包装类型。创建如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>
<p>String 对象的 valueOf() 方法和 toString() 方法都会返回 String 类型的原始值。</p>
<p><strong>length 属性</strong></p>
<p>String 对象具有属性 length，它是字符串中的字符个数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello world"</span>);</span><br><span class="line">alert(oStringObject.length);	<span class="comment">//输出 "11"</span></span><br></pre></td></tr></table></figure>
<h3 id="1-字符方法"><a href="#1-字符方法" class="headerlink" title="1.字符方法"></a>1.字符方法</h3><p>两个方法 charAt() 和 charCodeAt() 访问的是字符串中的单个字符。这两个方法都有一个参数，即要操作的字符的位置。</p>
<p><strong>charAt() 方法</strong>返回的是包含指定位置处的字符的字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello world"</span>);</span><br><span class="line">alert(oStringObject.charAt(<span class="number">1</span>));	<span class="comment">//输出 "e"</span></span><br></pre></td></tr></table></figure>
<p>如果想得到的不是字符，而是字符代码，那么可以调用 <strong>charCodeAt()</strong> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello world"</span>);</span><br><span class="line">alert(oStringObject.charCodeAt(<span class="number">1</span>));	<span class="comment">//输出 "101"</span></span><br></pre></td></tr></table></figure>
<h3 id="2-字符串操作方法"><a href="#2-字符串操作方法" class="headerlink" title="2.字符串操作方法"></a>2.字符串操作方法</h3><p><a href="http://riny.net/2012/the-summary-of-javascript-string/" target="_blank" rel="noopener">参考javascript中字符串常用操作总结</a></p>
<h3 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat() 方法"></a>concat() 方法</h3><p> 用于把一个或多个字符串连接到 String 对象的原始值上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello "</span>); </span><br><span class="line"><span class="keyword">var</span> sResult = oStringObject.concat(<span class="string">"world"</span>); </span><br><span class="line">alert(sResult); <span class="comment">//输出 "hello world" </span></span><br><span class="line">alert(oStringObject); <span class="comment">//输出 "hello "</span></span><br></pre></td></tr></table></figure>
<p>较常见的是用加号（+）连接字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var oStringObject = new String(&quot;hello &quot;); </span><br><span class="line">var sResult = oStringObject + &quot;world&quot;; </span><br><span class="line">alert(sResult); //输出 &quot;hello world&quot; </span><br><span class="line">alert(oStringObject); //输出 &quot;hello &quot;</span><br></pre></td></tr></table></figure>
<h3 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.substring(start,end)</span><br></pre></td></tr></table></figure>
<p>substring()是最常用到的字符串截取方法，它可以接收两个参数(参数不能为负值)，分别是要截取的开始位置和结束位置，它将返回一个新的字符串，其内容是从start处到end-1处的所有字符。若结束参数(end)省略，则表示从start位置一直截取到最后。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abcdefg'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">1</span>, <span class="number">4</span>));    <span class="comment">//返回bcd</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">1</span>));    <span class="comment">//返回bcdefg</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">-1</span>));    <span class="comment">//返回abcdefg，传入负值时会视为0</span></span><br></pre></td></tr></table></figure>
<h3 id="slice-1"><a href="#slice-1" class="headerlink" title="slice()"></a>slice()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.slice(start,end)</span><br></pre></td></tr></table></figure>
<p>slice()方法与substring()方法非常类似，它传入的两个参数也分别对应着开始位置和结束位置。而区别在于，slice()中的参数可以为负值，如果参数是负数，则将负值与字符串长度相加。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abcdefg'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">1</span>, <span class="number">4</span>));    <span class="comment">//返回bcd</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">-3</span>, <span class="number">-1</span>));    <span class="comment">//返回ef</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">1</span>, <span class="number">-1</span>));    <span class="comment">//返回bcdef</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">-1</span>, <span class="number">-3</span>));    <span class="comment">//返回空字符串，若传入的参数有问题，则返回空</span></span><br></pre></td></tr></table></figure>
<p>substr()</p>
<pre><code>stringObject.substr(start,length)
</code></pre><p>substr()方法可在字符串中抽取从start下标开始的指定数目的字符。其返回值为一个字符串，包含从 stringObject的start（包括start所指的字符）处开始的length个字符。如果没有指定 length，那么返回的字符串包含从start到stringObject的结尾的字符。另外如果start为负数，第一个参数加上字符串的长度，第二个负值转换为0.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abcdefg'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">1</span>, <span class="number">3</span>))    <span class="comment">//返回bcd</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">2</span>))    <span class="comment">//返回cdefg</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">-2</span>, <span class="number">4</span>))    <span class="comment">//返回fg，目标长度较大的话，以实际截取的长度为准</span></span><br></pre></td></tr></table></figure>
<h3 id="3-字符串位置的方法"><a href="#3-字符串位置的方法" class="headerlink" title="3.字符串位置的方法"></a>3.字符串位置的方法</h3><p><code>indexOf()</code>与<code>lastIndexOf()</code>参考5.2.7 位置方法。</p>
<p>在使用第二个参数的情况下，可以通过循环调用这两个方法来找到所有匹配的子字符串，例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">'lorem ipsum dolor sit amet, consectetur adipisicing elit '</span>;</span><br><span class="line"><span class="keyword">var</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span> ();</span><br><span class="line"><span class="keyword">var</span> pos = stringValue.index(<span class="string">'e'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pos &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">    position.push (pos);</span><br><span class="line">    pos = stringValue.index (<span class="string">'e'</span>, pos+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">alert (positions);<span class="comment">//'3，24，32，35，52'</span></span><br></pre></td></tr></table></figure>
<h3 id="4-trim-方法"><a href="#4-trim-方法" class="headerlink" title="4.trim() 方法"></a>4.trim() 方法</h3><p>从字符串中移除前导空格、尾随空格和行终止符。 rim() 方法并不影响原字符串本身，它返回的是一个新的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> stringObj.trim()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> orig = <span class="string">'   foo  '</span>;</span><br><span class="line"><span class="built_in">console</span>.log(orig.trim()); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure>
<h3 id="5-字符串大小写转换方法"><a href="#5-字符串大小写转换方法" class="headerlink" title="5.字符串大小写转换方法"></a>5.字符串大小写转换方法</h3><ul>
<li>toLowerCase()</li>
<li>toLocaleLowerCase()</li>
<li>toUpperCase()</li>
<li>toLocaleUpperCase()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Hello World"</span>);</span><br><span class="line">alert(oStringObject.toLocaleUpperCase());	<span class="comment">//输出 "HELLO WORLD"</span></span><br></pre></td></tr></table></figure>
<h3 id="6-字符串的模式匹配方法"><a href="#6-字符串的模式匹配方法" class="headerlink" title="6.字符串的模式匹配方法"></a>6.字符串的模式匹配方法</h3><h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stringObject.match(substr)</span><br><span class="line">stringObject.match(regexp)</span><br></pre></td></tr></table></figure>
<p>match()方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p>
<p>如果参数中传入的是子字符串或是没有进行全局匹配的正则表达式，那么match()方法会从开始位置执行一次匹配，如果没有匹配到结果，则返回null。否则则会返回一个数组，该数组的第0个元素存放的是匹配文本，除此之外，返回的数组还含有两个对象属性index和input，分别表示匹配文本的起始字符索引和stringObject 的引用(即原字符串)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'1a2b3c4d5e'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="string">'h'</span>));    <span class="comment">//返回null</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="string">'b'</span>));    <span class="comment">//返回["b", index: 3, input: "1a2b3c4d5e"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/b/</span>));    <span class="comment">//返回["b", index: 3, input: "1a2b3c4d5e"]</span></span><br></pre></td></tr></table></figure>
<p>如果参数传入的是具有全局匹配的正则表达式，那么match()从开始位置进行多次匹配，直到最后。如果没有匹配到结果，则返回null。否则则会返回一个数组，数组中存放所有符合要求的子字符串，并且没有index和input属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'1a2b3c4d5e'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/h/g</span>));    <span class="comment">//返回null</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/\d/g</span>));    <span class="comment">//返回["1", "2", "3", "4", "5"]</span></span><br></pre></td></tr></table></figure>
<h3 id="search"><a href="#search" class="headerlink" title="search ()"></a>search ()</h3><pre><code>stringObject.search(substr)
stringObject.search(regexp)
</code></pre><p>search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。它会返回第一个匹配的子字符串的起始位置，如果没有匹配的，则返回-1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abcDEF'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="string">'c'</span>));    <span class="comment">//返回2</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="string">'d'</span>));    <span class="comment">//返回-1</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/d/i</span>));    <span class="comment">//返回3</span></span><br></pre></td></tr></table></figure>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><pre><code>stringObject.replace(regexp/substr,replacement)
</code></pre><p>replace()方法用来进行字符串替换操作，它可以接收两个参数，前者为被替换的子字符串（可以是正则），后者为用来替换的文本。</p>
<p>如果第一个参数传入的是子字符串或是没有进行全局匹配的正则表达式，那么replace()方法将只进行一次替换（即替换最前面的），返回经过一次替换后的结果字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abcdeabcde'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="string">'a'</span>, <span class="string">'A'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="regexp">/a/</span>, <span class="string">'A'</span>));</span><br></pre></td></tr></table></figure>
<p>如果第一个参数传入的全局匹配的正则表达式，那么replace()将会对符合条件的子字符串进行多次替换，最后返回经过多次替换的结果字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abcdeabcdeABCDE'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="regexp">/a/g</span>, <span class="string">'A'</span>));    <span class="comment">//返回AbcdeAbcdeABCDE</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="regexp">/a/gi</span>, <span class="string">'$返回'</span>));    <span class="comment">//返回$bcde$bcde$BCDE</span></span><br></pre></td></tr></table></figure>
<p>replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>替换文本</th>
</tr>
</thead>
<tbody>
<tr>
<td>$1、$2、…、$99</td>
<td>与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。</td>
</tr>
<tr>
<td>$&amp;</td>
<td>与 regexp 相匹配的子串。</td>
</tr>
<tr>
<td>$`</td>
<td>位于匹配子串左侧的文本。</td>
</tr>
<tr>
<td>$’</td>
<td>位于匹配子串右侧的文本。</td>
</tr>
<tr>
<td>$$</td>
<td>直接量符号。</td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'www.denpe.com'</span>;</span><br><span class="line"><span class="keyword">var</span> searchStr = <span class="string">'denpe'</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.replace(searchStr, <span class="string">"$$ - $` - $&amp; - $'"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);   <span class="comment">// www.$ - www. - denpe - .com.com</span></span><br></pre></td></tr></table></figure>
<p>从上面例子可看到 denpe 被替换成了 $ - www. - denpe - .com。</p>
<table>
<thead>
<tr>
<th>参数search</th>
<th>表示$</th>
<th>匹配子串左边内容</th>
<th>匹配到的子串</th>
<th>匹配子串右边内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>变量名</td>
<td>$$</td>
<td>$`</td>
<td>$&amp;</td>
<td>$’</td>
</tr>
<tr>
<td>代表的值</td>
<td>$</td>
<td>www.</td>
<td>denpe</td>
<td>.com</td>
</tr>
</tbody>
</table>
<p><a href="https://www.denpe.com/jsbook/javascript-string-replace.html" target="_blank" rel="noopener">JavaScript String.prototype.replace() 方法详解</a></p>
<h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><pre><code>stringObject.split(separator,howmany)
</code></pre><p>split()方法用于把一个字符串分割成字符串数组。第一个参数separator表示分割位置(参考符)，第二个参数howmany表示返回数组的允许最大长度(一般情况下不设置)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'a|b|c|d|e'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">'|'</span>));    <span class="comment">//返回["a", "b", "c", "d", "e"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">'|'</span>, <span class="number">3</span>));    <span class="comment">//返回["a", "b", "c"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">''</span>));    <span class="comment">//返回["a", "|", "b", "|", "c", "|", "d", "|", "e"]</span></span><br></pre></td></tr></table></figure>
<p>也可以用正则来进行分割</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'a1b2c3d4e'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="regexp">/\d/</span>)); <span class="comment">//返回["a", "b", "c", "d", "e"]</span></span><br></pre></td></tr></table></figure>
<h3 id="7-localeCompare"><a href="#7-localeCompare" class="headerlink" title="7.localeCompare()"></a>7.localeCompare()</h3><p>用本地特定的顺序来比较两个字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.localeCompare(target)</span><br></pre></td></tr></table></figure>
<p>说明比较结果的数字。如果 stringObject 小于 target(字符串在字母表中的顺序排在字符串参数之前)，则 localeCompare() 返回小于 0 的数。如果 stringObject 大于 target，则该方法返回大于 0 的数。如果两个字符串相等，或根据本地排序规则没有区别，该方法返回 0</p>
<h3 id="8-fromCharCode"><a href="#8-fromCharCode" class="headerlink" title="8.fromCharCode()"></a>8.fromCharCode()</h3><p>String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode() <span class="comment">// ""</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">97</span>) <span class="comment">// "a"</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>)</span><br><span class="line"><span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，String.fromCharCode方法的参数为空，就返回空字符串；否则，返回参数对应的 Unicode 字符串。</p>
<h1 id="5-7-单体内置对象"><a href="#5-7-单体内置对象" class="headerlink" title="5.7 单体内置对象"></a>5.7 单体内置对象</h1><p>ECMA-262定义内置对象是：由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。例如Object，Array和String，Global和Math。</p>
<h2 id="5-7-1Global-对象"><a href="#5-7-1Global-对象" class="headerlink" title="5.7.1Global 对象"></a>5.7.1Global 对象</h2><p>事实上，没有全局对象或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性，例如isNaN()、isFinite()、parseInt()以及parseFloat()。除了这些，Global对象还有一些方法。</p>
<h2 id="1-URI编码方法"><a href="#1-URI编码方法" class="headerlink" title="1.URI编码方法"></a>1.URI编码方法</h2><p>Global对象的<code>encodeURI()</code>和<code>encodeURIComponent()</code>方法可以对URI进行编码，以便发送给浏览器，让浏览器更好地理解。</p>
<p><code>encodeURI()</code>主要用于整个URI，而<code>encodeURIComponent()</code>主要用于对URI中的某一段进行编码。区别在于，<code>encodeURI()</code>不会对本身属于URI的特殊字符进行编码，而<code>encodeURIComponent()</code>则会对它发现的任何非标准字符进行编码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">"http://www.wrox.com/illegal value.htm#start"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//"http://www.wrox.com/illegal%20value.html#start"</span></span><br><span class="line">alert(<span class="built_in">encodeURI</span>(uri));</span><br><span class="line"></span><br><span class="line"><span class="comment">//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start"</span></span><br><span class="line">alert(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure>
<p><code>encodeURI()</code>和<code>encodeURIComponent()</code>对应的两个方法分别是<code>decodeURI()</code>和<code>decodeURIComponent()</code>（这两个是解码）。</p>
<blockquote>
<p>URI方法<code>encodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURI()</code>和<code>decodeURIComponent()</code>用于替代已经被ECMA-262第3版废弃的<code>escape()</code>和<code>unescape()</code>方法。URI方法能够编码所有Unicode字符，而原来的方法只能正确的编码ASCII字符。</p>
</blockquote>
<h2 id="2-eval-方法"><a href="#2-eval-方法" class="headerlink" title="2.eval()方法"></a>2.eval()方法</h2><p> <code>eval()</code>方法就像一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript字符串。</p>
<p>当解析器发现代码中调用<code>eval()</code>方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过<code>eval()</code>执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"alert(msg)"</span>); <span class="comment">//"hello world"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"function sayHi() &#123; alert('hi'); &#125;"</span>);</span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure>
<p>在<code>eval()</code>中创建的任何变量或函数都不会提升，因为在解析代码的时候，它们被包含在一个字符串中，它们只在<code>eval()</code>执行的时候创建。<br> 严格模式下，在外部访问不到<code>eval()</code>中创建的任何变量和函数，为eval赋值也会导致错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">eval</span> = <span class="string">"hi"</span>; <span class="comment">//causes error</span></span><br></pre></td></tr></table></figure>
<h2 id="5-7-2Math对象"><a href="#5-7-2Math对象" class="headerlink" title="5.7.2Math对象"></a>5.7.2Math对象</h2><p> Math是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。</p>
<ul>
<li><code>Math.abs()</code>：绝对值</li>
<li><code>Math.ceil()</code>：向上取整</li>
<li><code>Math.floor()</code>：向下取整</li>
<li><code>Math.max()</code>：最大值</li>
<li><code>Math.min()</code>：最小值</li>
<li><code>Math.pow()</code>：指数运算</li>
<li><code>Math.sqrt()</code>：平方根</li>
<li><code>Math.log()</code>：自然对数</li>
<li><code>Math.exp()</code>：e的指数</li>
<li><code>Math.round()</code>：四舍五入</li>
<li><code>Math.random()</code>：随机数</li>
</ul>
<h2 id="1-Math对象的静态属性，"><a href="#1-Math对象的静态属性，" class="headerlink" title="1.Math对象的静态属性，"></a>1.Math对象的静态属性，</h2><p><a href="http://javascript.ruanyifeng.com/stdlib/math.html" target="_blank" rel="noopener">参阮一峰</a></p>
<p>提供以下一些数学常数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.E：常数e。</span><br><span class="line"><span class="built_in">Math</span>.LN2：<span class="number">2</span> 的自然对数。</span><br><span class="line"><span class="built_in">Math</span>.LN10：<span class="number">10</span> 的自然对数。</span><br><span class="line"><span class="built_in">Math</span>.LOG2E：以 <span class="number">2</span> 为底的e的对数。</span><br><span class="line"><span class="built_in">Math</span>.LOG10E：以 <span class="number">10</span> 为底的e的对数。</span><br><span class="line"><span class="built_in">Math</span>.PI：常数 Pi。</span><br><span class="line"><span class="built_in">Math</span>.SQRT1_2：<span class="number">0.5</span> 的平方根。</span><br><span class="line"><span class="built_in">Math</span>.SQRT2：<span class="number">2</span> 的平方根。</span><br></pre></td></tr></table></figure>
<h2 id="2-min-和max-方法"><a href="#2-min-和max-方法" class="headerlink" title="2.min()和max()方法"></a>2.min()和max()方法</h2><p>如果参数为空, Math.min返回Infinity, Math.max返回-Infinity。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">5</span>) <span class="comment">// 5 </span></span><br><span class="line"><span class="built_in">Math</span>.min(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">5</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<h2 id="3-舍入方法"><a href="#3-舍入方法" class="headerlink" title="3.舍入方法"></a>3.舍入方法</h2><p>Math.floor方法小于参数值的最大整数 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="number">3.2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">-3.2</span>) <span class="comment">// -4</span></span><br></pre></td></tr></table></figure>
<p>Math.ceil方法返回大于参数值的最小整数（天花板值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">3.2</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">-3.2</span>) <span class="comment">// -3</span></span><br></pre></td></tr></table></figure>
<p> Math.round方法用于四舍五入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.round(<span class="number">0.1</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h2 id="4-random-方法"><a href="#4-random-方法" class="headerlink" title="4.random()方法"></a>4.random()方法</h2><p>Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.random() <span class="comment">// 0.7151307314634323</span></span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    
    <div>
   
    <div>

        
-------------本文结束感谢您的阅读-------------

    
</div>
    
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/读/" rel="tag"># 读</a>
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/note/2018/undefined04/ec13cc6b.html" rel="next" title="关于吃">
                <i class="fa fa-chevron-left"></i> 关于吃
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/note/2018/undefined16/23e5c293.html" rel="prev" title="读《JavaScript高级程序设计》（3）">
                读《JavaScript高级程序设计》（3） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>  


  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="3039535188@qq.com" />
            
              <p class="site-author-name" itemprop="name">3039535188@qq.com</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/shigithup" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/142813973/" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-coffee"></i>豆瓣</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://music.163.com/#/user/home?id=90908294" target="_blank" title="网易云音乐">
                      
                        <i class="fa fa-fw fa-music"></i>网易云音乐</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章-变量、作用域和内存问题"><span class="nav-text">第四章 变量、作用域和内存问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-1-基本类型和引用类型的值"><span class="nav-text">4.1  基本类型和引用类型的值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-1-复制变量值"><span class="nav-text">4.1.1 复制变量值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-2-传递参数"><span class="nav-text">4.1.2 传递参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-2-执行环境及作用域"><span class="nav-text">4.2 执行环境及作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-1-延长作用域链："><span class="nav-text">4.2.1 延长作用域链：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-2-没有块级作用域"><span class="nav-text">4.2.2 没有块级作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-垃圾收集"><span class="nav-text">4.3 垃圾收集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-标记清除"><span class="nav-text">1. 标记清除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-引用计数"><span class="nav-text">2. 引用计数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-4-堆内存与栈内存"><span class="nav-text">4.4 堆内存与栈内存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章-引用类型"><span class="nav-text">第五章 引用类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-1-Object-类型"><span class="nav-text">5.1 Object 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建Object实例的方法有两种。"><span class="nav-text">创建Object实例的方法有两种。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问对象属性"><span class="nav-text">访问对象属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for…in-循环"><span class="nav-text">for…in 循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-2-Array-类型"><span class="nav-text">5.2 Array  类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建数组的方式也有两种："><span class="nav-text">创建数组的方式也有两种：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#length-属性"><span class="nav-text">length 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-1-检测数组"><span class="nav-text">5.2.1 检测数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-2-转换方法"><span class="nav-text">5.2.2 转换方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-3-栈方法"><span class="nav-text">5.2.3 栈方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-4-队列方法"><span class="nav-text">5.2.4 队列方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-5-重排序方法"><span class="nav-text">5.2.5  重排序方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-6-操作方法"><span class="nav-text">5.2.6 操作方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#concat"><span class="nav-text">concat()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slice"><span class="nav-text">slice()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#splice"><span class="nav-text">splice()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-7-位置方法"><span class="nav-text">5.2.7 位置方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-8-迭代方法"><span class="nav-text">5.2.8 迭代方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-9-归并算法"><span class="nav-text">5.2.9 归并算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-Date-类型"><span class="nav-text">5.3 Date 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态方法（Date-方法-而不是通过变量名-方法）"><span class="nav-text">静态方法（Date.方法()而不是通过变量名.方法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Date-parse"><span class="nav-text">1. Date.parse()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Date-UTC"><span class="nav-text">2. Date.UTC()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Date-now"><span class="nav-text">3. Date.now()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例方法"><span class="nav-text">实例方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-4-RegEXp-类型"><span class="nav-text">5.4 RegEXp 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字面量知识点补充"><span class="nav-text">字面量知识点补充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方括号"><span class="nav-text">方括号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元字符"><span class="nav-text">元字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#量词"><span class="nav-text">量词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-1-RegExp-实例属性"><span class="nav-text">5.4.1 RegExp 实例属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-2-实例方法"><span class="nav-text">5.4.2  实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exec（）"><span class="nav-text">exec（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test"><span class="nav-text">test()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-3-RegExp-构造函数属性"><span class="nav-text">5.4.3 RegExp 构造函数属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-5-Function-类型"><span class="nav-text">5.5 Function 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-1-作为值的函数"><span class="nav-text">5.5.1 作为值的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-2-函数内部属性-arguments和this"><span class="nav-text">5.5.2 函数内部属性(arguments和this)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-3-函数属性和方法"><span class="nav-text">5.5.3 函数属性和方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-6-基本包装类型"><span class="nav-text">5.6 基本包装类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-1-Boolean-类型"><span class="nav-text">5.6.1 Boolean 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-2-Number-类型"><span class="nav-text">5.6.2 Number 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#toFixed-方法"><span class="nav-text">toFixed() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toExponential-方法"><span class="nav-text">toExponential() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toPrecision-方法"><span class="nav-text">toPrecision() 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-3-String-类型"><span class="nav-text">5.6.3  String 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-字符方法"><span class="nav-text">1.字符方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-字符串操作方法"><span class="nav-text">2.字符串操作方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concat-方法"><span class="nav-text">concat() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#substring"><span class="nav-text">substring()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slice-1"><span class="nav-text">slice()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-字符串位置的方法"><span class="nav-text">3.字符串位置的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-trim-方法"><span class="nav-text">4.trim() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-字符串大小写转换方法"><span class="nav-text">5.字符串大小写转换方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-字符串的模式匹配方法"><span class="nav-text">6.字符串的模式匹配方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#match"><span class="nav-text">match()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search"><span class="nav-text">search ()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#replace"><span class="nav-text">replace()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#split"><span class="nav-text">split()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-localeCompare"><span class="nav-text">7.localeCompare()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-fromCharCode"><span class="nav-text">8.fromCharCode()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-7-单体内置对象"><span class="nav-text">5.7 单体内置对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-1Global-对象"><span class="nav-text">5.7.1Global 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-URI编码方法"><span class="nav-text">1.URI编码方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-eval-方法"><span class="nav-text">2.eval()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-2Math对象"><span class="nav-text">5.7.2Math对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Math对象的静态属性，"><span class="nav-text">1.Math对象的静态属性，</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-min-和max-方法"><span class="nav-text">2.min()和max()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-舍入方法"><span class="nav-text">3.舍入方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-random-方法"><span class="nav-text">4.random()方法</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">3039535188@qq.com</span>

  
</div>








  <div class="footer-custom">豫ICP备18010326号</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '0cd15a19fbf292a3df3d',
          clientSecret: '94e8970c83d76609f9a1d3ac28a377af4a941bf2',
          repo: 'shigithup.github.io',
          owner: 'shigithup',
          admin: ['shigithup'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>






  




	





  





  













  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("DnTq8pUq5NmYnvPkWfvFf23I-gzGzoHsz", "8V4ErWsnUWnHm7rh6suDGUML");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
<!-- 页面点击小红心 --> <script type="text/javascript" src="/js/src/love.js"></script>
